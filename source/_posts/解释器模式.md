---
title: 解释器模式
date: 2023-10-04 17:51:34
tags:
categories: 设计模式
---

# 1 概念

## **1 定义**

给定一个语言，定义它文法的一种表示。并定义一个解释器，使用这个解释器来解释语言中的句子

类型：行为型

## **2 应用场景**

-  可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 
- 一些重复出现的问题可以用一种简单的语言来进行表
- 一个简单语法需要解释的场景。

## **3 优缺点**

优点：

- 语法由很多类组成，便于扩展

缺点：

- 语法 规则太多时，增加了系统复杂度

# **2 代码实现**

场景：定义表达式【6 100 11 +  * *】，计算逻辑为（100 + 11 ）* * 6

```java
public interface Interpreter {
    int interpret();
}
```

```java
public class NumberInterpreter implements Interpreter {
    private int number;
    public NumberInterpreter(int number){
        this.number=number;
    }
    public NumberInterpreter(String number){
        this.number=Integer.parseInt(number);
    }
    @Override
    public int interpret(){
        return this.number;
    }
}
```

```java
public class AddInterpreter implements Interpreter {
    private Interpreter firstExpression,secondExpression;
    public AddInterpreter(Interpreter firstExpression, Interpreter secondExpression){
        this.firstExpression=firstExpression;
        this.secondExpression=secondExpression;
    }
    @Override
    public int interpret(){
        return this.firstExpression.interpret()+this.secondExpression.interpret();
    }
    @Override
    public String toString(){
        return "+";
    }
}
```

```java
public class MultiInterpreter implements Interpreter {

    private Interpreter firstExpression,secondExpression;
    public MultiInterpreter(Interpreter firstExpression, Interpreter secondExpression){
        this.firstExpression=firstExpression;
        this.secondExpression=secondExpression;
    }
    @Override
    public int interpret(){
        return this.firstExpression.interpret()*this.secondExpression.interpret();
    }
    @Override
    public String toString(){
        return "*";
    }
}
```

```java
public class MyExpressionParser {
    private Stack<Interpreter> stack = new Stack<Interpreter>();

    public int parse(String str) {
        String[] strItemArray = str.split(" ");
        for (String symbol : strItemArray) {
            if (!isOperator(symbol)) {
                Interpreter numberExpression = new NumberInterpreter(symbol);
                stack.push(numberExpression);
                System.out.printf("入栈: %d%n", numberExpression.interpret());
            } else {
                //是运算符号，可以计算
                Interpreter firstExpression = stack.pop();
                Interpreter secondExpression = stack.pop();
                System.out.printf("出栈: %d 和 %d%n",
                        firstExpression.interpret(), secondExpression.interpret());
                Interpreter operator = getExpressionObject(firstExpression, secondExpression, symbol);
                System.out.printf("应用运算符: %s%n", operator);
                int result = operator.interpret();
                NumberInterpreter resultExpression = new NumberInterpreter(result);
                stack.push(resultExpression);
                System.out.printf("阶段结果入栈: %d%n", resultExpression.interpret());
            }
        }
        int result = stack.pop().interpret();
        return result;
    }

    public static boolean isOperator(String symbol) {
        return (symbol.equals("+") || symbol.equals("*"));
    }
    
    public static Interpreter getExpressionObject(Interpreter firstExpression, Interpreter secondExpression, String symbol) {
        if (symbol.equals("+")) {
            return new AddInterpreter(firstExpression, secondExpression);
        } else if (symbol.equals("*")) {
            return new MultiInterpreter(firstExpression, secondExpression);
        }
        return null;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        String geelyInputStr="6 100 11 + *";
        MyExpressionParser expressionParser=new MyExpressionParser();
        int result=expressionParser.parse(geelyInputStr);
        System.out.println("解释器计算结果: "+result);
    }
}
```

输出：

入栈: 6
入栈: 100
入栈: 11
出栈: 11 和 100
应用运算符: +
阶段结果入栈: 111
出栈: 111 和 6
应用运算符: *
阶段结果入栈: 666
解释器计算结果: 666
