---
title: 类加载机制的深度解析
date: 2022-08-24 00:20:48
tags: 类加载机制
categories: JVM调优
---

# 1. 类加载运行全过程

当我们用java命令运行某个类的main函数启动程序时，首先需要通过**类加载器**把主类加载到 JVM。

有如下几步： **加载 >> 验证 >> 准备 >> 解析 >> 初始化 >>** 使用 >> 卸载 

- 加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个**代表这个类的** **.Class对象**，作为这个类的各种数据的访问入口 。
- 验证：校验字节码文件的正确性 
- 准备：给类的静态变量分配内存，并赋予默认值 
- 解析：将**符号引用**替换为直接引用（地址引用）
- **初始化**：对类的静态变量初始化为指定的值，执行静态代码块

# 2. **类加载器**

1. **引导类加载器 (Bootstrap ClassLoader)**：
   - **职责**：加载 Java 核心库中的类，如 `java.lang.*`、`java.util.*` 等。
   - **加载路径**：JVM 启动时指定的 `rt.jar` 或者 `jmod` 文件中的类。
   - **特点**：由 JVM 实现，使用本地代码，不是一个普通的 Java 类。
2. **扩展类加载器 (Extension ClassLoader)**：
   - **职责**：加载标准扩展库中的类，位于 `JAVA_HOME/lib/ext` 目录或由系统属性 `java.ext.dirs` 指定的目录。
   - **加载路径**：`lib/ext` 目录中的 JAR 文件。
   - **特点**：由 Java 实现，继承自 `ClassLoader` 类。
3. **系统类加载器 (System ClassLoader) / 应用程序类加载器 (Application ClassLoader)**：
   - **职责**：加载用户类路径 (`classpath`) 中的类，包含用户定义的类和第三方库。
   - **加载路径**：通过命令行参数 `-classpath` 或环境变量 `CLASSPATH` 指定的路径。
   - **特点**：默认的类加载器，可以通过 `ClassLoader.getSystemClassLoader()` 获取。
4. **自定义类加载器 (Custom ClassLoader)**：
   - **职责**：由用户定义，可以从任意位置加载类，例如网络、数据库等。
   - **加载路径**：用户定义。
   - **特点**：用户可以通过继承 `ClassLoader` 类并覆盖 `findClass` 方法来自定义类加载逻辑。

# 3. 双亲委派机制

当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

<img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20240603232254437.png" alt="image-20240603232254437" style="zoom:50%;" />

loadClass 方法的主要职责就是实现双亲委派机制：首先检查这个类是不是已经被加载过了，如果加载过了直接返回，否则委派给父加载器加载，这是一个递归调用，一层一层向上委派，最顶层的类加载器（启动类加载器）无法加载该类时，再一层一层向下委派给子类加载器加载。

```java
public abstract class ClassLoader {

    //每个类加载器都有个父加载器
    private final ClassLoader parent;
    
    public Class<?> loadClass(String name) {
  
        //查找一下这个类是不是已经加载过了
        Class<?> c = findLoadedClass(name);
        
        //如果没有加载过
        if( c == null ){
          //先委派给父加载器去加载，注意这是个递归调用
          if (parent != null) {
              c = parent.loadClass(name);
          }else {
              // 如果父加载器为空，查找Bootstrap加载器是不是加载过了
              c = findBootstrapClassOrNull(name);
          }
        }
        // 如果父加载器没加载成功，调用自己的findClass去加载
        if (c == null) {
            c = findClass(name);
        }
        
        return c；
    }
    
    protected Class<?> findClass(String name){
       //1. 根据传入的类名name，到在特定目录下去寻找类文件，把.class文件读入内存
          ...
          
       //2. 调用defineClass将字节数组转成Class对象
       return defineClass(buf, off, len)；
    }
    
    // 将字节码数组解析成一个Class对象，用native方法实现
    protected final Class<?> defineClass(byte[] b, int off, int len){
       ...
    }
}
```



## 3.1 作用

1. **防止加载同一个.class。**通过委托去询问上级是否已经加载过该.class，如果加载过了，则不需要重新加载。保证了数据安全。

2. **保证核心.class不被篡改。**通过委托的方式，保证核心.class不被篡改，即使被篡改也不会被加载，即使被加载也不会是同一个class对象，因为不同的加载器加载同一个.class也不是同一个Class对象。这样则保证了Class的执行安全。

## 3.2 如何打破双亲委派？

打破双亲委派，其实就是不走双亲委派那一套，而是走自定义的类加载器。

双亲委派的机制是ClassLoader中的loadClass方法实现的，打破双亲委派，其实就是重写这个方法，来用我们自己的方式来实现即可。典型的打破双亲委派模型的框架和中间件有tomcat。

```java
public class CustomClassLoader extends ClassLoader {
    private final String classPath;

    public CustomClassLoader(String classPath) {
        this.classPath = classPath;
    }
    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        // 尝试加载自定义类
        Class<?> clazz = findClass(name);
        if (clazz != null) {
            return clazz;
        }
        // 自己加载不了，再调用父类loadClass，保持双亲委托模式
        return super.loadClass(name);
    }

    // 自定义类加载逻辑，例如从文件、网络等加载类字节码
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] result;
        String path = classPath + File.separatorChar + name.replace('.', File.separatorChar) + ".class";
        try (FileInputStream fis = new FileInputStream(path)) {
            byte[] buffer = new byte[fis.available()];
            fis.read(buffer);
            result = buffer;
        } catch (IOException e) {
            throw new ClassNotFoundException("Could not load class " + name, e);
        }
        return defineClass(name, result, 0, result.length);
    }
}
```



