---
title: Redis实现分布式锁
date: 2022-09-20 15:03:35
tags:
- 分布式锁
categories: Redis
---

## 1 **基于Redis实现分布式锁**

效率最高，加锁速度最快，因为Redis几乎都是纯内存操作

适用于并发量很大、性能要求很高而可靠性问题可以通过其 他方案去弥补的场景。 

## 1.1 设计原理

- 利用利用Redis的`SETNX key value`这个命令获取锁，并设置过期时间，保存线程标示

- 释放锁时先判断线程标示是否与自己一致，一致则删除锁 (Lua 脚本保证原子性)

>  SETNX key value: 只有当key不存在时才会执行成功，如果key已经存在则命令执行失败。

## 1.2.2 实现注意事项

- Redis 的 increment 并不能满足安全性，如果使用它需要特殊处理增加复杂性，如：
  - ID的组成部分：
    - **符号位**：1bit，永远为0
    - **时间戳**：31bit，以秒为单位，可以使用69年
    - **序列号**：32bit，秒内的计数器，支持每秒产生2^32个不同ID

- 需要设置一个超时时间，因为有可能宕机或者被运维重启了，无法释放锁，但是这个超时时间的长短却不好确定：
  - 设置过短，会导致其他线程提前获得锁，引发线程安全问题
  - 设置过长，线程需要额外等待

- 如果业务执行时间> 过期时间，就需要**锁续命**：搞一个定时任务，设一个间隔时间，小于失效时间，过一段时间去监控业务是否执行完了，执行没结束，也就是锁还没释放，我就再把锁的过期时间重新设置成初始值

## redis分布式锁

![image-20230228222015374](https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222015374.png)

- 多个线程，只有一个线程会执行成功
- 必须使用try catch 在finally中释放锁，否则有异常，锁便没法释放，其他线程进来就会一直执行失败
- 分布式锁需要设置一个超时时间，因为有可能宕机或者被运维重启了，需要保证原子性，写成一个命令

![image-20230228222025578](https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222025578.png)

存在问题：现在有两个线程A，B，加锁时长设置的是10秒

- 线程A先去加锁，执行完所有的逻辑需要 15秒，他加锁成功后，正在执行下面的逻辑，第10秒的时候，锁被释放了
- 线程B加锁成功，执行完所有的逻辑需要 8，执行完逻辑后，删除这把锁
- 线程A逻辑执行完了，去释放锁，但锁已经被线程B释放掉了

避免线程A释放线程B的锁，需要在释放锁时多加一个判断，每个线程只释放自己的锁，不能释放别人的锁！可以给每个线程分配一个唯一的UUID

![image-20230228222036009](https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222036009.png)

存在问题：

**获取client id 和删除redis必须是原子性操作**，因为可能存在线程A执行到删除锁之前刚好到失效时间了，然后又卡顿了，这时候线程B就又可以获得锁，释放锁，导致线程A又没法释放锁

解决方式：

锁续命：搞一个定时任务，设一个间隔时间，小于失效时间，过一段时间去监控业务是否执行完了，执行没结束，也就是锁还没释放，我就再把锁的过期时间重新设置成初始值



**目前还有待完善的点：**

- **不可重入**，同一个线程无法多次获取同一把锁
- **不可重试**，获取锁只尝试一次就返回false，没有重试机制
- **主从一致性**，如果Redis提供了主从集群，主从同步存在延迟，当主宕机时，在主节点中的锁数据并没有及时同步到从节点中，则会导致其他线程也能获得锁，引发线程安全问题（延迟时间是在毫秒以下的，所以这种情况概率极低）

redison

使用：

![image-20230228222056848](https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222056848.png)

原理：

![image-20230228222105112](https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222105112.png)



# 
