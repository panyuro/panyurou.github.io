---
title: zookeeper的使用场景
date: 2022-09-20 16:28:35
tags: 
categories: Zookeeper
---

# 1 ZooKeeper 实现分布式 ID

## 1.1 为什么需要分布式ID

在单体结构的应用中，我们可以使用 MySQL 数据库的主键自增来为我们的数据设置唯一标识 ID，但是在分布式环境中，单个数据库的吞吐量成为整个应用的性能瓶颈，我们就可以搭建数据库集群来提升数据库的性能，此时如果还使用 MySQL 的主键自增来设置数据 ID 的话，就会出现重复的 ID，这样就会出现主键冲突的情况。

如果使用分布式的全局唯一 ID 就不用担心会出现这个问题了

## 1.2 实现方式

### 1.2.1 **UUID实现分布式 ID**

- 在 Java 中可以使用 java.util.UUID 的 randomUUID() 方法来获得：

```java
java.util.UUID.randomUUID().toString();
```

UUID 可以在本地生成，生成速度快，不依赖网络和其它服务，但是 UUID 没有可以识别的特点，也没有顺序性。

### 1.2.2 **Redis实现分布式 ID**

使用 Redis 的 Incr 命令来把 <key,value> 中 key 的数值加 1 并返回，如果这个 key 不存在，则 key 值会被初始化为 0，再执行 Incr 命令来进行加 1 操作

```java
// 使用 incr(key) 来让 key 加 1
long id = jedis.incr("id");
```

使用 Redis 的方式生成分布式 ID 需要依赖 Redis 服务，还要保证 Redis 的高可用，否则 Redis 服务宕机会影响整个应用。

### 1.2.3 Zookeeper 实现分布式 ID

在 Zookeeper 中，我们可以使用 Zookeeper 的 顺序节点来完成分布式 ID 的生成

顺序节点，在 Zookeeper 客户端创建顺序节点时，Zookeeper 会根据创建的时间顺序，在节点名称后添加 10 位的顺序编号。

# 2  Zookeeper 实现负载均衡

## 2.1 为什么需要做负载均衡

在分布式的环境中，我们常常使用集群部署的方式来提高某个服务的可用性，为了让高并发的请求能够平均的分配到集群中的每一个服务，避免有些服务压力过大，而有些服务处于空闲状态这样的情况，我们需要制定一些规则来把请求进行路由，这种分配请求的做法就叫做负载均衡，路由请求的规则就是负载均衡的策略。

## 2.2 负载均衡的策略

### 3.2.1 **轮询策略**

- 轮询策略就是按照集群的服务列表的顺序，依次进行请求的分配，直到列表中所有的服务都分配了一次请求，就完成了一轮的请求分配，然后再从第一个服务开始分配请求。
- 轮询策略是很多负载均衡技术的默认策略，这样的方式保证了的每个服务所承受的请求压力是平均的，我们可以把服务列表按照顺序放到一个数组来循环分配请求。

### 3.2.2 **随机策略**

- 随机策略就是根据随机算法把请求随机的分配给服务列表中的任意一个服务。
- 随机策略的实现方式：我们可以把服务列表放到一个数组，然后根据数组的长度来获取随机数，取到的随机数就是服务在数组中的索引，根据这个索引，我们就可以拿到服务地址来发送请求了

### 3.2.3 **一致性哈希策略**

- 一致性哈希策略的实现方式：我们先把服务列表中的地址进行哈希计算，把计算后的值放到哈希环上，接收到请求后，根据请求的固定属性值来进行哈希计算，然后根据请求的哈希值在哈希环上顺时针寻找服务地址的哈希值，寻找到哪个服务地址的哈希值，就把请求分配给哪个服务。

### 3.2.4 **加权轮询策略**

加权轮询策略就是在轮询策略的基础上，对 Server 地址进行加权处理，除了按照服务地址列表的顺序来分配请求外，还要按照权重大小来决定请求的分配次数。加权的目的是为了让性能和网络较好的服务多承担请求分配的压力。

比如 Server_1 的权重是 3，Server_2 的权重是 2，Server_3 的权重是 1，那么在进行请求分配时，Server_1 会被分配 3 次请求，Server_2 会被分配 2 次请求，Server_3 会被分配 1 次请求，就这样完成一轮请求的分配，然后再从 Server_1 开始进行分配。

### 3.2.5 **加权随机策略**

加权随机策略就是在随机策略的基础上，对 Server 地址进行加权处理，Server 地址的加权有多少，那么 Server 地址的数组中的地址就会有几个，然后再从这个数组中进行随机选址。

### 3.2.6 **最小连接数策略**

最小连接数策略，就是根据客户端与服务端会话数量来决定请求的分配情况，它会把请求分配到会话数量小的服务，会话的数量越少，也能说明服务的性能和网络较好。

## 实现方式

把ZooKeeper作为一个服务的[注册中心](https://cloud.tencent.com/product/tse?from=10680)，在其中登记每个服务，每台服务器知道自己是属于哪个服务，在服务器启动时，自己向所属服务进行登记，这样，一个树形的服务结构就呈现出来了

服务的调用者到注册中心里面查找：能提供所需服务的服务器列表，然后自己根据负载均衡算法，从中选取一台服务器进行连接

# 3 Zookeeper 实现配置中心

配置中心来更新配置的方式有两种，一种是由配置中心的配置更新后向服务推送更新的配置，另一种是服务定时轮询的方式的去配置中心拉取配置，发现配置中心的配置被更新就更新自己的配置。

Zookeeper 实现配置中心的方式：服务把自己的配置信息存储到 Zookeeper 节点的 data 上，并且对这个节点开启 Watch 监听，只要这个节点的数据发生变化，Zookeeper 就会把这个消息推送给服务，服务在回调事件中去获取该节点的数据，然后使用新的数据更新自己的配置。那么根据这个思路，我们就开始使用 Zookeeper 来实现配置中心。

# 4 Zookeeper 实现分布式锁

[Zookeeper实现分布式锁 - 楼上有只喵 (pyr9.github.io)](https://pyr9.github.io/Zookeeper实现分布式锁/)

# 5 Zookeeper 实现注册中心

[注册中心 - 楼上有只喵 (pyr9.github.io)](https://pyr9.github.io/注册中心/)
