<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Jpa和mybatis</title>
    <link href="/Jpa%E5%92%8Cmybatis/"/>
    <url>/Jpa%E5%92%8Cmybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="1-JPA和mybatis的区别"><a href="#1-JPA和mybatis的区别" class="headerlink" title="1. JPA和mybatis的区别"></a>1. JPA和mybatis的区别</h1><p><strong>基本概念</strong></p><ul><li><strong>MyBatis</strong>：<ul><li>是一个半自动化的持久层框架，专注于 SQL 映射和管理。</li><li>提供 SQL 查询、结果映射和存储过程的调用，允许开发者编写自己的 SQL。</li></ul></li><li><strong>JPA</strong>：<ul><li>是 Java EE 和 Java SE 的标准规范，用于对象关系映射（ORM）。</li><li>主要实现包括 Hibernate、spring data jpa 和 OpenJPA。</li><li>提供全自动化的 ORM 功能，开发者通常不需要编写 SQL，而是依赖于 JPA 提供的抽象层。</li></ul></li></ul><p><strong>2. SQL 操作</strong></p><ul><li><strong>MyBatis</strong>：<ul><li>强调手写 SQL，开发者有完全的 SQL 控制权。</li><li>通过 XML 文件或注解定义 SQL 映射。</li><li>更适合对 SQL 有细粒度控制需求的场景。</li></ul></li><li><strong>JPA</strong>：<ul><li>使用 JPQL（Java Persistence Query Language）或 Criteria API 查询，类似于 SQL，但面向对象。</li><li>复杂查询下可以使用QueryDsL 和写nativeSQL</li><li>更侧重于通过实体类操作数据库，减少直接 SQL 的编写。</li><li>对 SQL 的控制较少，但方便数据操作。</li><li>更换数据库平台方便</li></ul></li></ul><p><strong>3. 配置和复杂度</strong></p><ul><li><strong>MyBatis</strong>：<ul><li>配置较为简单，主要通过 XML 文件或注解。</li><li>需要手动管理 SQL 和对象映射，适合复杂 SQL 或存储过程的项目。</li></ul></li><li><strong>JPA</strong>：<ul><li>配置相对复杂，依赖于实体类、关系映射和持久化单元配置。</li><li>通过注解或 XML 文件定义实体类及其关系，自动管理实体的生命周期。</li></ul></li></ul><p><strong>4 性能和灵活性</strong></p><ul><li><strong>MyBatis</strong>：<ul><li>性能较好，尤其在复杂查询和批量操作方面。</li><li>灵活性高，开发者可以优化每个 SQL 语句。</li></ul></li><li><strong>JPA</strong>：<ul><li>提供缓存机制（一级和二级缓存）和延迟加载，提高性能。</li><li>性能受 ORM 层次的影响较大，适合 CRUD 操作较多的应用。</li></ul></li></ul><p><strong>5. 学习曲线</strong></p><ul><li><strong>MyBatis</strong>：<ul><li>学习曲线较平缓，SQL 和映射配置简单直观。</li><li>适合有 SQL 基础的开发者。</li></ul></li><li><strong>JPA</strong>：<ul><li>学习曲线较陡，需要掌握 JPA 规范和面向对象的数据库操作方法。</li><li>适合需要高层次抽象和自动化管理的项目。</li></ul></li></ul><p><strong>6 适用场景</strong></p><ul><li><strong>MyBatis</strong>：<ul><li>适用于需要频繁编写复杂 SQL 的项目。</li><li>适合对 SQL 语句有精细控制要求的应用。</li></ul></li><li><strong>JPA</strong>：<ul><li>适用于标准化 CRUD 操作较多的企业级应用。</li><li>适合需要 ORM 特性和面向对象数据库操作的项目。</li></ul></li></ul><h1 id="2-Mybatis-动态-sql-概念"><a href="#2-Mybatis-动态-sql-概念" class="headerlink" title="2. Mybatis 动态 sql 概念"></a>2. Mybatis 动态 sql 概念</h1><p>摆脱根据不同条件拼接 SQL 语句的痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。MyBatis 中用于实现动态 SQL 的元素主要有：</p><ol><li><p>if 语句 (简单的条件判断)</p></li><li><p>choose (when,otherwize) ,相当于 java 语言中的 switch ,与 jstl 中的choose 很类似.</p></li><li><p>where (主要是用来简化 sql 语句中 where 条件判断的，能智能的处理 and or , 不必担心多余导致语法错误)</p></li><li><p>set (主要用于更新时，功能和 where 标签元素差不多，主要是在包含的语句前输出一个 set，然后如果包含的语句是以逗号结束的话将会把该逗号忽略，如果 set 标签最终返回的内容为空的话则可能会出错（ update set name &#x3D; #{name}, where … ? )</p></li><li><p>trim (trim 元素的主要功能是可以在自己包含的内容前加上某些前缀，也可以在其后加上某些后缀，与之对应的属性是 prefix 和 suffix；可以把包含内容的首部某些内容覆盖，即忽略，也可以把尾部的某些内容覆盖，对应的属性是 prefixOverrides 和 suffixOverrides；正因为 trim 有这样的功能，它可以用来实现 where 和 set 的效果)</p></li><li><p>foreach (java中有for, 可通过for循环， 同样， mybatis中有foreach, 可通过它实现循环，循环的对象当然主要是java集合或数组。)</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jpa的批量优化</title>
    <link href="/jpa%E7%9A%84%E6%89%B9%E9%87%8F%E4%BC%98%E5%8C%96/"/>
    <url>/jpa%E7%9A%84%E6%89%B9%E9%87%8F%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><p>Spring-data-jpa自己带的JpaRepository里有很多现有的方法，如findAll, saveAll, deleteAll ,但是saveAll 和deleteAll 这种底层都是foreach的save或者delete的，性能非常低</p><h1 id="2-优化"><a href="#2-优化" class="headerlink" title="2. 优化"></a>2. 优化</h1><p>可以通过配置<code>hibernate.jdbc.batch_size</code>的方式， 将这些插入操作打包成一个批处理操作，然后一次性发送到数据库执行。</p><p>这样做可以减少通信成本和事务开销，提高性能。但依旧不够，所以需要自己写SQL处理器</p><p>基于PG：</p><h2 id="2-1-insert"><a href="#2-1-insert" class="headerlink" title="2.1 insert"></a>2.1 insert</h2><p>原理： <code>insert into %s (%s) values %s;</code></p><p>注意：</p><ul><li><p>需要自己生成ID， 有一张表维护不同业务表的id_value序号，根据当前业务表，查询出当前id_value, 将当前id_value+ LIst.size+1 作为要更新的新id_value, 更新成功的话，则将之前查询出来的id_value+1和最新id_value返回</p><p><code>update id_value=</code>id_value+ LIst.size+1 where id_value&#x3D;id_value &#96; 利用CAS</p></li><li><p>获取id失败的话，retry一次</p></li></ul><h2 id="2-2-update"><a href="#2-2-update" class="headerlink" title="2.2 update"></a>2.2 update</h2><p>原理： <code>update %s set %s from (values %s) as tmp (%s) where %s.id=tmp.id;</code></p><p>把fields传过去， 不传默认更新所有</p><p>这里就需要更新当前所有的fields， 构建的entity中之遥某个有这个fields，就得都加上</p><p>SQL执行可能有长度和行数限制</p><p>每次从list里取对象进行SQL拼接时，都检查下当前剩余长度是否够用，以及当前行数是否超过限制</p><p>不够的话，再新构建一个SQL将剩下的部分拼接进去</p><p>这次的优化速度提高，是倍数增长的，因为之前需要多个SQL，多次连接多次执行，下载都优化成了一次</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h1><p>关键词：</p><ol><li>满足XXX条件（计算结果，出现次数，同时包含）</li><li>最长&#x2F;最短</li><li>子串&#x2F;子数组&#x2F;子序列</li></ol><p>Eg：长度最小的子数组</p><h1 id="2-使用思路"><a href="#2-使用思路" class="headerlink" title="2. 使用思路"></a>2. 使用思路</h1><h2 id="1-寻找最长"><a href="#1-寻找最长" class="headerlink" title="1. 寻找最长"></a>1. 寻找最长</h2><p>左右双指针（L，R）在起始点，R向右逐位滑动循环</p><p>——每次滑动过程中</p><ul><li>窗内元素满足条件，R向右扩大窗口，并更新最优结果</li><li>窗内元素不满足条件，L向右缩小窗口</li></ul><p>——R到达结尾</p><h2 id="2-模版"><a href="#2-模版" class="headerlink" title="2. 模版"></a>2. 模版</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 初始化 left, right,  currentResult, bestResult<br><span class="hljs-bullet">2.</span> while (右指针没有到达结尾) &#123;<br><span class="hljs-code">     加入right对应元素的值，更新currentResult</span><br><span class="hljs-code">     while (currentResult 不满足要求) &#123;</span><br><span class="hljs-code">        1 窗口缩小，left右移 left++;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    1》更新最优结果 bestResult</span><br><span class="hljs-code">    2》窗口扩大 right右移 right++;</span><br><span class="hljs-code">   &#125;</span><br><span class="hljs-code">3. 返回bestResult</span><br></code></pre></td></tr></table></figure><h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxLengthOfSubString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLengthOfSubString</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(s.charAt(i))) &#123;<br>                left = Math.max(left, map.get(s.charAt(i)) + <span class="hljs-number">1</span>);<br>            &#125;<br>            map.put(s.charAt(i), i);<br>            right = Math.max(right, i - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-string">&quot;abcabcbb&quot;</span>;<br>        <span class="hljs-keyword">int</span> i = maxLengthOfSubString(s);<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-寻找最短"><a href="#2-寻找最短" class="headerlink" title="2. 寻找最短"></a>2. 寻找最短</h2><p>左右双指针（L，R）在起始点，R向右逐位滑动循环</p><p>——每次滑动过程中</p><ul><li>窗内元素满足条件，L向右缩小窗口，并更新最优结果</li><li>窗内元素不满足条件，R向右扩大窗口</li></ul><p>——R到达结尾</p><h2 id="2-模版-1"><a href="#2-模版-1" class="headerlink" title="2. 模版"></a>2. 模版</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 初始化 left, right,  currentResult, bestResult<br><span class="hljs-bullet">2.</span> while (右指针没有到达结尾) &#123;<br><span class="hljs-code">     加入right对应元素的值，更新currentResult</span><br><span class="hljs-code">     while (currentResult 满足要求) &#123;</span><br><span class="hljs-code">        1》更新最优结果 bestResult</span><br><span class="hljs-code">        2》移除left对应元素的值</span><br><span class="hljs-code">        3》窗口缩小，left右移 left++;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    窗口扩大 right右移 right++;</span><br><span class="hljs-code">   &#125;</span><br><span class="hljs-code">3. 返回bestResult</span><br></code></pre></td></tr></table></figure><h2 id="3-例题-1"><a href="#3-例题-1" class="headerlink" title="3. 例题"></a>3. 例题</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续</strong></p><p><strong>子数组</strong></p><p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> minLength = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> curSum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> sLength = nums.length;<br>        <span class="hljs-keyword">if</span> (sLength == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &lt; sLength) &#123;<br>            curSum += nums[right];<br>            <span class="hljs-keyword">while</span> (curSum &gt;= target) &#123;<br>                minLength = Math.min(minLength, right - left + <span class="hljs-number">1</span>);<br>                curSum -= nums[left];<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLength == Integer.MAX_VALUE ? <span class="hljs-number">0</span>: minLength;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>同步阻塞与异步非阻塞的整理</title>
    <link href="/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E6%95%B4%E7%90%86/"/>
    <url>/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-BIO-和NIO"><a href="#1-BIO-和NIO" class="headerlink" title="1. BIO 和NIO"></a>1. BIO 和NIO</h2><p>BIO（Blocking I&#x2F;O）和 NIO（Non-blocking I&#x2F;O）是 Java 中用于处理 I&#x2F;O 操作的两种不同的编程模型。</p><p><strong>BIO（Blocking I&#x2F;O）</strong>：</p><ol><li><strong>同步阻塞</strong>：在 BIO 模型中，I&#x2F;O 操作是同步阻塞的。当一个线程执行一个 I&#x2F;O 操作时，线程会被阻塞，直到这个 I&#x2F;O 操作完成并返回结果。</li><li><strong>阻塞等待</strong>：当执行 I&#x2F;O 操作时，BIO 会让线程一直等待，直到操作完成。这样会导致线程被浪费掉，不能执行其他任务，造成资源的浪费和低效率。</li><li><strong>传统的 I&#x2F;O 模型</strong>：在传统的网络编程中，通常使用 BIO 模型。每个客户端请求都会创建一个新的线程来处理，当连接数量增加时，会导致服务器资源消耗过多，性能下降。</li></ol><p><strong>NIO（Non-blocking I&#x2F;O）</strong>：</p><ol><li><strong>异步非阻塞</strong>：NIO 模型是一种异步非阻塞的 I&#x2F;O 模型。当一个线程执行一个 I&#x2F;O 操作时，线程不会被阻塞，而是继续执行其他任务。当 I&#x2F;O 操作完成后，会通过回调或者其他方式来处理结果。</li><li><strong>事件驱动</strong>：NIO 模型采用事件驱动的方式处理异步操作。当某个 I&#x2F;O 事件发生时，会触发相应的事件处理器或者回调函数。</li><li><strong>通道和缓冲区</strong>：NIO 模型引入了通道（Channel）和缓冲区（Buffer）的概念，可以更灵活地进行数据读写操作。</li></ol><p><strong>总结</strong>：</p><ul><li>BIO 适用于连接数较少且对并发性能要求不高的场景，但是当连接数量增加时，会导致资源消耗过多，性能下降。</li><li>NIO 适用于需要处理大量并发请求、异步操作和事件驱动的场景，能够更有效地利用系统资源，并提高并发处理能力。 NIO 模型是 Java NIO 包中的核心部分，用于构建高性能的网络服务器和客户端应用程序。</li></ul><h2 id="2-阻塞编程和响应式编程"><a href="#2-阻塞编程和响应式编程" class="headerlink" title="2. 阻塞编程和响应式编程"></a>2. 阻塞编程和响应式编程</h2><p>响应式编程（Reactive Programming）是一种基于数据流和变化传播的编程范式，旨在处理异步数据流和事件驱动的编程场景。它的核心思想是将系统中的数据流和事件抽象为流（Stream），并通过一系列的操作符来处理这些流，实现对数据流的异步处理、组合和转换。</p><p>在响应式编程中，常见的角色包括：</p><ol><li><strong>数据源（Data Source）</strong>：产生数据流的源头，可以是用户输入、网络请求、消息队列等。</li><li><strong>流（Stream）</strong>：代表一系列连续的数据项，可以是同步的也可以是异步的。流可以发出数据项、错误或者完成信号。</li><li><strong>观察者（Observer）</strong>：订阅流并对流中的数据项进行处理的组件，它会接收来自流的通知，并定义对数据的处理逻辑。</li><li><strong>操作符（Operator）</strong>：用于对流进行转换、过滤、映射等操作的函数或者方法。操作符可以链式组合，形成复杂的数据处理逻辑。</li></ol><p>响应式编程具有以下特点：</p><ul><li><strong>异步非阻塞</strong>：响应式编程通过异步和非阻塞的方式处理数据流，能够更高效地利用系统资源，并提高并发处理能力。</li><li><strong>数据流处理</strong>：响应式编程将整个应用程序看作是一个数据流的处理管道，可以在数据流中应用各种操作符来实现数据的转换、过滤和聚合。</li><li><strong>事件驱动</strong>：响应式编程是事件驱动的，它通过订阅事件流来处理异步事件，当事件发生时，观察者会收到通知并进行相应的处理。</li><li><strong>背压处理</strong>：响应式编程中通常会处理数据流中的背压（Backpressure），即当数据生产速率大于消费速率时的处理机制，以避免内存溢出和系统崩溃。</li></ul><p>响应式编程在处理现代应用程序中的复杂数据流和事件驱动场景中具有很好的适用性，例如网络通信、实时数据处理、用户界面交互等。常见的响应式编程库包括 Reactor、RxJava、Project Reactor 等。</p><h2 id="3-webFlux"><a href="#3-webFlux" class="headerlink" title="3. webFlux"></a>3. webFlux</h2><p>WebFlux 是 Spring Framework 5 中引入的响应式编程的核心组件之一，用于构建基于响应式编程模型的 Web 应用程序。它提供了一种基于 Reactor 的非阻塞编程模型，能够处理大量并发的请求，并提供了高性能和高吞吐量的特性。</p><p>WebFlux 的主要特点包括：</p><ol><li><strong>非阻塞 I&#x2F;O</strong>：WebFlux 使用了 Reactor 库提供的非阻塞 I&#x2F;O 模型，能够更高效地利用系统资源，并支持处理大量并发的请求。</li><li><strong>响应式编程模型</strong>：WebFlux 基于响应式编程模型，使用 Flux 和 Mono 来表示异步的数据流和操作。Flux 表示的是一个包含多个元素的异步序列，而 Mono 表示的是一个包含零个或一个元素的异步结果。</li><li><strong>函数式风格的路由和处理器</strong>：WebFlux 提供了一种函数式风格的路由和处理器 API，可以通过编程的方式来定义路由规则和请求处理逻辑。</li><li><strong>反应式的核心组件</strong>：作为 Spring Framework 的一部分，WebFlux 提供了与其他 Spring 组件（如 Spring Boot、Spring Data、Spring Security 等）良好集成的能力。</li><li><strong>支持多种网络容器</strong>：WebFlux 不依赖于 Servlet 容器，而是通过 Netty、Undertow 或者 Servlet 3.1+ 容器来运行。这使得 WebFlux 能够更加灵活地选择适合自己场景的网络容器。</li></ol><p>WebFlux 适用于需要处理大量并发请求、异步操作和事件驱动的场景，比如实时数据处理、实时通信、实时监控等。它提供了一种现代化的编程模型，能够更好地应对现代 Web 应用程序的挑战。</p><h2 id="4-netty"><a href="#4-netty" class="headerlink" title="4. netty"></a>4. netty</h2><p>netty 是一个基于 Java NIO 的异步事件驱动的网络应用框架，用于快速开发可维护的高性能的网络服务器和客户端程序。它提供了简单而强大的 API，使得开发者可以轻松地构建各种类型的网络应用，包括实时通信、实时监控、在线游戏等。</p><p>Netty 的主要特点包括：</p><ol><li><strong>异步非阻塞</strong>：Netty 使用了 Java NIO 提供的非阻塞 I&#x2F;O 模型，能够处理大量并发的连接和请求，并且不会阻塞线程，提高了系统的并发处理能力和性能。</li><li><strong>事件驱动</strong>：Netty 是基于事件驱动的编程模型，通过注册和处理事件来进行异步的数据读写操作。当有事件发生时，Netty 会调用相应的处理器（Handler）来处理事件，实现了解耦和高度灵活性。</li><li><strong>高性能和高吞吐量</strong>：Netty 的设计目标之一是提供高性能和高吞吐量的网络通信能力。它采用了零拷贝、内存池等技术来减少内存分配和复制的开销，提高了数据传输的效率。</li><li><strong>可定制性</strong>：Netty 提供了丰富的组件和扩展点，使得开发者可以灵活地定制和扩展网络应用的功能和特性。</li><li><strong>广泛的应用领域</strong>：Netty 被广泛应用于各种领域，包括 Web 服务器、实时通信服务器、消息中间件、游戏服务器、物联网设备等。</li></ol><p>由于其优秀的性能和可扩展性，Netty 已经成为 Java 开发中首选的网络应用框架之一，得到了众多企业和开发者的广泛应用和认可。</p><h2 id="5-zuul和springCloud-Gateway"><a href="#5-zuul和springCloud-Gateway" class="headerlink" title="5. zuul和springCloud Gateway"></a>5. zuul和springCloud Gateway</h2><p>**Zuul1.x(Spring Cloud Netflix Zuul 1.x)**：</p><ol><li><strong>成熟度</strong>：Zuul 是 Netflix 公司开发的一个成熟的网关服务组件，已经在大规模生产环境中被广泛使用和验证。</li><li><strong>基于 Servlet</strong>：Zuul 采用基于 Servlet 的方式构建，它直接与 Servlet 容器（如 Tomcat、Jetty）集成，使用传统的阻塞式 I&#x2F;O 模型。</li><li><strong>同步处理</strong>：Zuul 使用同步处理模型，每个请求都会经过一系列的过滤器链，这些过滤器是同步执行的，如果某个过滤器出现问题，会导致整个请求链条中断。</li><li><strong>功能丰富</strong>：Zuul 提供了丰富的功能和特性，包括路由、负载均衡、请求转发、过滤器、熔断器等，能够满足各种复杂的网关服务需求。</li></ol><p><strong>Zuul 2.x（Spring Cloud Netflix Zuul 2.x）</strong>：</p><ol><li><strong>异步非阻塞</strong>：Zuul 2.x 使用了基于 Netty 的非阻塞式 I&#x2F;O 模型，能够处理大量并发的请求，并提供了高性能和高吞吐量的特性。</li><li><strong>功能丰富</strong>：Zuul 2.x 继承了 Zuul 1.x 的功能，包括路由、负载均衡、请求转发、过滤器、熔断器等，同时还提供了更多的灵活性和扩展性。</li><li><strong>Spring Cloud 生态集成</strong>：Zuul 2.x 是 Spring Cloud 生态系统的一部分，与其他 Spring Cloud 组件（如 Eureka、Ribbon、Spring Cloud Config 等）能够很好地集成。</li><li><strong>网关与微服务架构集成</strong>：Zuul 2.x 可以与 Netflix 提供的其他微服务架构组件集成，如 Eureka 服务注册中心、Ribbon 客户端负载均衡器等。</li></ol><p><strong>Spring Cloud Gateway</strong>：</p><ol><li><strong>基于 Spring WebFlux</strong>：Spring Cloud Gateway 是基于 Spring WebFlux 构建的，使用了 Reactor 提供的非阻塞式 I&#x2F;O 模型，能够更高效地利用系统资源，并提高并发处理能力。</li><li><strong>响应式编程模型</strong>：Spring Cloud Gateway 使用了响应式编程模型，支持异步和非阻塞的请求处理，能够处理大量并发请求。</li><li><strong>灵活性和扩展性</strong>：Spring Cloud Gateway 提供了更大的灵活性和扩展性，支持动态路由、自定义过滤器、熔断器等特性，可以根据需要进行定制和扩展。</li><li><strong>函数式路由定义</strong>：Spring Cloud Gateway 使用函数式的方式来定义路由规则，可以更灵活地定义路由规则和请求处理逻辑。</li></ol><p>Zuul 2.x 和 Spring Cloud Gateway 在基于非阻塞式 I&#x2F;O 模型、响应式编程模型和灵活性等方面具有相似性，但由于 Spring Cloud Gateway 是 Spring Cloud 生态系统的一部分，因此在与其他 Spring Cloud 组件的集成和生态支持方面可能更为优越。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/%E9%9B%86%E5%90%88/"/>
    <url>/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="⼀、集合分类"><a href="#⼀、集合分类" class="headerlink" title="⼀、集合分类"></a>⼀、集合分类</h1><p>Java中的集合框架⼤类可分为Collection和Map，⽽collection⼜有两个⼦接⼝List和Set</p><h2 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. <strong>List</strong></h2><ul><li><p>特点：元素有顺序，能重复 ，可以插⼊多个 null 元素。</p></li><li><p>List 接⼝有三个实现类：LinkedList，ArrayList，Vector</p><ul><li><p>LinkedList：底层基于链表实现，链表内存是散乱的，每⼀个元素存储本身内存地址的同时还存储下⼀个元素的地址。链表增删快，查找慢</p></li><li><p>ArrayList 可变⻓数组，查询快，⾮同步，ArrayList 是⾮线程安全的，效率⾼；</p></li><li><p>Vector 是基于线程安全的，效率低</p></li></ul></li></ul><h2 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. <strong>Set</strong></h2><ul><li><p>特点：元素⽆⽆顺序，不能重复，只允许⼀个 null 元素</p></li><li><p>最流⾏的⼏个实现类是 HashSet、LinkedHashSet 以及 TreeSet</p><ul><li><p>HashSet： HashSet 类按照哈希算法来存取集合中的对象，存取速度⽐较快</p></li><li><p>TreeSet ：TreeSet 类实现了 SortedSet接⼝，能够对集合中的对象进⾏排序。 TreeSet 通过 Comparator 或者Comparable 维护了⼀个排序顺序。</p></li></ul></li></ul><h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3.  Map"></a>3.  <strong>Map</strong></h2><ul><li>特点：元素按键值对存储，⽆放⼊顺序</li><li>最流⾏的⼏个实现类是 HashMap、HashTable、TreeMap、ConcurrentHashMap、LinkedHashMap<ul><li>HashMap:线程不安全的Map,最常用的Map</li><li>HashTable: 线程安全，在各个方法上添加了synchronize关键字，现在已经不再推荐使用HashTable了，因为现在有了ConcurrentHashMap这个专门用于多线程场景下的map实现类，其大大优化了多线程下的性能</li><li>TreeMap：TreeMap也是一个很常用的map实现类，因为他具有一个很大的特点就是会对Key进行排序</li><li>ConcurrentHashMap：是HahsMap的一个子类，但它保持了记录的插入顺序，遍历时先得到的肯定是先插入的，也可以在构造时带参数，按照应用次数排序，在遍历时会比HahsMap慢，不过有个例外，当HashMap的容量很大，实际数据少时，遍历起来会比LinkedHashMap慢（因为它是链啊），因为HashMap的遍历速度和它容量有关，LinkedHashMap遍历速度只与数据多少有关</li></ul></li></ul><h1 id="⼆、常考集合底层实现"><a href="#⼆、常考集合底层实现" class="headerlink" title="⼆、常考集合底层实现"></a>⼆、常考集合底层实现</h1><h2 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.  ArrayList"></a>1.  <strong>ArrayList</strong></h2><h3 id="1-底层实现"><a href="#1-底层实现" class="headerlink" title="1. 底层实现"></a>1. 底层实现</h3><p>ArrayList底层是Object数组存储数据，查找快，增删慢。</p><p>new ArrayList()的初始容量，在jdk1.6中是为10，然⽽在1.8中，如果只是new ArrayList()，容量其实是 0，当第⼀次通过add(e)时，才扩充为10。但它的扩容还是到之前的1.5倍的⼤⼩,每次扩容都是将原数组的数据复制进新数组中。</p><h3 id="2-如何避免ArrayList的并发问题？"><a href="#2-如何避免ArrayList的并发问题？" class="headerlink" title="2.如何避免ArrayList的并发问题？"></a>2.如何避免ArrayList的并发问题？</h3><ol><li>使⽤Vector</li></ol><p>Vector 是线程安全的。它和 ArrayList 差不多，只是在⽅法上加了synchronized 锁，扩容为原来的两倍或原容量 加扩容因⼦（构造时指定）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123; <br>  modCount++;<br>  ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>); elementData\[elementCount++\]= e;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>使⽤Collections.synchronizedList</li></ol><p>使⽤Collections.synchronizedList()⽅法对ArrayList对象进⾏包装,SynchronizedList是线程安全的根本原因是使⽤Synchronized对SynchronizedList的add,delete等操作进⾏加锁，把原来ArrayList在⽅法上加锁替换成了在代码块加锁，但是这种锁的⼒度很⼤，所以这种⽅式效率低下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123; <br>  <span class="hljs-keyword">synchronized</span>(mutex)&#123;<br>    list.add(index, element);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使⽤并发容器CopyOnWriteArrayList</li></ol><p>CopyOnWriteArrayList 是写时复制的容器，就是我们往容器⾥写东⻄时，不是直接写，⽽是先Copy当前容器，然后往新容器⾥添加元素，在将原容器的引⽤指向新容器。</p><ul><li><p>这样做的好处是：可以并发的读，⽽不需要加锁，因为当前容器不会添加任何元素。如果在添加数据的期间，其他线程如果要去读取数据，仍然是读取到旧的容器⾥的数据。</p></li><li><p>CopyOnWriteArrayList是⼀种读写分离的思想，只是在增删改上加锁，但是读不加锁，在读⽅⾯的性能就好于Vector，CopyOnWriteArrayList⽀持读多写少的并发情况。</p></li><li><p>CopyOnWriteArrayList 中的add、set、remove等⽅法，都是 ⽤了 <strong>ReentrantLock</strong> 的lock()来加锁，unlock()来解锁。 当增加元素时使⽤Array.copyOf()来拷⻉副本，在副本上增加元素，然后改变原引⽤指向副本，读操作不加锁。适合读操作远远多于写操作的应⽤。</p></li></ul><p><strong>缺点：</strong></p><p>（1） 内存占⽤问题；</p><p>（2）数据⼀致性问题CopyOnWrite机制只能保证最终的数据⼀致，不能保证实时数据⼀致，因此如果希望写⼊的数据能⻢上读到，就不应该⽤ CopyOnWrite;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock; <br>  lock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    Object[] elements = getArray();<br>    <span class="hljs-keyword">int</span> len = elements.length;<br>    Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>    newElements[len] = e;<br>    setArray(newElements);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123; <br>    lock.unlock();<br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h2><h3 id="1-底层实现-1"><a href="#1-底层实现-1" class="headerlink" title="1.底层实现"></a>1.底层实现</h3><p>LinkedList 是以双向链表实现，链表⽆容量限制，且增删快，查询慢。其内部主要成员为 first 和 last 两个 Node节点，在每次修改列表时⽤来指引当前双向链表的⾸尾部位，来对链表两头的进⾏操作。</p><ul><li>LinkedList线程不安全的，因为其内部添加、删除、等操作，没有进⾏同步操作。</li></ul><h3 id="2-如何避免LinkedList的并发问题？"><a href="#2-如何避免LinkedList的并发问题？" class="headerlink" title="2. 如何避免LinkedList的并发问题？"></a><strong>2.</strong> <strong>如何避免LinkedList的并发问题？</strong></h3><ol><li><p>Collections.synchronizedList</p></li><li><p>ConcurrentLinkedQueue</p><p>ConcurrentLinkedQueue 采⽤ CAS 乐观锁的机制实现⾮阻塞队列（BlockingQueue 阻塞队列）</p></li></ol><h2 id="3-hashMap"><a href="#3-hashMap" class="headerlink" title="3. hashMap"></a>3. <strong>hashMap</strong></h2><h3 id="1-底层实现-2"><a href="#1-底层实现-2" class="headerlink" title="1.底层实现"></a><strong>1.底层实现</strong></h3><p><a href="https://blog.csdn.net/qq_42922647/article/details/97375500">hashMap底层原理</a></p><h3 id="2-HashMap的put实现"><a href="#2-HashMap的put实现" class="headerlink" title="2. HashMap的put实现"></a>2. HashMap的put实现</h3><p>当往hashmap里put(key,value)新元素时，</p><p>利用key计算出hash值，然后再计算下标；求解下标的具体过程为：得到key.hashcode进行高16位^低16位，得到hash值；根据下标index&#x3D;(n - 1) &amp; hash，即可计算出下标。<br>放入节点时，有以下4种情况（源码中用4个if、else实现）：<br>数组原本位置为空，直接放入。<br>数组原本位置不为空，且下面连接了链表，往链表中添加节点，当链表长度为8时，进行树形化，将链表转为红黑树。<br>数组原本位置不为空，且下面连接了红黑树，往树中添加节点，当红黑树的节点个数为6时，将红黑树转为链表。<br>数组原本位置不为空，但要放入的节点的key与当前节点的key相同，则进行值覆盖，用新值替换旧值。</p><h3 id="3-HashMap-是如何扩容的？"><a href="#3-HashMap-是如何扩容的？" class="headerlink" title="3. HashMap 是如何扩容的？"></a>3. HashMap 是如何扩容的？</h3><p><strong>HashMap出现扩容有两种情况：</strong></p><p>在扩容的时候，首元素达到阈值了，即当前容量*0.75。</p><p>hashMap准备树形化但发现数组太短，即小于最小树形化的容量。</p><p><strong>当扩容时有两种情况：</strong></p><p>当前容量已达最大，即长度已经为2^30，则不进行扩容，返回当前数组。</p><p>否则，在现在基础上扩大二倍</p><h3 id="4-为什么以2的n次幂进行扩容？"><a href="#4-为什么以2的n次幂进行扩容？" class="headerlink" title="4. 为什么以2的n次幂进行扩容？"></a>4. <strong>为什么以2的n次幂进行扩容？</strong></h3><p>  在hashmap中数组下标的确定是通过index&#x3D;(n-1)&amp;hash计算的，2^n换成二进制都是“100000….”这种形式，减一后都是“011111..”.这种除了第一位后面几位都是1的二进制数</p><p>这样的话，相当于hashmap的位置，就只和hashcode的值有关，算出来的index是分布均匀的。</p><p>当不全为1，出现“01101”这样的形式，那么与0对应的那一位，不论hashcode值是0还是1，进行与运算后，都会放入同样的位置，这样会大大增加hash冲突。<strong>向扩容后的数组挪动的时候有以下3种情况</strong></p><ul><li>只有一个节点 ：将当前节点置空后，新的位置&#x3D;hash &amp; (newCap - 1)</li><li>数组下有链表：原下标+原容量</li><li>数组下有红黑树：进行分割</li></ul><h3 id="5-JDK1-7-和-JDK1-8-对-HashMap-的实现比较"><a href="#5-JDK1-7-和-JDK1-8-对-HashMap-的实现比较" class="headerlink" title="5. JDK1.7 和 JDK1.8 对 HashMap 的实现比较"></a>5. JDK1.7 和 JDK1.8 对 HashMap 的实现比较</h3><ol><li>底层数据结构不同</li></ol><p>在 HashMap 的 put 过程中，JDK1.7 时是没有红黑树这一概念的，直接是进行的链表存储，<strong>在 JDK1.8 之后才引入了红黑树的概念，来优化存储和查找</strong>。</p><ol start="2"><li>链表的插入方式不同</li></ol><p>在 HashMap 向链表中插入元素的过程中，JDK1.7 时是在表头节点插入的，JDK1.8 之后是在尾节点插入的。简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后</p><ol start="3"><li>扩容后数存储位置的计算方式不同</li></ol><p> 扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，位置不变或索引+旧容量大小； 在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容； </p><h2 id="6-HashMap-的哈希函数怎么设计的吗？"><a href="#6-HashMap-的哈希函数怎么设计的吗？" class="headerlink" title="6. HashMap 的哈希函数怎么设计的吗？"></a>6. HashMap 的哈希函数怎么设计的吗？</h2><p>hash 函数是先拿到通过 key 的 hashcode，是 32 位的 int 值，然后让 hashcode 的高 16 位和低 16 位进行异或操作。</p><p><strong>为什么这么设计吗？</strong></p><ul><li>高16位与低16位：是为了避免没有高位参与运算引起的碰撞。</li><li>异或：因为异或属于逻辑运算，在硬盘上实现的，运算速度快，像+、-、这种都属于算数运算，速度较慢。</li></ul><h3 id="7-链表的插入方式为什么从头插法改成了尾插法？"><a href="#7-链表的插入方式为什么从头插法改成了尾插法？" class="headerlink" title="7. 链表的插入方式为什么从头插法改成了尾插法？"></a>7. 链表的插入方式为什么从头插法改成了尾插法？</h3><p>1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环； A 线程在插入节点 B，B 线程也在插入，遇到容量不够开始扩容，重新 hash，放置元素，采用头插法，后遍历到的 B 节点放入了头部，这样形成了环，</p><h3 id="8-如何避免hashMap的并发问题？"><a href="#8-如何避免hashMap的并发问题？" class="headerlink" title="8. 如何避免hashMap的并发问题？"></a>8. 如何避免hashMap的并发问题？</h3><p><strong>1.</strong> <strong>Hashtable</strong></p><p>HashTable的主要⽅法的源码实现逻辑，与HashMap中⾮常相似，但它的所有的操作都是通过添加synchronized锁的，从⽽实现了线程安全，尽管JVM对它做了优化，但效率还是不⾼。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123; <br>  <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>&#125;<br></code></pre></td></tr></table></figure><p>2 <strong>ConcurrentHashMap</strong></p><p>我们常⽤的是java.util.concurrent包下的ConcurrentHashMap</p><p><strong>1.原理概述</strong></p><p><strong>之前的版本：</strong></p><p>1. ConcurrentHashMap通过在CAS和分段加锁来实现同步，分段加锁就是在ConcurrentHashMap 中，就是把 Map 分成了N 个 Segment（默认 16个），进⽽减⼩锁的⼒度。</p><p>2.put 和 get 的时候，都是现根据 key.hashCode()算出放到哪个 Segment中。Segment 在实现上继承了 ReentrantLock，这样就⾃带了锁的功能，在put<br>的时候需要锁住 Segment，get 时候不加锁，使⽤ volatile 来保证可⻅性。</p><p><strong>jdk1.8：</strong></p><p>1.ConcurrentHashMap 取消了 segment 分段锁，⽽采⽤ CAS 和 synchronized来保证并发安全。数据结构跟 HashMap1.8 的结构⼀样，也是在链表节点数达到 8个时，转为红⿊树。</p><p>2.synchronized只锁定当前链表或红⿊⼆叉树的⾸节点，这样只要hash不冲突，就不会产⽣并发，效率⼜提升N倍。（之前是固定的段数N，现在是根据数组⻓度呈线性变化的)</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/jxg0via1.png"></p><p><strong>2.put</strong> <strong>实现</strong></p><p>与hashmap⼤体⼀致，就是据 key 的 hash 值找到 node 数组相应位置后1.如果相应 node 还未初始化，则调⽤ <strong>CAS</strong> 操作插⼊相应数据。</p><p>2.如果相应位置 node 不为空，则使⽤<strong>synchronized</strong>同步代码块对链表和红⿊树进⾏更新插⼊操作。以此来实现同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">int</span> hash = spread(key.hashCode());<br>        <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>            Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br>            <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>                tab = initTable();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<br>                             <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))<br>                    <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>                tab = helpTransfer(tab, f);<br>            <span class="hljs-keyword">else</span> &#123;<br>                V oldVal = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                    <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                        <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                            binCount = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                                K ek;<br>                                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                    ((ek = e.key) == key ||<br>                                     (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                    oldVal = e.val;<br>                                    <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                        e.val = value;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                                Node&lt;K,V&gt; pred = e;<br>                                <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;<br>                                    pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,<br>                                                              value, <span class="hljs-keyword">null</span>);<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                            Node&lt;K,V&gt; p;<br>                            binCount = <span class="hljs-number">2</span>;<br>                            <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                           value)) != <span class="hljs-keyword">null</span>) &#123;<br>                                oldVal = p.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    p.val = value;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                        treeifyBin(tab, i);<br>                    <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)<br>                        <span class="hljs-keyword">return</span> oldVal;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        addCount(<span class="hljs-number">1L</span>, binCount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="4-HashSet"><a href="#4-HashSet" class="headerlink" title="4 HashSet"></a><strong>4</strong> <strong>HashSet</strong></h2><h3 id="1-底层实现-3"><a href="#1-底层实现-3" class="headerlink" title="1 底层实现"></a>1 底层实现</h3><p>HashSet 底层是使⽤ HashMap来保存元素的,元素都存到HashMap键值对的Key上⾯，⽽Value它定义了⼀个统⼀的虚拟的Object对象。它最⼤的特点就是可以去重。</p><p><strong>1.</strong> <strong>add</strong> <strong>⽅法（HashSet去重原理）</strong></p><p>add ⽅法调⽤的是 HashMap 的 put ⽅法向 HashSet添加元素，实际是往map成员变量⾥⾯添加对应的key和 value，map中的key实际就是要添加的元素，value是⼀个固定的对象，具体操作为：</p><p>1.HashSet 在存元素时会调⽤对象的 hashCode ⽅法计算出存储索引位置<br>2.如果其索引位置已经存在元素（哈希碰撞）则和该索引位置上所有的元素进⾏equals ⽐较，如果该位置没有其 他元素或者⽐较的结果都为 false就存进去，否则就不存。<br>3.所以可以看⻅元素是按照哈希值来找位置的，故⽽⽆序且可以保证⽆重复元素，因此我们在往HashSet 集合中存 储元素时，元素对象应该正确重写Object 类的 hashCode 和equals ⽅法，否则会出现不可预知的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>HashSet 不是线程安全的，底层的 HashMap不是线程安全的，它⾃然就不是啦，可以使⽤Collections.synchronizedSet(new HashSet()) 来创建线程安全的 HashSet。</p></li><li><p>由于 hashMap 中的 key 不能重复，所以 hashSet 不能存储重复元素；</p></li></ul><h3 id="2-如何避免HashSet的并发问题？"><a href="#2-如何避免HashSet的并发问题？" class="headerlink" title="2.如何避免HashSet的并发问题？"></a><strong>2.如何避免HashSet的并发问题</strong>？</h3><ol><li><p>CopyOnWriteArraySet</p><p>CopyOnWriteArraySet底层实现是利⽤数组，它的上层实现是CopyOnWriteArrayList。</p><p>CopyOnWriteArraySet是⼀个集合，所以它是不可以放置重复的元素的，它的取重逻辑是在add中体现的。</p><p>CopyOnWriteArraySet 是利⽤ CopyOnWriteArrayList来实现的，因为CopyOnWriteArrayList 是线程安全 的，所以CopyOnWriteArraySet 操作也是线程安全的</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s常用命令</title>
    <link href="/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1-用频率最高的K8s常用命令"><a href="#1-用频率最高的K8s常用命令" class="headerlink" title="1. 用频率最高的K8s常用命令"></a>1. 用频率最高的K8s常用命令</h4><ul><li><code>kubectl get</code>: 获取资源的信息，如获取Pod、Service、Deployment等资源的状态信息。</li><li><code>kubectl create</code>: 创建资源，如创建Pod、Service、Deployment等资源。</li><li><code>kubectl delete</code>: 删除资源，如删除Pod、Service、Deployment等资源。</li><li><code>kubectl apply</code>: 应用配置文件，如应用Deployment的配置文件。</li><li><code>kubectl describe</code>: 查看资源的详细信息，如查看Pod、Service、Deployment等资源的详细配置和状态信息。</li></ul><h4 id="2-难度较高的K8s常用命令"><a href="#2-难度较高的K8s常用命令" class="headerlink" title="2. 难度较高的K8s常用命令"></a>2. 难度较高的K8s常用命令</h4><ul><li><code>kubectl exec</code>: 在容器内部执行命令，如在Pod内部执行命令或访问容器内部的终端。</li><li><code>kubectl port-forward</code>: 将集群内的服务端口转发到本地，用于本地访问集群内的服务。</li><li><code>kubectl logs</code>: 查看Pod的日志信息，如查看容器的标准输出和标准错误输出。</li><li><code>kubectl scale</code>: 调整资源的副本数，如调整Deployment的副本数。</li><li><code>kubectl rollout</code>: 控制应用的滚动更新，如进行版本升级或回滚。</li></ul><h4 id="3-易错的K8s常用命令"><a href="#3-易错的K8s常用命令" class="headerlink" title="3. 易错的K8s常用命令"></a>3. 易错的K8s常用命令</h4><ul><li><code>kubectl get pods</code>: 获取Pod的信息时，常常忘记加<code>s</code>，导致无法获取到Pod的状态信息。</li><li><code>kubectl create -f &lt;file&gt;</code>: 创建资源时，忘记指定配置文件，导致资源无法创建成功。</li><li><code>kubectl delete pod &lt;pod-name&gt;</code>: 删除Pod时，忘记指定Pod的名称，导致无法删除指定的Pod。</li><li><code>kubectl apply -f &lt;file&gt;</code>: 应用配置文件时，忘记指定配置文件，导致配置文件无法生效。</li><li><code>kubectl describe &lt;resource&gt;</code>: 查看资源的详细信息时，忘记指定资源的名称，导致无法获取到详细信息。</li></ul><h4 id="4-其他命令"><a href="#4-其他命令" class="headerlink" title="4. 其他命令"></a>4. 其他命令</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Kubernetes</span>（K<span class="hljs-number">8</span>s） 常用命令~<br></code></pre></td></tr></table></figure><ol><li>kubectl get pods：获取当前集群中所有的Pods。</li><li>kubectl describe pod [pod名称]：显示指定Pod的详细信息。</li><li>kubectl create -f [yaml文件]：使用yaml文件创建一个资源（如Pod、Deployment等）。</li><li>kubectl apply -f [yaml文件]：使用yaml文件创建或更新一个资源。</li><li><code>kubectl delete pod [pod名称]</code>：删除指定的Pod。</li><li>kubectl scale deployment [deployment名称] –replicas&#x3D;[副本数量]：扩展或缩减指定Deployment的副本数量。</li><li>kubectl exec -it [pod名称] [命令]：在指定的Pod中执行命令。</li><li>kubectl logs [pod名称]：查看指定Pod的日志。</li><li>kubectl port-forward [pod名称] [本地端口]:[远程端口]：将本地端口与Pod中的端口进行转发。</li><li>kubectl get deployments：获取当前集群中所有的Deployments。</li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s</title>
    <link href="/k8s/"/>
    <url>/k8s/</url>
    
    <content type="html"><![CDATA[<h1 id="1-K8s简介"><a href="#1-K8s简介" class="headerlink" title="1 K8s简介"></a>1 K8s简介</h1><ul><li><p>Kubernetes（通常简称为K8s）是一个开源的容器编排和管理平台，用于<strong>自动化部署</strong>、<strong>扩展</strong>和<strong>管理容器化应用程序</strong>。它提供了一组丰富的功能和工具，用于简化容器化应用程序的部署、伸缩和运维。</p></li><li><p>K8s需要一个集群来运行和管理容器化应用程序。</p></li><li><p>Kubernetes 集群由多个计算节点组成，其中包括主节点（Master Node）和从节点（Worker Node）。</p><ul><li><p>主节点负责管理和控制整个集群的状态和配置，安装了K8s的核心组件</p></li><li><p>从节点是实际运行容器的计算节点。</p><ul><li>从节点（Worker Node）上的容器化环境一般是通过 Docker 运行的。</li><li>每个 Worker Node 上可以运行多个容器， 其中每个容器都可以托管一个或多个 Pod。</li></ul></li></ul></li></ul><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20240122164513407.png" alt="image-20240122164513407" style="zoom:70%;" /><h1 id="2-重要概念"><a href="#2-重要概念" class="headerlink" title="2 重要概念"></a>2 重要概念</h1><h2 id="2-1-Pod"><a href="#2-1-Pod" class="headerlink" title="2.1 Pod"></a>2.1 Pod</h2><ul><li>Pod 是一种逻辑概念，用于组织和管理容器的基本单位。</li><li>它是一个抽象的概念，用于封装一个或多个相关的容器、存储卷、网络和其他资源</li><li>所有的应用，服务最终都是运行在pod上，pod是一个容器</li><li>pod有一个独立的ip，pod里的容器可以共享网络，共享IP</li><li>pod里面可以有任意多个容器，以及任意多个存储(volumn)</li></ul><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20240122142025469.png" alt="image-20240122142025469" style="zoom:50%;" /><ul><li>k8s调度pod, 把pod运行起来<ul><li>Pod在node上运行，一个Node上可以有任意多个pod</li></ul></li></ul><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20240122143320022.png" alt="image-20240122143320022" style="zoom:33%;" /><h2 id="2-2-service"><a href="#2-2-service" class="headerlink" title="2.2 service"></a>2.2 service</h2><ul><li><p>service是一个逻辑层的概念，将一堆pod通过打标签的方式，划分成逻辑组，从而方便实现负载均衡</p></li><li><p>下图三个pod对应一个service B，通常表示一个应用的多个副本，即对同一个应用扩容，从一个实例变成了三个，他们对外提供相同的服务。通过service的IP可以对多个Pod的地址进行负载均衡</p><blockquote><p>灰度发布的时候，可以先将一个版本改掉，再依次改其他的</p></blockquote></li></ul><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20240122144759597.png" alt="image-20240122144759597" style="zoom:50%;" /><ul><li>通过打标签的方式识别Pod属于哪个service</li></ul><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20240122145618560.png" alt="image-20240122145618560" style="zoom:50%;" /><blockquote><p>为什么Pod已经有了IP还需要service再包一层呢？</p><ul><li>当Pod出现意外挂掉时，这个服务无法访问，他肯定会去其他位置新启动一个服务，通过service的IP依旧可以找到这个新建的服务</li></ul></blockquote><h2 id="2-3-Deployment"><a href="#2-3-Deployment" class="headerlink" title="2.3 Deployment"></a>2.3 Deployment</h2><ul><li><p>Deployment 可以部署service，也可以部署Pod</p><p>这张图可以理解为：在master上发起了一个deployment，选中了三个节点中的一个，然后部署了一个新的应用，运行在容器中</p></li></ul><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20240122141719723.png" alt="image-20240122141719723" style="zoom: 50%;" /><ul><li>怎么通过deployment完成应用扩容？<ol><li>从master发起一个，想给service里的一个Pod，扩容成4个实例</li><li>在其他节点上启动pod，通过打标签将这组pod标识为同一个service</li><li>service可以感知哪个pod出现问题，然后就不会把流量转发给他</li></ol></li><li>滚动更新的过程：停掉一个pod启动一个，停掉一个启动一个</li></ul><h1 id="3-基础集群部署"><a href="#3-基础集群部署" class="headerlink" title="3 基础集群部署"></a>3 基础集群部署</h1><h2 id="1-部署ETCD（主节点）"><a href="#1-部署ETCD（主节点）" class="headerlink" title="1. 部署ETCD（主节点）"></a>1. 部署ETCD（主节点）</h2><p> kubernetes需要存储很多东西，像它本身的节点信息，组件信息，还有通过kubernetes运行的pod，deployment，service等等。都需要持久化。etcd就是它的数据中心。生产环境中为了保证数据中心的高可用和数据的一致性，一般会部署最少三个节点。</p><p>端口：2379， 2380</p><h2 id="2-部署APIServer（主节点）"><a href="#2-部署APIServer（主节点）" class="headerlink" title="2. 部署APIServer（主节点）"></a>2. 部署APIServer（主节点）</h2><p>kube-apiserver是Kubernetes最重要的核心组件之一，主要提供以下的功能</p><ul><li>提供集群管理的REST API接口，包括认证授权（我们现在没有用到）数据校验以及集群状态变更等</li><li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）</li></ul><blockquote><p>生产环境为了保证apiserver的高可用一般会部署2+个节点，在上层做一个lb做负载均衡，比如haproxy。</p></blockquote><p>端口：6443， 8080</p><h2 id="3-部署ControllerManager（主节点）"><a href="#3-部署ControllerManager（主节点）" class="headerlink" title="3. 部署ControllerManager（主节点）"></a>3. 部署ControllerManager（主节点）</h2><ul><li><p>Controller Manager是Kubernetes的大脑，它通过apiserver监控整个集群的状态，并确保集群处于预期的工作状态。 </p></li><li><p>Controller Manager由kube-controller-manager和cloud-controller-manager组成。</p><ul><li>kube-controller-manager由一系列的控制器组成，像Replication Controller控制副本，Node Controller节点控制，Deployment Controller管理deployment等等</li><li>cloud-controller-manager在Kubernetes启用Cloud Provider的时候才需要，用来配合云服务提供商的控制</li></ul></li></ul><h2 id="4-部署Scheduler（主节点）"><a href="#4-部署Scheduler（主节点）" class="headerlink" title="4. 部署Scheduler（主节点）"></a>4. 部署Scheduler（主节点）</h2><p>kube-scheduler负责分配调度Pod到集群内的节点上，它监听kube-apiserver，查询还未分配Node的Pod，然后根据调度策略为这些Pod分配节点。kubernetes的各种调度策略就是它实现的。</p><h2 id="5-部署CalicoNode（所有节点）"><a href="#5-部署CalicoNode（所有节点）" class="headerlink" title="5. 部署CalicoNode（所有节点）"></a>5. 部署CalicoNode（所有节点）</h2><p>Calico实现了CNI接口，是kubernetes网络方案的一种选择，它一个纯三层的数据中心网络方案（不需要Overlay），并且与OpenStack、Kubernetes、AWS、GCE等IaaS和容器平台都有良好的集成。 </p><p>Calico在每一个计算节点利用Linux Kernel实现了一个高效的vRouter来负责数据转发，而每个vRouter通过BGP协议负责把自己上运行的workload的路由信息像整个Calico网络内传播——小规模部署可以直接互联，大规模下可通过指定的BGP route reflector来完成。 这样保证最终所有的workload之间的数据流量都是通过IP路由的方式完成互联的。</p><h2 id="6-配置kubectl命令（任意节点）"><a href="#6-配置kubectl命令（任意节点）" class="headerlink" title="6. 配置kubectl命令（任意节点）"></a>6. 配置kubectl命令（任意节点）</h2><p>kubectl是Kubernetes的命令行工具，是Kubernetes用户和管理员必备的管理工具。 kubectl提供了大量的子命令，方便管理Kubernetes集群中的各种功能。</p><h2 id="7-配置kubelet（工作节点）"><a href="#7-配置kubelet（工作节点）" class="headerlink" title="7. 配置kubelet（工作节点）"></a>7. 配置kubelet（工作节点）</h2><p>每个工作节点上都运行一个kubelet服务进程，默认监听10250端口，接收并执行master发来的指令，管理Pod及Pod中的容器。每个kubelet进程会在API Server上注册节点自身信息，定期向master节点汇报节点的资源使用情况，并通过cAdvisor监控节点和容器的资源。</p><h1 id="四、kubernetes集群部署微服务"><a href="#四、kubernetes集群部署微服务" class="headerlink" title="四、kubernetes集群部署微服务"></a>四、kubernetes集群部署微服务</h1><h5 id="我们有如下微服务："><a href="#我们有如下微服务：" class="headerlink" title="我们有如下微服务："></a>我们有如下微服务：</h5><ul><li>消息服务：message-service</li><li>课程dubbo服务：course-dubbo-service</li><li>课程web服务：course-edge-service</li><li>用户thrift服务：user-thrift-service</li><li>用户web服务：user-edge-service</li><li>API网关：api-gateway</li></ul><h5 id="把它们放到kubernetes集群运行我们要考虑什么问题？"><a href="#把它们放到kubernetes集群运行我们要考虑什么问题？" class="headerlink" title="把它们放到kubernetes集群运行我们要考虑什么问题？"></a>把它们放到kubernetes集群运行我们要考虑什么问题？</h5><ul><li><p>哪些服务适合单独成为一个pod？哪些服务适合在一个pod中？</p><p>如果把多个服务放在一个pod里，他们之间的访问效率会高。直接可以通过localhost访问在同一pod的其他服务</p><ul><li>课程web服务的接口主要是课程dubbo服务调用，故他们两个放在一个pod</li><li>消息服务以及API网关和其他服务关系不大，所以彼此单独放在一个pod</li></ul></li><li><p>在一个pod里面的服务如何彼此访问？他们的服务如何对外提供服务？</p></li><li><p>单独的pod如何对外提供服务？</p></li><li><p>哪个服务作为整个服务的入口，入口服务如何对外提供服务？</p></li></ul><p>每个微服务下都有一个Dockerfile以及一个build.sh ,build.sh 就是执行docker build ,并且将打包好的镜像放到docker仓库上</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker搭建ELK</title>
    <link href="/docker%E6%90%AD%E5%BB%BAELK/"/>
    <url>/docker%E6%90%AD%E5%BB%BAELK/</url>
    
    <content type="html"><![CDATA[<h1 id="1-ELK是什么？"><a href="#1-ELK是什么？" class="headerlink" title="1. ELK是什么？"></a>1. ELK是什么？</h1><p>ELK主要由ElasticSearch、Logstash和Kibana三个开源工具组成，还有其他专门由于收集数据的轻量型数据采集器Beats。</p><ul><li>Elasticsearch ：分布式搜索引擎。具有高可伸缩、高可靠、易管理等特点。可以用于全文检索、结构化检索和分析，并能将这三者结合起来。Elasticsearch 是用Java 基于 Lucene 开发，现在使用最广的开源搜索引擎之一，Wikipedia 、StackOverflow、Github 等都基于它来构建自己的搜索引擎。在elasticsearch中，所有节点的数据是均等的。</li><li>Logstash ：数据收集处理引擎。支持动态的从各种数据源搜集数据，并对数据进行过滤、分析、丰富、统一格式等操作，然后存储以供后续使用。</li><li>Kibana ：可视化化平台。它能够搜索、展示存储在 Elasticsearch 中索引数据。使用它可以很方便的用图表、表格、地图展示和分析数据。</li><li>Filebeat：轻量级数据收集引擎。相对于Logstash所占用的系统资源来说，Filebeat 所占用的系统资源几乎是微乎及微。它是基于原先 Logstash-fowarder 的源码改造出来。换句话说：Filebeat就是新版的 Logstash-fowarder，也会是 ELK Stack 在 Agent 的第一选择。</li></ul><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><h2 id="2-1-创建docker网络"><a href="#2-1-创建docker网络" class="headerlink" title="2.1 创建docker网络"></a>2.1 <strong>创建docker网络</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create -d bridge elastic<br></code></pre></td></tr></table></figure><h2 id="2-2-安装ES"><a href="#2-2-安装ES" class="headerlink" title="2.2 安装ES"></a>2.2 安装ES</h2><h3 id="1-拉取镜像"><a href="#1-拉取镜像" class="headerlink" title="1. 拉取镜像"></a>1. 拉取镜像</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull elasticsearch:<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="2-创建挂载目录并授权"><a href="#2-创建挂载目录并授权" class="headerlink" title="2. 创建挂载目录并授权"></a>2. 创建挂载目录并授权</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> /etc/elk<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span>/elasticsearch<br><span class="hljs-attribute">sudo</span> chown -R <span class="hljs-number">1000</span>:<span class="hljs-number">1000</span> /etc/elk<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span>/elasticsearch<br></code></pre></td></tr></table></figure><h3 id="3-第一次执行docker启动脚本"><a href="#3-第一次执行docker启动脚本" class="headerlink" title="3. 第一次执行docker启动脚本"></a>3. 第一次执行docker启动脚本</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run -<span class="hljs-literal">it</span> <span class="hljs-string">\</span><br>    -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> <span class="hljs-string">\</span><br>    -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> <span class="hljs-string">\</span><br>    --name elasticsearch <span class="hljs-string">\</span><br>    --net elastic <span class="hljs-string">\</span><br>    -e ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms1g -Xmx1g&quot;</span> <span class="hljs-string">\</span><br>    -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> <span class="hljs-string">\</span><br>    -e LANG=C.UTF-<span class="hljs-number">8</span> <span class="hljs-string">\</span><br>    -e LC_ALL=C.UTF-<span class="hljs-number">8</span> <span class="hljs-string">\</span><br>    elasticsearch:<span class="hljs-number">8.4</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="4-将容器内的文件复制到主机上"><a href="#4-将容器内的文件复制到主机上" class="headerlink" title="4. 将容器内的文件复制到主机上"></a>4. 将容器内的文件复制到主机上</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp elasticsearch:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>config <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span>/elasticsearch<br>docker cp elasticsearch:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>data <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span>/elasticsearch<br>docker cp elasticsearch:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>plugins <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span>/elasticsearch<br>docker cp elasticsearch:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>logs <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span>/elasticsearch<br></code></pre></td></tr></table></figure><h3 id="5-修改配置文件"><a href="#5-修改配置文件" class="headerlink" title="5. 修改配置文件"></a>5. 修改配置文件</h3><p><code>/etc/elk8.4.3/elasticsearch/config/elasticsearch.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">&quot;docker-cluster&quot;</span><br><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><br><span class="hljs-comment"># Enable security features</span><br><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-attr">http.cors.allow-headers:</span> <span class="hljs-string">Authorization</span><br><br><span class="hljs-attr">xpack.security.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">xpack.security.enrollment.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">xpack.monitoring.collection.enabled:</span> <span class="hljs-literal">true</span><br><br><br><span class="hljs-comment"># Enable encryption for HTTP API client connections, such as Kibana, Logstash, and Agents</span><br><span class="hljs-attr">xpack.security.http.ssl:</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">keystore.path:</span> <span class="hljs-string">certs/http.p12</span><br><br><span class="hljs-comment"># Enable encryption and mutual authentication between cluster nodes</span><br><span class="hljs-attr">xpack.security.transport.ssl:</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">verification_mode:</span> <span class="hljs-string">certificate</span><br>  <span class="hljs-attr">keystore.path:</span> <span class="hljs-string">certs/transport.p12</span><br>  <span class="hljs-attr">truststore.path:</span> <span class="hljs-string">certs/transport.p12</span><br></code></pre></td></tr></table></figure><h3 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker rm <span class="hljs-string">/elasticsearch</span><br></code></pre></td></tr></table></figure><h3 id="7-修改docker启动脚本，增加-v挂载目录"><a href="#7-修改docker启动脚本，增加-v挂载目录" class="headerlink" title="7. 修改docker启动脚本，增加-v挂载目录"></a>7. 修改docker启动脚本，增加-v挂载目录</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -it \<br>    -d \<br>    -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> \<br>    -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> \<br>    --name elasticsearch \<br>    --net elastic \<br>    -e ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms1g -Xmx1g&quot;</span> \<br>    -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> \<br>    -e LANG=C.UTF-<span class="hljs-number">8</span> \<br>    -e LC_ALL=C.UTF-<span class="hljs-number">8</span> \<br>    -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/elasticsearch/</span>config:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>config \<br>    -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/elasticsearch/</span>data:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>data \<br>    -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/elasticsearch/</span>plugins:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>plugins \<br>    -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/elasticsearch/</span>logs:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>logs \<br>    elasticsearch:<span class="hljs-number">8.4</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="8-设置用户密码"><a href="#8-设置用户密码" class="headerlink" title="8. 设置用户密码"></a>8. 设置用户密码</h3><ul><li>进入容器 <code>docker exec -it elk /bin/bash</code></li><li>进入bin目录 <code>cd bin</code></li><li>给elastic，kibana_system 设置密码为“sith-mes” ,执行<code>./elasticsearch-setup-passwords interactive </code>或<code>elasticsearch-reset-password -u elastic -i</code></li><li>重启容器</li></ul><h3 id="9-配置Monitoring监控日志"><a href="#9-配置Monitoring监控日志" class="headerlink" title="9. 配置Monitoring监控日志"></a>9. 配置Monitoring监控日志</h3><p>避免实例的大部分空间被监控索引占用，可通过以下两种方式进行优化（实际使用中，可以将以上两种方案结合使用）</p><p><a href="https://help.aliyun.com/zh/es/user-guide/configure-monitoring-indexes">如何配置Monitoring监控日志_检索分析服务 Elasticsearch版(ES)-阿里云帮助中心 (aliyun.com)</a></p><h2 id="2-3-安装Kibana"><a href="#2-3-安装Kibana" class="headerlink" title="2.3 安装Kibana"></a>2.3 安装Kibana</h2><h3 id="1-拉取镜像-1"><a href="#1-拉取镜像-1" class="headerlink" title="1. 拉取镜像"></a>1. 拉取镜像</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull kibana:<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="2-创建挂载目录并授权-1"><a href="#2-创建挂载目录并授权-1" class="headerlink" title="2. 创建挂载目录并授权"></a>2. 创建挂载目录并授权</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> /etc/elk<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span>/kibana<br><span class="hljs-attribute">sudo</span> chown -R <span class="hljs-number">1000</span>:<span class="hljs-number">1000</span> /etc/elk<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span>/kibana<br></code></pre></td></tr></table></figure><h3 id="3-第一次执行docker启动脚本-1"><a href="#3-第一次执行docker启动脚本-1" class="headerlink" title="3. 第一次执行docker启动脚本"></a>3. 第一次执行docker启动脚本</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run -<span class="hljs-literal">it</span> <span class="hljs-string">\</span><br>-d <span class="hljs-string">\</span><br>--restart=always <span class="hljs-string">\</span><br>--log-driver json-file <span class="hljs-string">\</span><br>--log-opt max-size=<span class="hljs-number">100m</span> <span class="hljs-string">\</span><br>--log-opt max-file=<span class="hljs-number">2</span> <span class="hljs-string">\</span><br>--name kibana <span class="hljs-string">\</span><br>-p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span> <span class="hljs-string">\</span><br>--net elastic <span class="hljs-string">\</span><br>kibana:<span class="hljs-number">8.4</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="4-将容器内的文件复制到主机上-1"><a href="#4-将容器内的文件复制到主机上-1" class="headerlink" title="4. 将容器内的文件复制到主机上"></a>4. 将容器内的文件复制到主机上</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp kibana:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kibana/</span>config <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/kibana/</span>        <br>docker cp kibana:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kibana/</span>data <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/kibana/</span>        <br>docker cp kibana:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kibana/</span>plugins <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/kibana/</span> <br>docker cp kibana:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kibana/</span>logs <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/kibana/</span>  <br></code></pre></td></tr></table></figure><h3 id="5-修改配置文件-1"><a href="#5-修改配置文件-1" class="headerlink" title="5. 修改配置文件"></a>5. 修改配置文件</h3><p> <code>/etc/elk8.4.3/kibana/config/kibana.yml</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">server</span>.host: <span class="hljs-string">&quot;0.0.0.0&quot;</span><br><span class="hljs-attribute">server</span>.shutdownTimeout: <span class="hljs-string">&quot;5s&quot;</span><br><span class="hljs-attribute">elasticsearch</span>.hosts:<span class="hljs-meta"> [ &quot;http://192.168.3.17:9200&quot; ]</span><br><span class="hljs-attribute">elasticsearch</span>.username: <span class="hljs-string">&quot;kibana_system&quot;</span><br><span class="hljs-attribute">elasticsearch</span>.password: <span class="hljs-string">&quot;sith-mes&quot;</span><br><span class="hljs-attribute">monitoring</span>.ui.container.elasticsearch.enabled: true<br><span class="hljs-attribute">i18n</span>.locale: <span class="hljs-string">&quot;en&quot;</span><br><span class="hljs-attribute">xpack</span>.encryptedSavedObjects.encryptionKey: dcbf<span class="hljs-number">819</span>d<span class="hljs-number">8874</span>e<span class="hljs-number">8242</span>eaf<span class="hljs-number">107</span>d<span class="hljs-number">538</span>fe<span class="hljs-number">874</span><br><span class="hljs-attribute">xpack</span>.reporting.encryptionKey: ba<span class="hljs-number">2</span>d<span class="hljs-number">98</span>e<span class="hljs-number">6</span>dad<span class="hljs-number">4</span>fa<span class="hljs-number">73</span>d<span class="hljs-number">77</span>f<span class="hljs-number">5</span>f<span class="hljs-number">34</span>a<span class="hljs-number">568</span>cfdd<br><span class="hljs-attribute">xpack</span>.security.encryptionKey: <span class="hljs-number">3871</span>dfc<span class="hljs-number">1</span>bd<span class="hljs-number">945</span>e<span class="hljs-number">1141364</span>e<span class="hljs-number">4244800</span>b<span class="hljs-number">39</span><br></code></pre></td></tr></table></figure><p>⚠️<strong>这里的用户是 kibana_system</strong></p><h3 id="6-删除容器-1"><a href="#6-删除容器-1" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker rm <span class="hljs-string">/kibana</span><br></code></pre></td></tr></table></figure><h3 id="7-修改docker启动脚本，增加-v挂载目录-1"><a href="#7-修改docker启动脚本，增加-v挂载目录-1" class="headerlink" title="7. 修改docker启动脚本，增加-v挂载目录"></a>7. 修改docker启动脚本，增加-v挂载目录</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker run -it \<br>  -d \<br>  --restart=always \<br>  --log-driver json-<span class="hljs-keyword">file</span> \<br>  --log-opt max-<span class="hljs-keyword">size</span>=<span class="hljs-number">100</span>m \<br>  --log-opt max-<span class="hljs-keyword">file</span>=<span class="hljs-number">2</span> \<br>  --name kibana \<br>  -p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span> \<br>  --net elastic \<br>  -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/kibana/</span>config:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kibana/</span>config \<br>  -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/kibana/</span>data:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kibana/</span>data \<br>  -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/kibana/</span>plugins:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kibana/</span>plugins \<br>  -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/kibana/</span>logs:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kibana/</span>logs \<br>  kibana:<span class="hljs-number">8.4</span>.<span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><h3 id="8-配置索引生命周期"><a href="#8-配置索引生命周期" class="headerlink" title="8. 配置索引生命周期"></a>8. 配置索引生命周期</h3><ol><li><p>配置策略 Index Lifecycle Policies</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/img_v3_02ao_623ea326-f24e-4ebb-9b9c-d41cc894e9ag.jpg" alt="img_v3_02ao_623ea326-f24e-4ebb-9b9c-d41cc894e9ag"></p></li><li><p>创建索引模板</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;template&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;settings&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;index&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;lifecycle&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;自定义的policy&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;routing&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;allocation&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;include&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;_tier_preference&quot;</span>: <span class="hljs-string">&quot;data_content&quot;</span><br>            &#125;<br>          &#125;<br>        &#125;,<br>        <span class="hljs-attr">&quot;number_of_shards&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>,<br>        <span class="hljs-attr">&quot;number_of_replicas&quot;</span>: <span class="hljs-string">&quot;0&quot;</span><br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">&quot;aliases&quot;</span>: &#123;&#125;,<br>    <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>给索引策略上加索引模板</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/img_v3_02ao_a2e5305a-307f-4d19-a05a-17abb32f599g.jpg" alt="img_v3_02ao_a2e5305a-307f-4d19-a05a-17abb32f599g"></p></li></ol><h2 id="2-4-安装logstash"><a href="#2-4-安装logstash" class="headerlink" title="2.4 安装logstash"></a>2.4 安装logstash</h2><h3 id="1-拉取镜像-2"><a href="#1-拉取镜像-2" class="headerlink" title="1. 拉取镜像"></a>1. 拉取镜像</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull logstash:<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="2-创建挂载目录并授权-2"><a href="#2-创建挂载目录并授权-2" class="headerlink" title="2. 创建挂载目录并授权"></a>2. 创建挂载目录并授权</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> /etc/elk<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span>/logstash<br><span class="hljs-attribute">sudo</span> chown -R <span class="hljs-number">1000</span>:<span class="hljs-number">1000</span> /etc/elk<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span>/logstash<br></code></pre></td></tr></table></figure><h3 id="3-第一次执行docker启动脚本-2"><a href="#3-第一次执行docker启动脚本-2" class="headerlink" title="3. 第一次执行docker启动脚本"></a>3. 第一次执行docker启动脚本</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run -<span class="hljs-literal">it</span> <span class="hljs-string">\</span><br>-d <span class="hljs-string">\</span><br>--name logstash <span class="hljs-string">\</span><br>-p <span class="hljs-number">9600</span>:<span class="hljs-number">9600</span> <span class="hljs-string">\</span><br>-p <span class="hljs-number">5044</span>:<span class="hljs-number">5044</span> <span class="hljs-string">\</span><br>--net elastic <span class="hljs-string">\</span><br>logstash:<span class="hljs-number">8.4</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="4-将容器内的文件复制到主机上-2"><a href="#4-将容器内的文件复制到主机上-2" class="headerlink" title="4. 将容器内的文件复制到主机上"></a>4. 将容器内的文件复制到主机上</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp logstash:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/logstash/</span>config <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/logstash/</span> <br>docker cp logstash:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/logstash/</span>pipeline <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/logstash/</span> <br>sudo cp <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/elasticsearch/</span>config<span class="hljs-regexp">/certs /</span>etc<span class="hljs-regexp">/elk8.4.3/</span>logstash<span class="hljs-regexp">/config/</span>certs<br></code></pre></td></tr></table></figure><h3 id="5-修改配置文件-2"><a href="#5-修改配置文件-2" class="headerlink" title="5. 修改配置文件"></a>5. 修改配置文件</h3><ul><li><code>/etc/elk8.4.3/logstash/config/logstash.yml</code></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">http<span class="hljs-selector-class">.host</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>xpack<span class="hljs-selector-class">.monitoring</span><span class="hljs-selector-class">.elasticsearch</span><span class="hljs-selector-class">.hosts</span>: <span class="hljs-selector-attr">[ <span class="hljs-string">&quot;http://192.168.3.17:9200&quot;</span> ]</span><br>xpack<span class="hljs-selector-class">.monitoring</span><span class="hljs-selector-class">.elasticsearch</span><span class="hljs-selector-class">.username</span>: elastic<br>xpack<span class="hljs-selector-class">.monitoring</span><span class="hljs-selector-class">.elasticsearch</span><span class="hljs-selector-class">.password</span>: sith-mes<br></code></pre></td></tr></table></figure><ul><li><code>/etc/elk8.4.3/logstash/pipeline/logstash.conf</code></li></ul><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">input</span> &#123;<br>  beats &#123;<br>    <span class="hljs-attr">port</span> =&gt; <span class="hljs-number">5044</span><br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">filter</span> &#123;<br>      grok &#123;  <br>      <span class="hljs-attr">match</span> =&gt; &#123;<span class="hljs-string">&quot;message&quot;</span> =&gt; <span class="hljs-string">&quot;\[%&#123;TIMESTAMP_ISO8601:time&#125;\] \[%&#123;LOGLEVEL:level&#125;\] \[%&#123;NOTSPACE:threadName&#125;\] \[%&#123;DATA:logger&#125;\] \[%&#123;DATA:hostname&#125;\] \[%&#123;DATA:ip&#125;\] \[%&#123;DATA:loginName&#125;\] \[%&#123;DATA:applicationName&#125;\] \[%&#123;DATA:executor&#125;\] %&#123;GREEDYDATA:restInfo&#125;&quot;</span>&#125;<br>    &#125;<br><br>  <span class="hljs-keyword">date</span> &#123;<br>    <span class="hljs-attr">match</span> =&gt; [ <span class="hljs-string">&quot;@timestamp&quot;</span>, <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss Z&quot;</span> ]<br>  &#125;<br>  <span class="hljs-keyword">mutate</span> &#123;<br>    <span class="hljs-attr">remove_field</span> =&gt; [<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;host&quot;</span>, <span class="hljs-string">&quot;[event][original]&quot;</span>]<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">output</span> &#123;<br>  elasticsearch &#123;<br>    <span class="hljs-attr">hosts</span> =&gt; [<span class="hljs-string">&quot;http://192.168.3.17:9200&quot;</span>]<br>    <span class="hljs-attr">index</span> =&gt; <span class="hljs-string">&quot;log-%&#123;+YYYY.MM.dd&#125;&quot;</span><br>    <span class="hljs-comment"># ssl =&gt; true</span><br>    <span class="hljs-comment"># ssl_certificate_verification =&gt; false</span><br>    <span class="hljs-comment"># cacert =&gt; &quot;/usr/share/logstash/config/certs/http_ca.crt&quot;</span><br>    <span class="hljs-comment"># ca_trusted_fingerprint =&gt; &quot;第一次启动elasticsearch是保存的信息中查找&quot;</span><br>    <span class="hljs-attr">user</span> =&gt; <span class="hljs-string">&quot;elastic&quot;</span><br>    <span class="hljs-attr">password</span> =&gt; <span class="hljs-string">&quot;sith-mes&quot;</span><br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="6-删除容器-2"><a href="#6-删除容器-2" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker rm <span class="hljs-string">/logstash</span><br></code></pre></td></tr></table></figure><h3 id="7-修改docker启动脚本，增加-v挂载目录-2"><a href="#7-修改docker启动脚本，增加-v挂载目录-2" class="headerlink" title="7. 修改docker启动脚本，增加-v挂载目录"></a>7. 修改docker启动脚本，增加-v挂载目录</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -it \<br>  -d \<br>  --name logstash \<br>  -p <span class="hljs-number">9600</span>:<span class="hljs-number">9600</span> \<br>  -p <span class="hljs-number">5044</span>:<span class="hljs-number">5044</span> \<br>  --net elastic \<br>  -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/logstash/</span>config:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/logstash/</span>config \<br>  -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/logstash/</span>pipeline:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/logstash/</span>pipeline \<br>  logstash:<span class="hljs-number">8.4</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="2-5-安装filebeat"><a href="#2-5-安装filebeat" class="headerlink" title="2.5 安装filebeat"></a>2.5 安装filebeat</h2><h3 id="1-拉取镜像-3"><a href="#1-拉取镜像-3" class="headerlink" title="1. 拉取镜像"></a>1. 拉取镜像</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull elastic/filebeat:<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="2-创建挂载目录并授权-3"><a href="#2-创建挂载目录并授权-3" class="headerlink" title="2. 创建挂载目录并授权"></a>2. 创建挂载目录并授权</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> /etc/elk<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span>/filebeat<br><span class="hljs-attribute">sudo</span> chown -R <span class="hljs-number">1000</span>:<span class="hljs-number">1000</span> /etc/elk<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span>/filebeat<br></code></pre></td></tr></table></figure><h3 id="3-第一次执行docker启动脚本-3"><a href="#3-第一次执行docker启动脚本-3" class="headerlink" title="3. 第一次执行docker启动脚本"></a>3. 第一次执行docker启动脚本</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run -<span class="hljs-literal">it</span> <span class="hljs-string">\</span><br>-d <span class="hljs-string">\</span><br>--name filebeat <span class="hljs-string">\</span><br>--network host <span class="hljs-string">\</span><br>-e TZ=Asia/Shanghai <span class="hljs-string">\</span><br>elastic/filebeat:<span class="hljs-number">8.4</span>.<span class="hljs-number">3</span> <span class="hljs-string">\</span><br>filebeat -e  -c /usr/share/filebeat/filebeat.yml<br></code></pre></td></tr></table></figure><h3 id="4-将容器内的文件复制到主机上-3"><a href="#4-将容器内的文件复制到主机上-3" class="headerlink" title="4. 将容器内的文件复制到主机上"></a>4. 将容器内的文件复制到主机上</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp filebeat:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/filebeat/</span>filebeat.yml <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/filebeat/</span> <br>docker cp filebeat:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/filebeat/</span>data <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/filebeat/</span> <br>docker cp filebeat:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/filebeat/</span>logs <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/filebeat/</span> <br></code></pre></td></tr></table></figure><h3 id="5-修改配置文件-3"><a href="#5-修改配置文件-3" class="headerlink" title="5. 修改配置文件"></a>5. 修改配置文件</h3><ul><li><code>/etc/elk8.4.3/filebeat/filebeat.yml</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">filebeat.config:</span><br>  <span class="hljs-attr">modules:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">$&#123;path.config&#125;/modules.d/*.yml</span><br>    <span class="hljs-attr">reload.enabled:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">processors:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">add_cloud_metadata:</span> <span class="hljs-string">~</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">add_docker_metadata:</span> <span class="hljs-string">~</span><br><br><span class="hljs-attr">output.logstash:</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># The Logstash hosts</span><br>  <span class="hljs-attr">hosts:</span> [<span class="hljs-string">&quot;192.168.3.17:5044&quot;</span>]<br> <br><span class="hljs-attr">filebeat.inputs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">log</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">paths:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/share/filebeat/target/*/info.log</span>  <span class="hljs-comment"># 这个路径是需要收集的日志路径，是docker容器中的路径</span><br>  <span class="hljs-attr">scan_frequency:</span> <span class="hljs-string">10s</span><br>  <span class="hljs-attr">exclude_lines:</span> [<span class="hljs-string">&#x27;HEAD&#x27;</span>]<br>  <span class="hljs-attr">exclude_lines:</span> [<span class="hljs-string">&#x27;HTTP/1.1&#x27;</span>]<br>  <span class="hljs-attr">multiline.pattern:</span> <span class="hljs-string">&#x27;^[[:space:]]+(at|\.&#123;3&#125;)\b|Exception|捕获异常&#x27;</span><br>  <span class="hljs-attr">multiline.negate:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">multiline.match:</span> <span class="hljs-string">after</span><br></code></pre></td></tr></table></figure><h3 id="6-删除容器-3"><a href="#6-删除容器-3" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker rm <span class="hljs-string">/filebeat</span><br></code></pre></td></tr></table></figure><h3 id="7-修改docker启动脚本，增加-v挂载目录-3"><a href="#7-修改docker启动脚本，增加-v挂载目录-3" class="headerlink" title="7. 修改docker启动脚本，增加-v挂载目录"></a>7. 修改docker启动脚本，增加-v挂载目录</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -it \<br>  -d \<br>  --name filebeat \<br>  --network host \<br>  -e TZ=Asia/Shanghai \<br>  -v <span class="hljs-regexp">/home/</span>sith<span class="hljs-regexp">/deploy/</span>backend<span class="hljs-regexp">/logs:/u</span>sr<span class="hljs-regexp">/share/</span>filebeat/target \<br>  -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/filebeat/</span>filebeat.yml:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/filebeat/</span>filebeat.yml \<br>  -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/filebeat/</span>data:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/filebeat/</span>data \<br>  -v <span class="hljs-regexp">/etc/</span>elk8.<span class="hljs-number">4.3</span><span class="hljs-regexp">/filebeat/</span>logs:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/filebeat/</span>logs \<br>  elastic/filebeat:<span class="hljs-number">8.4</span>.<span class="hljs-number">3</span> \<br>  filebeat -e  -c <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/filebeat/</span>filebeat.yml<br></code></pre></td></tr></table></figure><p>⚠️： ES映射的data和log比较大，建议放在磁盘空间比较足的目录。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>xxlJob使用</title>
    <link href="/xxlJob%E4%BD%BF%E7%94%A8/"/>
    <url>/xxlJob%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-任务调度"><a href="#1-任务调度" class="headerlink" title="1. 任务调度"></a>1. 任务调度</h1><h2 id="1-什么是任务调度"><a href="#1-什么是任务调度" class="headerlink" title="1. 什么是任务调度"></a>1. 什么是任务调度</h2><p>任务调度是为了自动完成特定任务，在约定的特定时刻去执行任务的过程。</p><h2 id="2-什么场景会需要任务调度"><a href="#2-什么场景会需要任务调度" class="headerlink" title="2. 什么场景会需要任务调度"></a>2. 什么场景会需要任务调度</h2><ul><li>某电商平台需要每天上午10点，下午3点，晚上8点发放一批优惠券</li><li>某银行系统需要在信用卡到期还款日的前3天进行短信提醒</li><li>某财务系统需要每天凌晨结算前一天的财务数据</li></ul><h1 id="2-分布式任务调度"><a href="#2-分布式任务调度" class="headerlink" title="2. 分布式任务调度"></a>2. 分布式任务调度</h1><h2 id="1-什么是分布式任务调度"><a href="#1-什么是分布式任务调度" class="headerlink" title="1. 什么是分布式任务调度"></a>1. 什么是分布式任务调度</h2><p>采用分布式架构，一个服务往往会部署多个冗余实例来运行我们的业务，在这种分布式系统环境下运行任务调度，我们称之为<strong>分布式任务调度</strong></p><h2 id="2-为什么需要分布式任务调度"><a href="#2-为什么需要分布式任务调度" class="headerlink" title="2. 为什么需要分布式任务调度"></a>2. 为什么需要分布式任务调度</h2><p>使用spring提供的@scheduled，也能实现调度的功能，为什么还需要分布式任务调度的呢？</p><ul><li>高可用：单机版的任务调度只能在一台机器上运行，程序出现异常后会导致服务不可用。</li><li>防止任务重复执行。当部署了多台服务，同一个定时任务需要控制在同一时间内，只有一个任务在执行。</li><li>单机处理存在极限。即使可以通过多线程提高单机的处理效率但能力依旧有限（CPU，内存，硬盘），依旧存在处理不过来的场景</li></ul><h1 id="2-xxl-Job"><a href="#2-xxl-Job" class="headerlink" title="2. xxl-Job"></a>2. xxl-Job</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>xxlJob是一个轻量级<strong>分布式任务调度</strong>平台</p><h2 id="2-设计思想"><a href="#2-设计思想" class="headerlink" title="2. 设计思想"></a>2. 设计思想</h2><ul><li>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</li><li>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</li><li>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；</li></ul><h2 id="3-系统组成"><a href="#3-系统组成" class="headerlink" title="3. 系统组成"></a>3. 系统组成</h2><ul><li><p><strong>调度模块（调度中心）</strong>：</p><p>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。</p><p>调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；<br>支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</p></li><li><p><strong>执行模块（执行器）</strong>：<br>负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；<br>接收“调度中心”的执行请求、终止请求和日志请求等。</p></li></ul><h2 id="4-Spring-Boot-集成-XXL-JOB"><a href="#4-Spring-Boot-集成-XXL-JOB" class="headerlink" title="4 Spring Boot 集成 XXL-JOB"></a>4 <strong>Spring Boot 集成 XXL-JOB</strong></h2><p>参考<a href="https://www.xuxueli.com/xxl-job/#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">快速入门</a></p><h3 id="1-配置运行调度中心（xxl-job-admin）"><a href="#1-配置运行调度中心（xxl-job-admin）" class="headerlink" title="1. 配置运行调度中心（xxl-job-admin）"></a>1. 配置运行调度中心（xxl-job-admin）</h3><ol><li>首先从源码仓库中下载代码</li><li>执行doc&#x2F;db<code>目录下有数据库脚本</code>tables_xxl_job.sql，初始化调度数据库 <code>xxl_job</code></li><li>修改 xxl-job-admin 的配置文件，主要是修改数据源信息，若需要用到邮件报警功能，需要配置邮箱</li><li>启动XxlJobAdminApplication，正常启动后，访问地址为：<code>http://localhost:8080/xxl-job-admin</code>，默认的账户为 admin，密码为 123456，</li></ol><h3 id="2-配置运行执行器项目（xxl-job-executor）"><a href="#2-配置运行执行器项目（xxl-job-executor）" class="headerlink" title="2. 配置运行执行器项目（xxl-job-executor）"></a>2. 配置运行执行器项目（xxl-job-executor）</h3><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">implementation &#x27;com.xuxueli:xxl-job-core:2.3.0&#x27;<br></code></pre></td></tr></table></figure></li><li><p>加入配置</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">### 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span><br><span class="hljs-meta">xxl.job.admin.addresses</span>=<span class="hljs-string">http://localhost:6100/xxl-job-admin</span><br><span class="hljs-comment">### 执行器通讯TOKEN [选填]：非空时启用；</span><br><span class="hljs-meta">xxl.job.accessToken</span>=<span class="hljs-string"></span><br><span class="hljs-comment">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span><br><span class="hljs-meta">xxl.job.executor.appname</span>=<span class="hljs-string">xxl-job-executor-city-eureka</span><br><span class="hljs-comment">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span><br><span class="hljs-meta">xxl.job.executor.address</span>=<span class="hljs-string"></span><br><span class="hljs-comment">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯时用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span><br><span class="hljs-meta">xxl.job.executor.ip</span>=<span class="hljs-string">localhost</span><br><span class="hljs-comment">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span><br><span class="hljs-meta">xxl.job.executor.port</span>=<span class="hljs-string">9999</span><br><span class="hljs-comment">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span><br><span class="hljs-meta">xxl.job.executor.logpath</span>=<span class="hljs-string">/data/applogs/xxl-job/jobhandler</span><br><span class="hljs-comment">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span><br><span class="hljs-meta">xxl.job.executor.logretentiondays</span>=<span class="hljs-string">30</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在 config 包下创建 <code>XxlJobConfig</code> 类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.pyr.city.config;<br><br><span class="hljs-keyword">import</span> com.xxl.job.core.executor.impl.XxlJobSpringExecutor;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * xxl-job config</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xuxueli 2017-04-28</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxlJobConfig</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String adminAddresses;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessToken;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String appname;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String ip;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String logPath;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> logRetentionDays;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> XxlJobSpringExecutor <span class="hljs-title">xxlJobExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);<br>        XxlJobSpringExecutor xxlJobSpringExecutor = <span class="hljs-keyword">new</span> XxlJobSpringExecutor();<br>        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);<br>        xxlJobSpringExecutor.setAppname(appname);<br>        xxlJobSpringExecutor.setAddress(address);<br>        xxlJobSpringExecutor.setIp(ip);<br>        xxlJobSpringExecutor.setPort(port);<br>        xxlJobSpringExecutor.setAccessToken(accessToken);<br>        xxlJobSpringExecutor.setLogPath(logPath);<br>        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);<br><br>        <span class="hljs-keyword">return</span> xxlJobSpringExecutor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>编写 JobHandler</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleXxlJob</span> </span>&#123;<br>    <span class="hljs-meta">@XxlJob(&quot;demoJobHandler&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demoJobHandler</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行定时任务，执行时间为：&quot;</span>+<span class="hljs-keyword">new</span> Date());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-BEAN模式测试"><a href="#3-BEAN模式测试" class="headerlink" title="3. BEAN模式测试"></a>3. BEAN模式测试</h3><p>BEAN模式执行器：每个执行器都是Spring的一个Bean实例，XXL-JOB通过注解 <code>@XxlJob</code>的方式进行任务开发；</p><ol><li>编写 JobHandler</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleXxlJob</span> </span>&#123;<br>    <span class="hljs-meta">@XxlJob(&quot;demoJobHandler&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demoJobHandler</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行定时任务，执行时间为：&quot;</span>+<span class="hljs-keyword">new</span> Date());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在执行器管理页面添加该执行器。</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231114165019091.png" alt="image-20231114165019091"></p><ol start="3"><li>在任务管理界面添加我们刚才开发的任务，运行模式选择BEAN</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231114165049371.png" alt="image-20231114165049371"></p><ol start="4"><li>在操作页面，点击执行一次</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231114165154323.png" alt="image-20231114165154323"></p><h3 id="4-GLUE-Java-模式测试"><a href="#4-GLUE-Java-模式测试" class="headerlink" title="4. GLUE(Java)模式测试"></a>4. GLUE(Java)模式测试</h3><ol><li>在任务管理界面添加一个新任务，运行模式选择BEAN</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231114183450401.png" alt="image-20231114183450401"></p><ol start="2"><li>编辑需要执行的代码</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231114183527467.png" alt="image-20231114183527467"></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231114183541042.png" alt="image-20231114183541042"></p><ol start="3"><li>在操作页面，点击执行一次</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231114183617278.png" alt="image-20231114183617278"></p><ol start="5"><li>执行日志打印</li></ol><p>需要使用<code>XxlJobHelper.log</code>打印执行日志；</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231114184326029.png" alt="image-20231114184326029"></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231114184858772.png" alt="image-20231114184858772"></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231114184353146.png" alt="image-20231114184353146"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot引入flyway</title>
    <link href="/springboot%E5%BC%95%E5%85%A5flyway/"/>
    <url>/springboot%E5%BC%95%E5%85%A5flyway/</url>
    
    <content type="html"><![CDATA[<h1 id="1-flyway-是什么？"><a href="#1-flyway-是什么？" class="headerlink" title="1. flyway 是什么？"></a>1. flyway 是什么？</h1><p>Flyway 就是一款数据库界的版本控制工具，它可以记录数据库的变化记录</p><p><strong>为什么需要它？</strong></p><p>目前通过人工去维护、同步数据库脚本，但经常会遇到疏忽而遗漏的情况，比如我们在开发环境对某个表新增了一个字段，而部署到线上时却忘了执行该 SQL 脚本，导致出现 bug。</p><p>有了 Flyway，在Spring boot项目启动时，会自动执行flyway定义的 SQL ，而无需人为手工控制，再也不用担心因数据库不同步而导致的各种环境问题。</p><h1 id="2-springboot引入flyway"><a href="#2-springboot引入flyway" class="headerlink" title="2. springboot引入flyway"></a>2. springboot引入flyway</h1><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><p>pom.xml增加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.flywaydb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flyway-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-支持maven编译sql文件"><a href="#2-支持maven编译sql文件" class="headerlink" title="2. 支持maven编译sql文件"></a>2. 支持maven编译sql文件</h2><p>pom.xml增加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.sql<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-添加配置"><a href="#2-添加配置" class="headerlink" title="2. 添加配置"></a>2. 添加配置</h2><p>application.yml增加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">flyway:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">## 开启flyway, sithMesDev不开启为false</span><br>    <span class="hljs-attr">baseline-on-migrate:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#对于已经存在的项目，数据库中存在数据，通过设置baseline告诉flyway，这个baseline及之前的sql脚本都不要执行了</span><br>    <span class="hljs-attr">locations:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">classpath:db/migration</span> <span class="hljs-comment">#指定项目中需要迁移的sql文件在哪个位置，在springboot项目中classpath指的是resource文件夹</span><br>    <span class="hljs-attr">table:</span> <span class="hljs-string">flyway_schema_history_xxx</span> <span class="hljs-comment"># 版本控制日志表，默认flyway_schema_history,不同系统建议修改表名，如flyway_schema_history_admin</span><br></code></pre></td></tr></table></figure><h2 id="3-创建迁移所需要的脚本"><a href="#3-创建迁移所需要的脚本" class="headerlink" title="3. 创建迁移所需要的脚本"></a>3. 创建迁移所需要的脚本</h2><p>在项目src&#x2F;main&#x2F;resources下新建文件夹层级db&#x2F;migration，将需要执行的sql文件放进去</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231109154251326.png" alt="image-20231109154251326"></p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><p>重启项目，可以观察控制会出现：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231109154142159.png" alt="image-20231109154142159"></p>]]></content>
    
    
    <categories>
      
      <category>Springboot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录由于数据库用户权限导致的一次线上事故</title>
    <link href="/%E8%AE%B0%E5%BD%95%E7%94%B1%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/"/>
    <url>/%E8%AE%B0%E5%BD%95%E7%94%B1%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><ul><li>11.3 生产环境和用户查询相关的功能，都报错could not extract ResultSet; SQL [n&#x2F;a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet</li><li>ELK查询原因，Caused by: org.postgresql.util.PSQLException: 错误: 对表 em_adm_user_group 权限不够</li><li>f lyway新建了V20231031155120__DDL_create_user_group.sql，并且userVo join user_group，所以会查询user_group这张表</li></ul><h1 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h1><ul><li><p>9.4 LGQ定位中毒事件的时候，为了确认是哪个微服务执行的数据库操作（不同的微服务如果使用了不同的用户，可以看到是哪个微服务执行的sql），修改了sith-mes的application-sithMes.yml，将数据库的用户从sith-mes修改成了sith-server，并且赋予了sith-server超级管理员的权限，所以sith-server可以操作sith-mes创建的表。</p></li><li><p>执行create_user_group.sql的时候，因为此时是在sith-mes服务下执行的，所以user_group这张表的owner是sith-server。admin服务此时连接的数据库用户是sith-mes，所以没有操作sith-server的权限</p></li></ul><blockquote><p>用户sith-server建立的表，用户sith-mes没有权限操作</p></blockquote><h1 id="3-紧急修复"><a href="#3-紧急修复" class="headerlink" title="3. 紧急修复"></a>3. 紧急修复</h1><p>将新建的user_group 的owner改成了sith-mes</p><p>问题：后期如果在sith-mes新建的表，其他微服务要操作的话，依旧会出现没权限问题</p><h1 id="4-解决方式"><a href="#4-解决方式" class="headerlink" title="4 解决方式"></a>4 解决方式</h1><ol><li>保持所有微服务用户一致，sith-mes改回用户sith-mes，或者其他微服务也改成使用sith-server</li><li>将sith-mes也设置成超级管理员，使他可以操作sith-mes数据库的所有表</li><li>每个微服务数据库使用自己的用户，flyway基于每个微服务建立，并且需保证服务只操作自己服务的表</li></ol><h1 id="5-数据库新建用户，并赋予权限步骤"><a href="#5-数据库新建用户，并赋予权限步骤" class="headerlink" title="5. 数据库新建用户，并赋予权限步骤"></a>5. 数据库新建用户，并赋予权限步骤</h1><p>场景：用户panyurou创建了一个名为“micro-weather”的database(数据库)，同时在该库下默认的public(shema)创建了一个表city</p><p>需求：新建一个用户cityserver，使得这个用户可以操作“micro-weather”的public(shema)下的所有表</p><h2 id="5-1-创建用户并设置密码"><a href="#5-1-创建用户并设置密码" class="headerlink" title="5.1 创建用户并设置密码"></a>5.1 创建用户并设置密码</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> cityserver <span class="hljs-keyword">with</span> PASSWORD <span class="hljs-string">&#x27;city-server&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="5-2-数据库授权"><a href="#5-2-数据库授权" class="headerlink" title="5.2 数据库授权"></a>5.2 数据库授权</h2><p>赋予指定账号，指定数据库的所有权限</p><ol><li><p>以panyurou的身份进入数据库（因为是panyurou创建的数据库和表，所以需要在panyurou的身份下操作）。此时是可以访问city这张表的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  Desktop psql <span class="hljs-operator">-</span>U panyurou <span class="hljs-operator">-</span>d  micro<span class="hljs-operator">-</span>weather<br><br>psql (<span class="hljs-number">14.6</span> (Homebrew))<br>Type &quot;help&quot; <span class="hljs-keyword">for</span> help.<br><br>micro<span class="hljs-operator">-</span>weather<span class="hljs-operator">=</span># <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> city;<br> id <span class="hljs-operator">|</span> name<br><span class="hljs-comment">----+------</span><br>(<span class="hljs-number">0</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure></li><li><p>赋予数据库权限</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">micro<span class="hljs-operator">-</span>weather<span class="hljs-operator">=</span># <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> privileges <span class="hljs-keyword">on</span> database &quot;micro-weather&quot; <span class="hljs-keyword">to</span> cityserver;<br><span class="hljs-keyword">GRANT</span><br>micro<span class="hljs-operator">-</span>weather<span class="hljs-operator">=</span># \q<br></code></pre></td></tr></table></figure><ol start="3"><li>赋予该数据库下所有表权限</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">micro<span class="hljs-operator">-</span>weather<span class="hljs-operator">=</span># <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> privileges <span class="hljs-keyword">on</span> <span class="hljs-keyword">all</span> tables <span class="hljs-keyword">in</span> schema public <span class="hljs-keyword">to</span> cityserver;<br><span class="hljs-keyword">GRANT</span><br>micro<span class="hljs-operator">-</span>weather<span class="hljs-operator">=</span># \q<br></code></pre></td></tr></table></figure><p>注：当没有赋予权限，并且以新建的用户去访问数据的话，会报错</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">➜  Desktop psql -U cityserver -d micro-weather<br><br>psql (14.6 (Homebrew))<br>Type &quot;help&quot; for help.<br><br>micro-weather=&gt; select * from city;<br><span class="hljs-keyword">ERROR:  </span>permission denied for table city<br></code></pre></td></tr></table></figure><p>附：数据库用户介绍</p><p>执行<code>select * from pg_user;</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231107225414985.png" alt="image-20231107225414985"></p><h2 id="5-3-常用sql"><a href="#5-3-常用sql" class="headerlink" title="5.3 常用sql"></a>5.3 常用sql</h2><p>将用户修改成超级管理员</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> cityserver <span class="hljs-keyword">WITH</span> SUPERUSER<br></code></pre></td></tr></table></figure><p>移除用户超级管理员</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> cityserver <span class="hljs-keyword">WITH</span> NOSUPERUSER;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线上事故</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>权限系统设计</title>
    <link href="/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <url>/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>权限管理是公司数据安全的重要保证，针对不同的岗位，不同的级别看到的数据是不一样的，操作数据的限制也是不一样的。</strong></p><blockquote><p>如何让各个岗位的人在系统上各司其职，就是权限管理要解决的问题。</p></blockquote><h1 id="1-权限设计"><a href="#1-权限设计" class="headerlink" title="1. 权限设计"></a>1. 权限设计</h1><p>业务分类上来讲权限可以分为数据查看权限，数据修改权限等。</p><p>对应到系统设计中有页面权限、菜单权限、按钮权限等。菜单也分一级菜单、二级菜单甚至三级菜单，菜单对应的页面里又有很多按钮。</p><p>我们在设计的时候最好把权限设计成树形结构，这样在申请权限的时候就可以一目了然的看到菜单的结构，需要哪些权限就非常的明了了。</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231005205506829.png" alt="image-20231005205506829" style="zoom:50%;" /><h1 id="2-权限模型的演进"><a href="#2-权限模型的演进" class="headerlink" title="2.权限模型的演进"></a>2.权限模型的演进</h1><p><code>RBAC</code>全称为基于角色的访问控制模型（<code>Role-based access control</code>），在该模型中，通过让权限与角色关联来实现授权，给用户分配一系列的角色来让注册用户得到这些角色对应的权限。</p><h3 id="1-RBAC0-x2F-基本模型"><a href="#1-RBAC0-x2F-基本模型" class="headerlink" title="1. RBAC0&#x2F;基本模型"></a>1. RBAC0&#x2F;基本模型</h3><p><code>RBAC0</code>是最基本的模型，未做特殊要求和扩展，在该模型中，一个用户可以同时拥有多个角色，每个角色可以拥有多个权限。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231121113023361.png" alt="image-20231121113023361"></p><p><strong>表设计</strong>：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231121114418238.png" alt="image-20231121114418238"></p><h3 id="2-RBAC1-x2F-角色继承的RBAC模型"><a href="#2-RBAC1-x2F-角色继承的RBAC模型" class="headerlink" title="2. RBAC1&#x2F;角色继承的RBAC模型"></a>2. RBAC1&#x2F;角色继承的RBAC模型</h3><p>由于具有公司的岗位具有上下级关系，且上级拥有下级的所有权限，所以不同的角色之间存在着重叠的权限，如：</p><ul><li><p>员工：员工的权限</p></li><li><p>主管：员工的权限、主管的权限</p></li><li><p>老板：员工的权限、主管的权限、老板的权限</p></li></ul><blockquote><p>存在的弊端是：每当增加一条员工的权限，都需要同时绑定给【员工】、【主管】和【老板】。倘若将【老板】漏了，那么就会出现【员工有权限，而老板没权限】的情况了。</p></blockquote><p><strong>设计思路</strong>：上层角色默认拥有下层角色的所有权限。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231121113513733.png" alt="image-20231121113513733"></p><p>表设计：需要在刚才的基础上增加角色继承表，来记录角色之间的继承关系，包括两个字段角色ID和父角色ID</p><h3 id="3-RBAC2-x2F-带约束的RBAC模型"><a href="#3-RBAC2-x2F-带约束的RBAC模型" class="headerlink" title="3. RBAC2&#x2F;带约束的RBAC模型"></a>3. RBAC2&#x2F;带约束的RBAC模型</h3><p>带约束的RBAC模型又称RBAC2模型。<strong>基于RBAC0模型的基础上，进行了角色的访问控制。</strong>此模型中常用以下限制：</p><ul><li><p>互斥角色：同一个用户在两个互斥角色中只能选择一个。</p></li><li><p>基数约束：一个用户拥有的角色是有限的，一个角色拥有的权限也是有限的。</p></li><li><p>先决条件约束：用户想要获得上层角色，首先必须拥有下层角色。</p></li><li><p>运行时互斥 ：允许一个用户具有两个角色，一次鉴权只能使用一个角色。</p></li></ul><h1 id="3-用户划分"><a href="#3-用户划分" class="headerlink" title="3. 用户划分"></a>3. 用户划分</h1><h2 id="1-用户组（组织）"><a href="#1-用户组（组织）" class="headerlink" title="1 用户组（组织）"></a>1 用户组（组织）</h2><p>如果用户数量比较庞大，可以加入用户组模式。需要给用户分组，每个用户组内有多个用户，可以给用户加角色外，也可以给用户组加角色。最终用户拥有的所有权限 &#x3D; 用户个人拥有的权限+该用户所在用户组拥有的权限。</p><p>优势：</p><ul><li><strong>实现权限分配的自动化：</strong> 和组织关系打通之后，按照组织来分配角色，如果有新入职的用户，被划分在某个组织下面之后，会自动获取该组织下所有的权限，无需人工分配。又比如有用户调岗，只需要把组织关系调整就可以了，权限会跟着组织关系自动调整。</li><li><strong>控制数据权限：</strong> 把角色关联到组织，组织里的成员只能看到本组织下的数据，比如市场推广和大客定制，市场推广针对的是零散的客户，大可定制针对的是有一定体量的客户，相互的数据虽然在一个平台，但是只能看自己组织下的数据。</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231121143805877.png" alt="image-20231121143805877"></p><p>表设计：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231121145331930.png" alt="image-20231121145331930"></p><h1 id="4-实战演练"><a href="#4-实战演练" class="headerlink" title="4. 实战演练"></a>4. 实战演练</h1><h2 id="1-表设计："><a href="#1-表设计：" class="headerlink" title="1. 表设计："></a>1. 表设计：</h2><p><strong>基础表：</strong></p><ul><li><p>用户 User：id, name</p></li><li><p>角色 Role:   id, name, code</p></li><li><p>权限模块 Acl_Module：name, parent_id, level, code</p></li><li><p>权限ACl : id, name, acl_module_id, parent_id, url, type(按钮，请求地址)</p></li></ul><p><strong>关系表：</strong></p><ul><li>用户-角色关系表</li><li>角色权限关系表</li></ul><h2 id="2-后端逻辑"><a href="#2-后端逻辑" class="headerlink" title="2. 后端逻辑"></a>2. 后端逻辑</h2><ol><li>新建权限点，菜单或者按钮（url是请求地址）</li><li>创建角色，设置角色名称， 角色读写权限等级（增&#x2F;删&#x2F;改&#x2F;查）中的组合。给这个权限配置新建的权限点以及对应的人</li></ol><p>（增删改查，分别对应2，3，5，7 这样的话，数据库只需要存一位去记录，当然存0101这种也行）</p><ol start="3"><li>在权限拦截器增加校验<ol><li>获取当前登录用户可以访问的权限列表</li><li>将权限列表和当前请求做比较，需满足以下两个条件，即可放行，否则提示没有权限<ul><li>请求URL在当前权限URL列表里</li></ul></li><li>当前访问的method也在权限URL列表里（这里需要后端使用restful请求，即增删改查对应 POST，DELETE， PUT，GET， 或者后端带标识过来）</li></ol></li></ol><h2 id="3-前端逻辑"><a href="#3-前端逻辑" class="headerlink" title="3. 前端逻辑"></a>3. 前端逻辑</h2><ol><li>前端在用户登录后，就在localstory里存储了，调用当前user的权限列表的结果，只有用户退出登录后，才会更新</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>在工厂父类定义一个创建对象的接口，而工厂子类则负责生成<strong>一组相关的对象</strong>。这些对象之间通常有某种关联或依赖关系。</p><p>抽象工厂模式适用于需要创建多个相关对象并确保它们之间的一致性的情况。</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li>客户端不依赖某个产品实例具体如何创建</li><li>强调一系列相关的产品对象一起创建使用</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li><p>用户只需要关心产品所需工厂，无需关心创建细节</p></li><li><p>将一个系列的产品族统一到一起创建：抽象工厂模式通过一组相关的工厂类来创建一系列相关或依赖的对象，确保了这些对象之间的一致性。这意味着创建的对象是相互配合、一起使用的，能够满足特定的需求或目标。</p></li></ul><p>缺点：</p><ul><li>产品族中扩展新的产品困难</li><li>增加了系统的抽象性和理解难度</li></ul><blockquote><p>产品族是指一组相关联或依赖的产品，它们在功能、特性或目标上具有一定的相似性或关联性。产品族通常由多个具体产品组成，每个具体产品属于同一个产品族。</p><p>举例来说，假设有一个汽车制造系统，其中包含了多个产品族：轿车产品族、SUV产品族和卡车产品族。每个产品族包含了各自的具体产品，如轿车产品族可能包含了轿车的具体型号（如小型轿车、中型轿车、豪华轿车等），SUV产品族可能包含了SUV的具体型号（如紧凑型SUV、中型SUV、全尺寸SUV等）</p></blockquote><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景： 不同的课程，配置的博客和视频都是不一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 博客</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaArticle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Article</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;编写Java课程博客&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PythonArticle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Article</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;编写Python课程博客&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 视频</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Video</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaVideo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Video</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;录制Java课程视频&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PythonVideo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Video</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;录制Python课程视频&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 课程工厂接口，创建不同课程的视频和博客</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseFactory</span> </span>&#123;<br>    <span class="hljs-function">Video <span class="hljs-title">getVideo</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Article <span class="hljs-title">getArticle</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaCourseFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CourseFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Video <span class="hljs-title">getVideo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JavaVideo();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Article <span class="hljs-title">getArticle</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JavaArticle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PythonCourseFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CourseFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Video <span class="hljs-title">getVideo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PythonVideo();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Article <span class="hljs-title">getArticle</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PythonArticle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CourseFactory courseFactory = <span class="hljs-keyword">new</span> JavaCourseFactory();<br>        Video video = courseFactory.getVideo();<br>        Article article = courseFactory.getArticle();<br>        video.produce();<br>        article.produce();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>录制Java课程视频<br>编写Java课程博客</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>工厂模式，又称工厂方法模式。在工厂父类定义一个创建对象的接口，而工厂子类则负责生成具体的对象。每个具体工厂类根据需要创建不同的对象，从而实现了对象的创建和使用的解耦。</p><p>类型：创建型</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li>创建对象需要大量重复代码</li><li>客户端不依赖某个产品实例具体如何创建</li><li>一个类通过子类来指定创建哪个对象</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>用户只需要关心产品所需工厂，无需关心创建细节</li><li>符合开闭原则</li></ul><p>缺点：</p><ul><li>类的个数容易多，增加复杂度</li><li>增加了系统的抽象性和理解难度</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景： 需要根据电影类型创建电影</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象产品类 ，定义具体产品的公共接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Video</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaVideo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Video</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;录制Java课程视频&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PythonVideo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Video</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;录制Python课程视频&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建抽象工厂类，定义具体工厂的公共接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Video <span class="hljs-title">getVideo</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaVideoFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">VideoFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Video <span class="hljs-title">getVideo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JavaVideo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PythonVideoFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">VideoFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Video <span class="hljs-title">getVideo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PythonVideo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        VideoFactory pythonVideoFactory = <span class="hljs-keyword">new</span> PythonVideoFactory();<br>        VideoFactory javaVideoFactory = <span class="hljs-keyword">new</span> JavaVideoFactory();<br>        Video pythonVideo = pythonVideoFactory.getVideo();<br>        pythonVideo.produce();<br>        Video javaVideo = javaVideoFactory.getVideo();<br>        javaVideo.produce();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>录制Python课程视频<br>录制Java课程视频</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>为对象提供代理，以控制对这个对象的访问</p><p>代理对象在客户端和目标对象之间起到中介作用</p><p><strong>分类</strong>：静态代理和动态代理</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li>保护目标对象</li><li>增强目标对象</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>代理模式可以将代理对象和目标对象接耦，扩展性好</li><li>增强目标对象</li></ul><p>缺点：</p><ul><li>造成类数目增加</li><li>在客户端和目标对象间增加了一个代理对象，会导致请求速度变慢</li><li>增加系统复杂度</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：发送邮件前进行额外的操作</p><ul><li>静态代理</li></ul><p> 由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Email</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlashEmail</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Email</span> </span>&#123;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>            System.out.println(<span class="hljs-string">&quot;邮件发送中。。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Email</span> </span>&#123;<br> <br>Email email;<br>  <br>  <span class="hljs-comment">//传入委托类初始化代理类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmailProxy</span><span class="hljs-params">(Email email)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>.email=email;<br>&#125;<br>  <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;发送邮件前准备。。。&quot;</span>);<br>            email.send();<br>            System.out.println(<span class="hljs-string">&quot;邮件发送后。。。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//原始对象</span><br>   Email email=<span class="hljs-keyword">new</span> FlashEmail();<br>   EmailProxy emailProxy=<span class="hljs-keyword">new</span> EmailProxy(email);<br>   emailProxy.send();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>发送邮件前准备。。。<br>邮件发送中。。。。。<br>邮件发送后。。。。。。</p><ul><li><p>动态代理</p><p>动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。</p><p>java.lang.reflect 包中的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。这一个类和接口是实现我们动态代理所必须用到的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailDynamicProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br> <br>Object target;<span class="hljs-comment">//委托对象</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmailDynamicProxy</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.target = obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">bind</span><span class="hljs-params">()</span></span>&#123;<br>Class cls = target.getClass();<br><span class="hljs-keyword">return</span> Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(),<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;发送邮件前准备。。。&quot;</span>);<br>    <span class="hljs-comment">//从委托对象中，调用该对象的指定方法，这里相当于send方法</span><br>method.invoke(target);<br>System.out.println(<span class="hljs-string">&quot;发送后。。。。。。&quot;</span>);<br><span class="hljs-keyword">return</span> target;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Email email = <span class="hljs-keyword">new</span> FlashEmail();<br>        Email emailProxy = (Email) <span class="hljs-keyword">new</span> EmailDynamicProxy(email).bind();<br>        emailProxy.send();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>状态模式</title>
    <link href="/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>当一个对象内在状态改变时允许改变其行为。比如：停止状态下，不允许快进视频这个行为</p><p>类型：行为型</p><p><strong>核心角色</strong></p><ol><li>环境类（Context）：环境类是拥有状态的对象。它维护一个指向当前状态对象的引用，并将与状态相关的请求委托给状态对象进行处理。</li><li>抽象状态类（State）：抽象状态类定义了一个接口，用于封装与环境对象相关的行为。它可以根据具体的状态进行具体的行为实现。</li><li>具体状态类（Concrete State）：具体状态类实现了抽象状态类中定义的接口，提供了与具体状态相关的行为实现。</li></ol><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><p>一个对象存在多个状态（不同状态下行为不同），且状态可以转换</p><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>将不同状态隔离</li><li>将各种状态的转换逻辑，分布到state的子类中，减少互相依赖</li><li>增加新的状态简单</li></ul><p>缺点：</p><ul><li>状态多的场景下，导致类数目增加，系统变复杂</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：网站的课程视频有暂停，快进，停止，播放状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 课程状态抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseVideoState</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> CourseVideoContext courseVideoContext;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCourseVideoContext</span><span class="hljs-params">(CourseVideoContext courseVideoContext)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.courseVideoContext = courseVideoContext;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speed</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pause</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 播放状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CourseVideoState</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;正常播放课程视频状态&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speed</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.courseVideoContext.setCourseVideoState(CourseVideoContext.SPEED_STATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pause</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.courseVideoContext.setCourseVideoState(CourseVideoContext.PAUSE_STATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 快进状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpeedState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CourseVideoState</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speed</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;快进播放课程视频状态&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pause</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.courseVideoContext.setCourseVideoState(CourseVideoContext.PAUSE_STATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 暂停状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PauseState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CourseVideoState</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speed</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.courseVideoContext.setCourseVideoState(CourseVideoContext.SPEED_STATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pause</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;暂停播放课程视频状态&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 停止状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StopState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CourseVideoState</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speed</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ERROR 停止状态不能快进!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pause</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ERROR 停止状态不能暂停!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;停止播放课程视频状态&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 课程状态上下文</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseVideoContext</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> CourseVideoState courseVideoState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> PlayState PLAY_STATE = <span class="hljs-keyword">new</span> PlayState();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> StopState STOP_STATE = <span class="hljs-keyword">new</span> StopState();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> PauseState PAUSE_STATE = <span class="hljs-keyword">new</span> PauseState();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> SpeedState SPEED_STATE = <span class="hljs-keyword">new</span> SpeedState();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CourseVideoState <span class="hljs-title">getCourseVideoState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> courseVideoState;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCourseVideoState</span><span class="hljs-params">(CourseVideoState courseVideoState)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.courseVideoState = courseVideoState;<br>        <span class="hljs-keyword">this</span>.courseVideoState.setCourseVideoContext(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.courseVideoState.play();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speed</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.courseVideoState.speed();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.courseVideoState.stop();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pause</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.courseVideoState.pause();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CourseVideoContext courseVideoContext = <span class="hljs-keyword">new</span> CourseVideoContext();<br>        courseVideoContext.setCourseVideoState(<span class="hljs-keyword">new</span> PlayState());<br><br>        System.out.println(<span class="hljs-string">&quot;当前状态:&quot;</span>+courseVideoContext.getCourseVideoState().getClass().getSimpleName());<br>        courseVideoContext.pause();<br><br>        System.out.println(<span class="hljs-string">&quot;当前状态:&quot;</span>+courseVideoContext.getCourseVideoState().getClass().getSimpleName());<br><br>        courseVideoContext.speed();<br><br>        System.out.println(<span class="hljs-string">&quot;当前状态:&quot;</span>+courseVideoContext.getCourseVideoState().getClass().getSimpleName());<br><br>        courseVideoContext.stop();<br><br>        System.out.println(<span class="hljs-string">&quot;当前状态:&quot;</span>+courseVideoContext.getCourseVideoState().getClass().getSimpleName());<br>        <br>        courseVideoContext.speed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>当前状态:PlayState<br>当前状态:PauseState<br>当前状态:SpeedState<br>当前状态:StopState<br>ERROR 停止状态不能快进!!</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>访问者模式</title>
    <link href="/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><ul><li><p>它允许在不改变已有对象结构的情况下，定义对这些对象的新操作。</p></li><li><p>有两个核心角色：</p><ul><li>访问者（Visitor）：定义了可以对各种对象结构中元素进行的操作。它抽象出了可以对不同对象执行的操作，并通过不同的具体访问者来实现具体的操作逻辑。</li><li>元素（Element）：定义了一个接受访问者的方法，使得访问者可以访问它的内部状态。元素可以是单个对象，也可以是对象的集合。</li></ul></li><li><p>类型 : 行为型</p></li></ul><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li>需要对对象结构中的元素进行多种不相关或不一致的操作，而不希望在元素类中增加这些操作的情况。</li><li>需要对不同类型的元素执行不同的操作，而又不希望使用条件语句或类型判断来实现的情况。</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>增加新的操作很容易 , 只需要增加一个新的访问者即可</li></ul><p>缺点：</p><ul><li><p>增加 新 数据结构比较困难</p></li><li><p>元素变更比较困难 ; 如为被访问的对象增加 &#x2F; 减少一些属性 , 相应的访问者也需要进行修改</p></li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：课程分为免费课程和VIP课程 , 用户分为 免费用户 和 VIP用户 ;不同的用户 , 访问不同的课程 , 各自有不同的效果 ;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当有访问者要访问课程时 , 将访问者传入该方法</span><br><span class="hljs-comment">     * 用于判定访问者是否有权限访问课程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(IVisitor visitor)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeCourse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Course</span> </span>&#123;<br>    <br>  <span class="hljs-comment">// 免费课程，接受访问者，来判断访问者是否有权限访问课程</span><br>  <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(IVisitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VIPCourse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Course</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> price;<br><br>    <span class="hljs-comment">// VIP课程，接受访问者，来判断访问者是否有权限访问课程</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(IVisitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 访问者接口, 封装多个Course的访问方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IVisitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(FreeCourse freeCourse)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(VIPCourse VIPCourse)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VIPVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IVisitor</span> </span>&#123;<br><br>    <span class="hljs-comment">//访问免费课程，打印所有免费课程名称</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(FreeCourse freeCourse)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是 VIP, 可以访问:免费课程:&quot;</span>+freeCourse.getName());<br>    &#125;<br><br>    <span class="hljs-comment">//访问VIP课程，打印所有VIP课程名称及价格</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(VIPCourse VIPCourse)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是 VIP ,可以访问VIP课程:&quot;</span>+ VIPCourse.getName()+<span class="hljs-string">&quot; 价格:&quot;</span>+ VIPCourse.getPrice()+<span class="hljs-string">&quot;元&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Course&gt; courseList = <span class="hljs-keyword">new</span> ArrayList&lt;Course&gt;();<br><br>        FreeCourse freeCourse = <span class="hljs-keyword">new</span> FreeCourse();<br>        freeCourse.setName(<span class="hljs-string">&quot;SpringMVC数据绑定&quot;</span>);<br><br>        VIPCourse VIPCourse = <span class="hljs-keyword">new</span> VIPCourse();<br>        VIPCourse.setName(<span class="hljs-string">&quot;Java设计模式精讲&quot;</span>);<br>        VIPCourse.setPrice(<span class="hljs-number">299</span>);<br><br>        courseList.add(freeCourse);<br>        courseList.add(VIPCourse);<br><br>        <span class="hljs-keyword">for</span>(Course course : courseList)&#123;<br>            course.accept(<span class="hljs-keyword">new</span> VIPVisitor());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>我是 VIP, 可以访问:免费课程:SpringMVC数据绑定<br>我是 VIP ,可以访问VIP课程:Java设计模式精讲 价格:299元</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>责任链模式</title>
    <link href="/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>责任链模式为请求创建了一个接收者对象的链。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p>类型：行为型</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li>一个请求需要多个对象中的一个或者多个进行处理</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>责任链可以动态组合</li></ul><p>缺点：</p><ul><li>责任链太长或者处理时间太长，影响性能</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：发布一篇文章后，内容审查者审查内容，审查通过了后，视频审查者审查视频</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">private</span> String video;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Approver</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Approver approver;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNextApprover</span><span class="hljs-params">(Approver approver)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.approver = approver;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(Article article)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContentApprover</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Approver</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(Article article)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(article.getContent()))&#123;<br>            System.out.println(article.getName()+<span class="hljs-string">&quot;内容合规,批准&quot;</span>);<br>            <span class="hljs-keyword">if</span>(approver != <span class="hljs-keyword">null</span>)&#123;<br>                approver.check(article);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(article.getName()+<span class="hljs-string">&quot;内容不合规,不批准,流程结束&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoApprover</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Approver</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(Article article)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(article.getVideo()))&#123;<br>            System.out.println(article.getName()+<span class="hljs-string">&quot;视频内容合规,批准&quot;</span>);<br>            <span class="hljs-keyword">if</span>(approver != <span class="hljs-keyword">null</span>)&#123;<br>                approver.check(article);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(article.getName()+<span class="hljs-string">&quot;视频内容不合规,不批准,流程结束&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Approver contentApprover = <span class="hljs-keyword">new</span> ContentApprover();<br>        Approver videoApprover = <span class="hljs-keyword">new</span> VideoApprover();<br><br>        Article article = <span class="hljs-keyword">new</span> Article();<br>        article.setName(<span class="hljs-string">&quot;Java设计模式精讲&quot;</span>);<br>        article.setContent(<span class="hljs-string">&quot;Java设计模式精讲的内容&quot;</span>);<br>        article.setVideo(<span class="hljs-string">&quot;Java设计模式精讲的视频&quot;</span>);<br><br>        contentApprover.setNextApprover(videoApprover);<br><br>        contentApprover.check(article);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>中介者模式</title>
    <link href="/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>定义一个封装一组对象如何交互的对象</p><p>类型：行为型</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li>对象之间有复杂的通信关系：当对象之间的通信关系变得复杂时，使用中介者模式可以简化对象之间的交互，将复杂的通信逻辑转移到中介者中进行管理。</li><li>对象之间的耦合度较高：当对象之间的耦合度较高，彼此之间的依赖关系较为复杂时，可以使用中介者模式来解耦对象之间的关系，减少对象之间的直接依赖。</li><li>一对多的关系：中介者模式适用于一对多的关系，当一个对象需要与多个其他对象进行通信时，可以引入中介者来简化对象之间的通信。</li><li>分布式系统：中介者模式在分布式系统中也有应用。例如，分布式系统中的消息中间件可以看作是中介者，负责协调不同组件或服务之间的通信和数据交换。</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>解耦对象之间的关系：中介者模式通过将对象之间的通信集中在中介者对象中，将对象之间的直接耦合转换为对象与中介者的耦合。这样一来，对象之间的关系变得松散，可以独立地改变和复用对象和中介者。</li><li>简化对象协议：中介者模式可以简化对象之间的协议。对象只需要与中介者进行通信，不需要了解其他对象的具体实现细节，从而降低了对象之间的复杂性。</li><li>可扩展性和维护性：由于中介者模式将对象之间的通信集中管理，当系统需要增加新的对象时，只需与中介者进行交互即可，无需修改现有对象之间的通信逻辑。这提高了系统的可扩展性和维护性。</li></ul><p>缺点：</p><ul><li>中介者复杂化：随着系统中对象之间通信关系的增加，中介者对象可能变得复杂。它需要处理和管理多个对象之间的交互逻辑，可能会导致中介者本身的复杂性增加。</li><li>单点故障：中介者模式将对象之间的通信集中在中介者对象中，如果中介者对象出现问题或失败，可能会影响整个系统的正常运行。中介者的故障可能会导致通信链路中的所有对象无法正常通信。</li><li>违背单一职责原则：中介者模式可能导致中介者对象承担过多的责任。中介者需要了解和管理多个对象之间的通信关系，可能违背了单一职责原则，使得中介者对象变得庞大和复杂。</li><li>增加系统复杂性：引入中介者模式会增加系统中的额外类和对象，从而增加系统的复杂性。</li><li>通信效率降低：中介者模式可能导致通信效率降低。当系统中的对象需要频繁地进行通信时，由于通信都需要通过中介者进行转发，可能会导致通信的延迟增加。</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：</p><p>用户通过QQ群来进行聊天而不是直接面对面聊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        StudyGroup.showMessage(<span class="hljs-keyword">this</span>, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudyGroup</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">(User user, String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; [&quot;</span> + user.getName() + <span class="hljs-string">&quot;] : &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User geely = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Geely&quot;</span>);<br>        User tom= <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Tom&quot;</span>);<br><br>        geely.sendMessage(<span class="hljs-string">&quot; Hey! Tom! Let&#x27;s learn Design Pattern&quot;</span>);<br>        tom.sendMessage(<span class="hljs-string">&quot;OK! Geely&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>Wed Oct 04 21:43:12 CST 2023 [Geely] :  Hey! Tom! Let’s learn Design Pattern<br>Wed Oct 04 21:43:12 CST 2023 [Tom] : OK! Geely</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>命令模式</title>
    <link href="/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>将请求或操作封装成一个对象，<strong>从而使不同的请求可以被异步、延迟、排队，或者记录下来以备撤销或重做等操作</strong>。</p><p>类型：行为型</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li>撤销&#x2F;重做操作：当需要支持撤销和重做功能时，可以使用命令模式。命令对象可以记录操作的状态和参数，以便在需要时执行撤销操作</li><li>事务性操作：命令模式可以用于实现事务性操作，即一系列相关操作的执行要么全部成功，要么全部失败。通过将每个操作封装为一个命令对象，可以在需要时执行回滚操作，确保数据的一致性。</li><li>队列请求：命令模式可以用于构建请求队列。每个命令对象都表示一个请求，并且可以按顺序执行这些请求。这在需要按顺序执行一系列操作的情况下很有用。</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>降低耦合</li><li>容易扩展出新命令或者一组命令</li></ul><p>缺点：</p><ul><li>命令会扩展类的数量，从而提高系统复杂度</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：CEO下达打开课程视频和关闭课程视频的操作的命令，员工执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseVideo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CourseVideo</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;课程视频开放&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;课程视频关闭&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenCourseVideoCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> CourseVideo courseVideo;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenCourseVideoCommand</span><span class="hljs-params">(CourseVideo courseVideo)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.courseVideo = courseVideo;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        courseVideo.open();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseCourseVideoCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> CourseVideo courseVideo;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CloseCourseVideoCommand</span><span class="hljs-params">(CourseVideo courseVideo)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.courseVideo = courseVideo;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        courseVideo.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 员工记录需要执行的命令，进行执行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Staff</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Command&gt; commandList = <span class="hljs-keyword">new</span> ArrayList&lt;Command&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCommand</span><span class="hljs-params">(Command command)</span></span>&#123;<br>        commandList.add(command);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeCommands</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(Command command : commandList)&#123;<br>            command.execute();<br>        &#125;<br>        commandList.clear();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CourseVideo courseVideo = <span class="hljs-keyword">new</span> CourseVideo(<span class="hljs-string">&quot;Java设计模式精讲&quot;</span>);<br>        OpenCourseVideoCommand openCourseVideoCommand = <span class="hljs-keyword">new</span> OpenCourseVideoCommand(courseVideo);<br>        CloseCourseVideoCommand closeCourseVideoCommand = <span class="hljs-keyword">new</span> CloseCourseVideoCommand(courseVideo);<br><br>        Staff staff = <span class="hljs-keyword">new</span> Staff();<br>        staff.addCommand(openCourseVideoCommand);<br>        staff.addCommand(closeCourseVideoCommand);<br><br>        staff.executeCommands();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>Java设计模式精讲课程视频开放<br>Java设计模式精讲课程视频关闭</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>备忘录模式</title>
    <link href="/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>保存一个对象的某种状态，以便在适当的时候来恢复对象</p><p>类型：行为型</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><p>保存及恢复数据相关业务场景</p><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>为用户提供一种可恢复的机制</li><li>存档信息的封装</li></ul><p>缺点：</p><ul><li>资源占用</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：网站上发布博客，支持暂存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> String content;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArticleMemento <span class="hljs-title">saveToMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArticleMemento(<span class="hljs-keyword">this</span>.title, <span class="hljs-keyword">this</span>.content);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">undoFromMemento</span><span class="hljs-params">(ArticleMemento articleMemento)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.title = articleMemento.getTitle();<br>        <span class="hljs-keyword">this</span>.content = articleMemento.getContent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArticleMemento</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> String content;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用栈的先进后出来做备忘录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArticleMementoManager</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Stack&lt;ArticleMemento&gt; ARTICLE_MEMENTO_STACK = <span class="hljs-keyword">new</span> Stack&lt;ArticleMemento&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArticleMemento <span class="hljs-title">getMemento</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> ARTICLE_MEMENTO_STACK.pop();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addMemento</span><span class="hljs-params">(ArticleMemento articleMemento)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ARTICLE_MEMENTO_STACK.push(articleMemento);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArticleMementoManager articleMementoManager = <span class="hljs-keyword">new</span> ArticleMementoManager();<br>        Article article= <span class="hljs-keyword">new</span> Article(<span class="hljs-string">&quot;如影随行的设计模式A&quot;</span>,<span class="hljs-string">&quot;内容A&quot;</span>);<br><br>        <span class="hljs-comment">// 版本1保存到备忘录</span><br>        ArticleMemento articleMemento = article.saveToMemento();<br>        articleMementoManager.addMemento(articleMemento);<br>        System.out.println(<span class="hljs-string">&quot;标题:&quot;</span>+article.getTitle()+<span class="hljs-string">&quot; 内容:&quot;</span>+article.getContent()+<span class="hljs-string">&quot; 暂存成功&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;完整信息:&quot;</span>+article);<br><br>        System.out.println(<span class="hljs-string">&quot;============修改文章start============&quot;</span>);<br>        article.setTitle(<span class="hljs-string">&quot;如影随行的设计模式B&quot;</span>);<br>        article.setContent(<span class="hljs-string">&quot;内容B&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;============修改文章end============&quot;</span>);<br><br>        <span class="hljs-comment">// 版本2保存到备忘录</span><br>        articleMemento = article.saveToMemento();<br>        articleMementoManager.addMemento(articleMemento);<br>        System.out.println(<span class="hljs-string">&quot;标题:&quot;</span>+article.getTitle()+<span class="hljs-string">&quot; 内容:&quot;</span>+article.getContent()+<span class="hljs-string">&quot; 暂存成功&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;完整信息:&quot;</span>+article);<br><br>        <span class="hljs-comment">// 回退到版本2</span><br>        System.out.println(<span class="hljs-string">&quot;============暂存回退start============&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;回退出栈1次&quot;</span>);<br>        articleMemento = articleMementoManager.getMemento();<br>        article.undoFromMemento(articleMemento);<br><br>        <span class="hljs-comment">// 回退到版本1</span><br>        System.out.println(<span class="hljs-string">&quot;回退出栈2次&quot;</span>);<br>        articleMemento = articleMementoManager.getMemento();<br>        article.undoFromMemento(articleMemento);<br>        System.out.println(<span class="hljs-string">&quot;============暂存回退end============&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;完整信息:&quot;</span>+article);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>标题:如影随行的设计模式A 内容:内容A 暂存成功<br>完整信息:Article(title&#x3D;如影随行的设计模式A, content&#x3D;内容A)<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改文章start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改文章end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>标题:如影随行的设计模式B 内容:内容B 暂存成功<br>完整信息:Article(title&#x3D;如影随行的设计模式B, content&#x3D;内容B)<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;暂存回退start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>回退出栈1次<br>回退出栈2次<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;暂存回退end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>完整信息:Article(title&#x3D;如影随行的设计模式A, content&#x3D;内容A)</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>定义了对象之间的一对多依赖。让多个观察者同时监听一个主题对象，当主题对象发生变化时，它的观察者都会收到通知并更新。</p><p>类型：行为型</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><p>关联行为场景。建立一套触发机制</p><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>支持广播通信</li></ul><p>缺点：</p><ul><li>观察者之间有过多依赖的话，会提高程序复杂度</li><li>使用需要注意，避免观察者和被观察者循环调用</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：同学在网站上提出问题，老师收到通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 继承Observable表明他是被观察者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String courseName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Course</span><span class="hljs-params">(String courseName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.courseName = courseName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCourseName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> courseName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produceQuestion</span><span class="hljs-params">(Course course, Question question)</span></span>&#123;<br>        System.out.println(question.getUserName()+<span class="hljs-string">&quot;在&quot;</span>+course.courseName+<span class="hljs-string">&quot;提交了一个问题&quot;</span>);<br>        <span class="hljs-comment">// 设置对象发生变化</span><br>        setChanged();<br>        <span class="hljs-comment">// 通知观察者</span><br>        notifyObservers(question);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String questionContent;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  implements Observer表明Teacher是观察者类,</span><br><span class="hljs-comment"> *  复写update来指名接受到通知后执行的逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String teacherName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String teacherName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.teacherName = teacherName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        Course course = (Course)o;<br>        Question question = (Question)arg;<br>        System.out.println(teacherName+<span class="hljs-string">&quot;老师的&quot;</span>+course.getCourseName()+<span class="hljs-string">&quot;课程接收到一个&quot;</span>+question.getUserName()+<span class="hljs-string">&quot;提交的问答:&quot;</span>+question.getQuestionContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Course course = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;Java设计模式精讲&quot;</span>);<br>        Teacher teacher1 = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&quot;Alpha&quot;</span>);<br>        Teacher teacher2 = <span class="hljs-keyword">new</span> Teacher(<span class="hljs-string">&quot;Beta&quot;</span>);<br>        <br>        <span class="hljs-comment">// 添加观察者</span><br>        course.addObserver(teacher1);<br>        course.addObserver(teacher2);<br><br>        <span class="hljs-comment">//业务逻辑代码</span><br>        Question question = <span class="hljs-keyword">new</span> Question();<br>        question.setUserName(<span class="hljs-string">&quot;Geely&quot;</span>);<br>        question.setQuestionContent(<span class="hljs-string">&quot;Java的主函数如何编写&quot;</span>);<br><br>        course.produceQuestion(course,question);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>Geely在Java设计模式精讲提交了一个问题<br>Beta老师的Java设计模式精讲课程接收到一个Geely提交的问答:Java的主函数如何编写<br>Alpha老师的Java设计模式精讲课程接收到一个Geely提交的问答:Java的主函数如何编写</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解释器模式</title>
    <link href="/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>给定一个语言，定义它文法的一种表示。并定义一个解释器，使用这个解释器来解释语言中的句子</p><p>类型：行为型</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 </li><li>一些重复出现的问题可以用一种简单的语言来进行表</li><li>一个简单语法需要解释的场景。</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>语法由很多类组成，便于扩展</li></ul><p>缺点：</p><ul><li>语法 规则太多时，增加了系统复杂度</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：定义表达式【6 100 11 +  * <em>】，计算逻辑为（100 + 11 ）</em> * 6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interpreter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberInterpreter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interpreter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumberInterpreter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.number=number;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumberInterpreter</span><span class="hljs-params">(String number)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.number=Integer.parseInt(number);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.number;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddInterpreter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interpreter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Interpreter firstExpression,secondExpression;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AddInterpreter</span><span class="hljs-params">(Interpreter firstExpression, Interpreter secondExpression)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.firstExpression=firstExpression;<br>        <span class="hljs-keyword">this</span>.secondExpression=secondExpression;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstExpression.interpret()+<span class="hljs-keyword">this</span>.secondExpression.interpret();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;+&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiInterpreter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interpreter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Interpreter firstExpression,secondExpression;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultiInterpreter</span><span class="hljs-params">(Interpreter firstExpression, Interpreter secondExpression)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.firstExpression=firstExpression;<br>        <span class="hljs-keyword">this</span>.secondExpression=secondExpression;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstExpression.interpret()*<span class="hljs-keyword">this</span>.secondExpression.interpret();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;*&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyExpressionParser</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Interpreter&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Interpreter&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parse</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        String[] strItemArray = str.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (String symbol : strItemArray) &#123;<br>            <span class="hljs-keyword">if</span> (!isOperator(symbol)) &#123;<br>                Interpreter numberExpression = <span class="hljs-keyword">new</span> NumberInterpreter(symbol);<br>                stack.push(numberExpression);<br>                System.out.printf(<span class="hljs-string">&quot;入栈: %d%n&quot;</span>, numberExpression.interpret());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//是运算符号，可以计算</span><br>                Interpreter firstExpression = stack.pop();<br>                Interpreter secondExpression = stack.pop();<br>                System.out.printf(<span class="hljs-string">&quot;出栈: %d 和 %d%n&quot;</span>,<br>                        firstExpression.interpret(), secondExpression.interpret());<br>                Interpreter operator = getExpressionObject(firstExpression, secondExpression, symbol);<br>                System.out.printf(<span class="hljs-string">&quot;应用运算符: %s%n&quot;</span>, operator);<br>                <span class="hljs-keyword">int</span> result = operator.interpret();<br>                NumberInterpreter resultExpression = <span class="hljs-keyword">new</span> NumberInterpreter(result);<br>                stack.push(resultExpression);<br>                System.out.printf(<span class="hljs-string">&quot;阶段结果入栈: %d%n&quot;</span>, resultExpression.interpret());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> result = stack.pop().interpret();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(String symbol)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (symbol.equals(<span class="hljs-string">&quot;+&quot;</span>) || symbol.equals(<span class="hljs-string">&quot;*&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Interpreter <span class="hljs-title">getExpressionObject</span><span class="hljs-params">(Interpreter firstExpression, Interpreter secondExpression, String symbol)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (symbol.equals(<span class="hljs-string">&quot;+&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AddInterpreter(firstExpression, secondExpression);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (symbol.equals(<span class="hljs-string">&quot;*&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MultiInterpreter(firstExpression, secondExpression);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String geelyInputStr=<span class="hljs-string">&quot;6 100 11 + *&quot;</span>;<br>        MyExpressionParser expressionParser=<span class="hljs-keyword">new</span> MyExpressionParser();<br>        <span class="hljs-keyword">int</span> result=expressionParser.parse(geelyInputStr);<br>        System.out.println(<span class="hljs-string">&quot;解释器计算结果: &quot;</span>+result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>入栈: 6<br>入栈: 100<br>入栈: 11<br>出栈: 11 和 100<br>应用运算符: +<br>阶段结果入栈: 111<br>出栈: 111 和 6<br>应用运算符: *<br>阶段结果入栈: 666<br>解释器计算结果: 666</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。</p><p>类型：行为型</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li>一个系统需要动态在几种策略中选择一种</li><li>系统很多类，区别仅仅是行为不同</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>符合开闭原则</li><li>避免大量使用if…else, switch..case</li><li>提高算法的保密性和安全性</li></ul><p>缺点：</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪个类</li><li>产生很多策略类</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：慕课网活动促销，有多种方式：满减，返现，立减等，双11和618都采取不同的策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PromotionStrategy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doPromotion</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmptyPromotionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PromotionStrategy</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPromotion</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;无促销活动&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiJianPromotionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PromotionStrategy</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPromotion</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;立减促销,课程的价格直接减去配置的价格&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanXianPromotionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PromotionStrategy</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPromotion</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;返现促销,返回的金额存放到慕课网用户的余额中&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 促销活动</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PromotionActivity</span> </span>&#123;<br>  <span class="hljs-comment">// 促销策略</span><br>    <span class="hljs-keyword">private</span> PromotionStrategy promotionStrategy;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PromotionActivity</span><span class="hljs-params">(PromotionStrategy promotionStrategy)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.promotionStrategy = promotionStrategy;<br>    &#125;<br><br>  <span class="hljs-comment">// 执行促销</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executePromotionStrategy</span><span class="hljs-params">()</span></span>&#123;<br>        promotionStrategy.doPromotion();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        PromotionActivity promotionActivity618 = <span class="hljs-keyword">new</span> PromotionActivity(<span class="hljs-keyword">new</span> LiJianPromotionStrategy());<br>        PromotionActivity promotionActivity1111 = <span class="hljs-keyword">new</span> PromotionActivity(<span class="hljs-keyword">new</span> FanXianPromotionStrategy());<br><br>        promotionActivity618.executePromotionStrategy();<br>        promotionActivity1111.executePromotionStrategy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>立减促销,课程的价格直接减去配置的价格<br>返现促销,返回的金额存放到慕课网用户的余额中</p><p><strong>代码演进</strong></p><p>如果需要根据传过来的key，去选择对应的策略，使用共厂模式演进。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PromotionStrategyFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,PromotionStrategy&gt; PROMOTION_STRATEGY_MAP = <span class="hljs-keyword">new</span> HashMap&lt;String, PromotionStrategy&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        PROMOTION_STRATEGY_MAP.put(PromotionKey.LIJIAN,<span class="hljs-keyword">new</span> LiJianPromotionStrategy());<br>        PROMOTION_STRATEGY_MAP.put(PromotionKey.FANXIAN,<span class="hljs-keyword">new</span> FanXianPromotionStrategy());<br>    &#125;<br><br>    <span class="hljs-comment">// 避免每次进来都需要new</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PromotionStrategy NON_PROMOTION = <span class="hljs-keyword">new</span> EmptyPromotionStrategy();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">PromotionStrategyFactory</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PromotionStrategy <span class="hljs-title">getPromotionStrategy</span><span class="hljs-params">(String promotionKey)</span></span>&#123;<br>        PromotionStrategy promotionStrategy = PROMOTION_STRATEGY_MAP.get(promotionKey);<br>        <span class="hljs-keyword">return</span> promotionStrategy == <span class="hljs-keyword">null</span> ? NON_PROMOTION : promotionStrategy;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PromotionKey</span></span>&#123;<br>        String LIJIAN = <span class="hljs-string">&quot;LIJIAN&quot;</span>;<br>        String FANXIAN = <span class="hljs-string">&quot;FANXIAN&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String promotionKey = <span class="hljs-string">&quot;LIJIAN&quot;</span>;<br>        PromotionActivity promotionActivity = <span class="hljs-keyword">new</span> PromotionActivity(PromotionStrategyFactory.getPromotionStrategy(promotionKey));<br>        promotionActivity.executePromotionStrategy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>立减促销,课程的价格直接减去配置的价格</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>迭代器模式</title>
    <link href="/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>提供一种方法，顺序访问一个集合对象中的各个元素，而又不暴露该对象的内部展示</p><p>类型：行为型</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li>访问一个集合的内容，而不暴露该对象的内部展示</li><li>为遍历不同的集合结构提供一个统一的接口</li></ul><blockquote><p>平时我们不太会自己写，因为已经有很多工具类写好了</p></blockquote><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>分离了集合对象的存储和遍历行为，由迭代器进行遍历</li></ul><p>缺点：</p><ul><li>类的个数成对增加，需要新增迭代器类</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景： 遍历课程列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseAggregate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addCourse</span><span class="hljs-params">(Course course)</span></span>;<br>    <span class="hljs-function">CourseIterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseAggregateImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CourseAggregate</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List courseList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CourseAggregateImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.courseList = <span class="hljs-keyword">new</span> ArrayList();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCourse</span><span class="hljs-params">(Course course)</span> </span>&#123;<br>        courseList.add(course);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CourseIterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CourseIteratorImpl(courseList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseIterator</span> </span>&#123;<br>    <span class="hljs-function">Course <span class="hljs-title">nextCourse</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseIteratorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CourseIterator</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Course&gt; courseList;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position;<br>    <span class="hljs-keyword">private</span> Course course;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CourseIteratorImpl</span><span class="hljs-params">(List&lt;Course&gt; courseList)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.courseList=courseList;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Course <span class="hljs-title">nextCourse</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;返回课程,位置是: &quot;</span>+position);<br>        course=courseList.get(position);<br>        position++;<br>        <span class="hljs-keyword">return</span> course;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(position&lt; courseList.size())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Course course1 = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;Java电商一期&quot;</span>);<br>        Course course2 = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;Java电商二期&quot;</span>);<br>        Course course3 = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;Java设计模式精讲&quot;</span>);<br>        Course course4 = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;Python课程&quot;</span>);<br>        Course course5 = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;算法课程&quot;</span>);<br>        Course course6 = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;前端课程&quot;</span>);<br><br><br>        CourseAggregate courseAggregate = <span class="hljs-keyword">new</span> CourseAggregateImpl();<br><br>        courseAggregate.addCourse(course1);<br>        courseAggregate.addCourse(course2);<br>        courseAggregate.addCourse(course3);<br>        courseAggregate.addCourse(course4);<br>        courseAggregate.addCourse(course5);<br>        courseAggregate.addCourse(course6);<br><br>        System.out.println(<span class="hljs-string">&quot;-----课程列表-----&quot;</span>);<br>        printCourses(courseAggregate);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printCourses</span><span class="hljs-params">(CourseAggregate courseAggregate)</span></span>&#123;<br>        CourseIterator courseIterator= courseAggregate.getIterator();<br>        <span class="hljs-keyword">while</span>(!courseIterator.hasNext())&#123;<br>            Course course=courseIterator.nextCourse();<br>            System.out.println(course.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>返回课程,位置是: 0<br>Java电商一期<br>返回课程,位置是: 1<br>Java电商二期<br>返回课程,位置是: 2<br>Java设计模式精讲<br>返回课程,位置是: 3<br>Python课程<br>返回课程,位置是: 4<br>算法课程<br>返回课程,位置是: 5<br>前端课程</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模版方法模式</title>
    <link href="/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a><strong>1 定义</strong></h2><p>定义一个算法的骨架，允许子类为一个或者多个步骤提供实现。</p><p>使子类在不改变算法结构的情况下，重新定义算法的某些步骤</p><p>类型：行为型</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a><strong>2 应用场景</strong></h2><ul><li><p>一次性实现一个算法不变的部分，并将可变的行为留给子类实现</p></li><li><p>将各类中公共的行为抽取出来到一个公共的父类中，避免代码重复</p></li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a><strong>3 优缺点</strong></h2><p>优点：</p><ul><li>提高复用性</li><li>提高扩展性</li><li>符合开闭原则</li></ul><p>缺点：</p><ul><li>类数目增加</li><li>增加系统复杂度</li><li>继承自身缺点，如果父类添加新的抽象方法，所有子类都需要改一遍。</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><strong>2 代码实现</strong></h1><p>场景：</p><p>准备讲解前端和后端课程流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ACourse</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCourse</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.makePPT();<br>        <span class="hljs-keyword">this</span>.makeVideo();<br>        <span class="hljs-keyword">if</span>(needWriteArticle())&#123;<br>            <span class="hljs-keyword">this</span>.writeArticle();<br>        &#125;<br>        <span class="hljs-keyword">this</span>.prepareContentMaterial();<br>    &#125;<br><br>    <span class="hljs-comment">// 注意这里如果是必须要执行的步骤，必须加final，否则子类可以重写，就打乱了步骤</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makePPT</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;制作PPT&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeVideo</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;制作视频&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeArticle</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;编写课堂笔记&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//钩子方法，注意这里不是final的子类可以复写它</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">needWriteArticle</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContentMaterial</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BackEndCourse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ACourse</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prepareContentMaterial</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;提供课程Java源代码&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">needWriteArticle</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FECourse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ACourse</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> needWriteArticleFlag = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prepareContentMaterial</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;提供课程的前端代码&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;提供课程的图片等多媒体素材&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FECourse</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> needWriteArticleFlag)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.needWriteArticleFlag = needWriteArticleFlag;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">needWriteArticle</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.needWriteArticleFlag;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后端设计模式课程start---&quot;</span>);<br>        ACourse designPatternCourse = <span class="hljs-keyword">new</span> BackEndCourse();<br>        designPatternCourse.makeCourse();<br>        System.out.println(<span class="hljs-string">&quot;后端设计模式课程end---&quot;</span>);<br><br><br>        System.out.println(<span class="hljs-string">&quot;前端课程start---&quot;</span>);<br>        ACourse feCourse = <span class="hljs-keyword">new</span> FECourse(<span class="hljs-keyword">false</span>);<br>        feCourse.makeCourse();<br>        System.out.println(<span class="hljs-string">&quot;前端课程end---&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>后端设计模式课程start—<br>制作PPT<br>制作视频<br>编写课堂笔记<br>提供课程Java源代码<br>后端设计模式课程end—<br>前端课程start—<br>制作PPT<br>制作视频<br>提供课程的前端代码<br>提供课程的图片等多媒体素材<br>前端课程end—</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>桥接模式</title>
    <link href="/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><p>类型：结构型</p><blockquote><p><strong>桥</strong>我们大家都熟悉，顾名思义就是用来将河的两岸联系起来的。而此处的桥是用来将两个独立的结构联系起来，而这两个被联系起来的结构可以独立的变化。</p></blockquote><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a>2 应用场景</h2><ul><li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。（如中国工商银行 年付账号，会根据银行和存储方式两个维度进行扩展）</li><li>对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a>3 优缺点</h2><p>优点：</p><ul><li>抽象与实现分离，扩展能力强</li><li>使用了组合，符合合成复用原则</li></ul><p>缺点：</p><ul><li>增加了系统的复杂度。要求开发者可以正确地识别出系统中两个独立变化的维度</li><li>增加了系统的设计难度。</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><p>场景：</p><p>有一个银行类，他可以扩展出两个子类：中国工商银行和中国农业银行。希望这两个银行都支持月月存和年存这两种存储方式，由于已经有两个类，所以需要创建 中国工商银行+月月存，中国工商银行+年存，中国农业银行+月月存，中国农业银行+年存，这四种类来支持。</p><p>如果需要新增银行或者新增存储方式，将导致代码复杂程度指数增长。</p><p>解决：在银行和存储方式这两个独立的维度分别扩展，适用组合的方式建立关联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-function">Account <span class="hljs-title">createAccount</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonthSavingAccount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">createAccount</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;新建一个月存储账号。。。&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MonthSavingAccount();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YearSavingAccount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">createAccount</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;新建一个年存储账号。。。&quot;</span>);<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> YearSavingAccount();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Account account;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bank</span><span class="hljs-params">(Account account)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.account = account;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> Account <span class="hljs-title">createAccount</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABCBank</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bank</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ABCBank</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(account);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">Account <span class="hljs-title">createAccount</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开中国农业银行账号管理系统。。。&quot;</span>);<br>        account.createAccount();<br>        <span class="hljs-keyword">return</span> account;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ICBCBank</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bank</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ICBCBank</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(account);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">Account <span class="hljs-title">createAccount</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开中国工商银行账号管理系统。。。&quot;</span>);<br>        account.createAccount();<br>        <span class="hljs-keyword">return</span> account;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 新建一个工商银行 + 月存储账号</span><br>        Bank icbcBank = <span class="hljs-keyword">new</span> ICBCBank(<span class="hljs-keyword">new</span> MonthSavingAccount());<br>        icbcBank.createAccount();<br><br>        <span class="hljs-comment">// 新建一个工商银行 + 年存储账号</span><br>        Bank icbcBank2 = <span class="hljs-keyword">new</span> ICBCBank(<span class="hljs-keyword">new</span> YearSavingAccount());<br>        icbcBank2.createAccount();<br><br>        <span class="hljs-comment">// 新建一个农业银行 + 年存储账号</span><br>        Bank abcBank = <span class="hljs-keyword">new</span> ABCBank(<span class="hljs-keyword">new</span> YearSavingAccount());<br>        abcBank.createAccount();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>打开中国工商银行账号管理系统。。。<br>新建一个月存储账号。。。<br>打开中国工商银行账号管理系统。。。<br>新建一个年存储账号。。。<br>打开中国农业银行账号管理系统。。。<br>新建一个年存储账号。。。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>组合模式</title>
    <link href="/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>将对象组合成树形结构以表示“部分——整体”的层次结构</p><p>组合模式使客户端对单个对象和组合对象保持一致的处理方式</p><p>类型：结构型</p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2 适用场景"></a>2 适用场景</h2><ul><li>希望客户端可以忽略组合对象和单个对象之前的差异</li><li>处理树形结构时</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a>3 优缺点</h2><p>优点</p><ul><li>让客户端忽略了层次的差异，方便对整个层次进行控制。简化客户端代码</li><li>符合开闭原则</li></ul><p>缺点</p><ul><li>使设计变得抽象</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><p>场景：打印课程目录和课程的层次关系。课程的主目录包括课程目录和课程。</p><p>有些课程属于某个子目录下，有些无法归类到子目录，直属于主目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目录组件</span><br><span class="hljs-comment"> *      目录 和 书籍 都继承 CatalogComponent 接口</span><br><span class="hljs-comment"> *      子类根据当前的的类型 , 选择性重写接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatalogComponent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(CatalogComponent catalogComponent)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;不支持添加操作&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">(CatalogComponent catalogComponent)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;不支持获取名称操作&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;不支持打印操作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CatalogComponent</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> price;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Course</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">(CatalogComponent catalogComponent)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">(CatalogComponent catalogComponent)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.price;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Course Name:&quot;</span>+name+<span class="hljs-string">&quot; Price:&quot;</span>+price);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Catalog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CatalogComponent</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;CatalogComponent&gt; items = <span class="hljs-keyword">new</span> ArrayList&lt;CatalogComponent&gt;();<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer level;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Catalog</span><span class="hljs-params">(String name, Integer level)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.level = level;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(CatalogComponent catalogComponent)</span> </span>&#123;<br>        items.add(catalogComponent);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">(CatalogComponent catalogComponent)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.name);<br>        <span class="hljs-keyword">for</span>(CatalogComponent catalogComponent : items)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.level != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>  i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.level; i++)&#123;<br>                    System.out.print(<span class="hljs-string">&quot;  &quot;</span>);<br>                &#125;<br>            &#125;<br>            catalogComponent.print();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CatalogComponent linuxCourse = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;Linux课程&quot;</span>,<span class="hljs-number">11</span>);<br>        CatalogComponent windowsCourse = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;Windows课程&quot;</span>,<span class="hljs-number">11</span>);<br><br>        CatalogComponent javaCourseCatalog = <span class="hljs-keyword">new</span> Catalog(<span class="hljs-string">&quot;Java课程目录&quot;</span>,<span class="hljs-number">2</span>);<br><br>        CatalogComponent mmallCourse1 = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;Java电商一期&quot;</span>,<span class="hljs-number">55</span>);<br>        CatalogComponent mmallCourse2 = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;Java电商二期&quot;</span>,<span class="hljs-number">66</span>);<br>        CatalogComponent designPattern = <span class="hljs-keyword">new</span> Course(<span class="hljs-string">&quot;Java设计模式&quot;</span>,<span class="hljs-number">77</span>);<br><br>        javaCourseCatalog.add(mmallCourse1);<br>        javaCourseCatalog.add(mmallCourse2);<br>        javaCourseCatalog.add(designPattern);<br><br>        CatalogComponent mainCourseCatalog = <span class="hljs-keyword">new</span> Catalog(<span class="hljs-string">&quot;课程主目录&quot;</span>,<span class="hljs-number">1</span>);<br>        mainCourseCatalog.add(linuxCourse);<br>        mainCourseCatalog.add(windowsCourse);<br>        mainCourseCatalog.add(javaCourseCatalog);<br><br>        mainCourseCatalog.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231004141724348.png" alt="image-20231004141724348" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>享元模式</title>
    <link href="/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>“享”就表示共享，“元”表示对象。如果在一个系统中存在多个相同的对象，那么只需要共享一份对象的拷贝,而不必为每一次使用都创建新的对象。目的是减少对象创建，减少内存占用，提高系统性能。</p><p>类型：结构型</p><blockquote><p>比如：去图书馆借书，如果书架上有这本书直接拿走，到借阅机上借阅就好了，如果没有，可以到图书管理处去拿一本新书。对于整个图书馆来说，书其实就是共享的。对于我们借书的流程和图书共享的方式就是享元模式。</p></blockquote><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a>2 应用场景</h2><ul><li>系统底层开发。比如Java的string类型，如果有则返回，没有则创建一个，保存在字符串缓存池里；数据库连接池。</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a>3 优缺点</h2><p>优点：</p><ul><li>减少对象创建，减少内存占用，提高系统性能。</li></ul><p>缺点：</p><ul><li><p>关注内外部状态，关注线程安全问题。一般我们都用的HashMap,线程安全可以使用hashTable,提升效率可以concurentHashMap</p></li><li><p>提高了系统的复杂度</p></li></ul><h2 id="4-主要角色"><a href="#4-主要角色" class="headerlink" title="4 主要角色"></a>4 主要角色</h2><ul><li>抽象享元（Book）：定义需要共享的对象业务接口。享元类被创建出来总是为了实现某些特定的业务逻辑.</li><li>具体享元（ConcreteBook）：实现抽象享元类的接口，完成某一具体逻辑。在这里表示可以被借出。</li><li>享元工厂（Llibrary）：用于创建具体享元类，维护相同的享元对象。当请求对象已经存在时，直接返回对象，不存在时，在创建对象。在例子中的解释就是图书馆，保存了所有的书，当学生借书时，有就拿走，没有买一本新书。这里面其实是使用了单例模式的</li></ul><blockquote><p>享元工厂是享元模式的核心，它需要确保系统可以共享相同的对象。它会维护一个对象列表，当我们想要获取享元类时，如果请求的享元类已经被创建，则直接返回已有的享元类：若没有，则创建一个新的享元对象，并将它加入到维护队列中。</p></blockquote><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><p>场景：去图书馆借书，如果书架上有这本书直接拿走，到借阅机上借阅就好了，如果没有，可以到图书管理处去拿一本新书。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Book</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">borrow</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBook</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Book</span> </span>&#123;<br>    <span class="hljs-comment">//被借出的书名,外部状态，不可以共享的状态，传入的书名不同，书不同</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// 内部状态，这些书都属于新华书店，可共享的状态</span><br>    <span class="hljs-keyword">private</span> String librarySign = <span class="hljs-string">&quot;新华书店&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteBook</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">borrow</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;图书馆借出一本书，书名为：&quot;</span> + <span class="hljs-keyword">this</span>.name );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 相当于bookFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Book&gt; BOOK_MAP = <span class="hljs-keyword">new</span> HashMap&lt;String, Book&gt;();<br><br>    <span class="hljs-comment">//图书馆外借图书</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Book <span class="hljs-title">borrowBook</span><span class="hljs-params">(String bookName)</span></span>&#123;<br>        <span class="hljs-comment">//如果书架有，直接借出</span><br>        Book   book = BOOK_MAP.get(bookName);<br>        <span class="hljs-comment">//如果书架没有，那就调进来一本新书</span><br>        <span class="hljs-keyword">if</span>(book == <span class="hljs-keyword">null</span>)&#123;<br>            book = <span class="hljs-keyword">new</span> ConcreteBook(bookName);<br>            BOOK_MAP.put(bookName, book);<br>        &#125;<br>        <span class="hljs-keyword">return</span> book;<br>    &#125;<br><br>    <span class="hljs-comment">//图书馆书架上的书的数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAllBookSize</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BOOK_MAP.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] bookNames = &#123;<span class="hljs-string">&quot;白雪公主&quot;</span>,<span class="hljs-string">&quot;一千零一夜&quot;</span>,<span class="hljs-string">&quot;火烈鸟&quot;</span>,<span class="hljs-string">&quot;海蒂&quot;</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BOOK_SIZE = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BOOK_SIZE; i++) &#123;<br>            <span class="hljs-keyword">int</span> randomIndex = <span class="hljs-keyword">new</span> Random().nextInt(bookNames.length);<br>            String bookName = bookNames[randomIndex];<br>            Book book = Library.borrowBook(bookName);<br>            book.borrow();<br>        &#125;<br>        <span class="hljs-comment">//输出一些学生一共借多少本书</span><br>        System.out.println(<span class="hljs-string">&quot;学生一共借了 &quot;</span> + BOOK_SIZE + <span class="hljs-string">&quot; 本书! &quot;</span>);<br>        <span class="hljs-comment">//输出一下图书馆一共借出多少本书</span><br>        System.out.println(<span class="hljs-string">&quot;图书馆实际借出&quot;</span> + Library.getAllBookSize() + <span class="hljs-string">&quot; 本书&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>图书馆借出一本书，书名为：海蒂<br>图书馆借出一本书，书名为：火烈鸟<br>图书馆借出一本书，书名为：一千零一夜<br>图书馆借出一本书，书名为：火烈鸟<br>图书馆借出一本书，书名为：火烈鸟<br>图书馆借出一本书，书名为：白雪公主<br>图书馆借出一本书，书名为：白雪公主<br>图书馆借出一本书，书名为：海蒂<br>图书馆借出一本书，书名为：海蒂<br>图书馆借出一本书，书名为：一千零一夜<br>学生一共借了 10 本书!<br>图书馆实际借出4 本书</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>将一个类的接口转换成客户期望的另一个接口。使得原本不兼容的类，可以一起工作</p><p>类型：结构型</p><p>分类：</p><p>对象适配器：使用组合</p><p>类适配器：使用类继承</p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2 适用场景"></a>2 适用场景</h2><ul><li>已经存在的类，他的方法和需求不匹配时（方法的结果相同或相似）</li><li>不是软件设计阶段考虑的设计模式，是随着软件的维护，由于不同产品，不同厂家造成功能类似而接口不相同情况下的解决方案</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a>3 优缺点</h2><p>优点：</p><ul><li>提高类的透明性和复用，现有的类复用而不发生改变</li><li>目标类和适配器类解耦，提高程序扩展性</li><li>符合开闭原则</li></ul><p>缺点：</p><p>增加代码可读性的难度</p><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2 代码"></a>2 代码</h1><p>场景：将220V直流电，通过充电器转换成5V的交流电，从而给手机充电</p><h2 id="2-1-类适配器模式"><a href="#2-1-类适配器模式" class="headerlink" title="2.1 类适配器模式"></a>2.1 类适配器模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 被适配者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AC220</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">outputAC220V</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> output = <span class="hljs-number">220</span>;<br>        System.out.println(<span class="hljs-string">&quot;输出交流电&quot;</span>+output+<span class="hljs-string">&quot;V&quot;</span>);<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标输出</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DC5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">outputDC5V</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 适配器，使被适配者转换成目标类，并且有目标输出的接口方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PowerAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AC220</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DC5</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">outputDC5V</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> adapterInput = <span class="hljs-keyword">super</span>.outputAC220V();<br>        <span class="hljs-comment">//变压器...</span><br>        <span class="hljs-keyword">int</span> adapterOutput = adapterInput/<span class="hljs-number">44</span>;<br>        System.out.println(<span class="hljs-string">&quot;使用PowerAdapter输入AC:&quot;</span>+adapterInput+<span class="hljs-string">&quot;V&quot;</span>+<span class="hljs-string">&quot;输出DC:&quot;</span>+adapterOutput+<span class="hljs-string">&quot;V&quot;</span>);<br>        <span class="hljs-keyword">return</span> adapterOutput;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Target adapterTarget = <span class="hljs-keyword">new</span> Adapter();<br>        adapterTarget.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-对象适配器"><a href="#2-2-对象适配器" class="headerlink" title="2.2 对象适配器"></a>2.2 对象适配器</h2><p>只有适配器的代码发生了改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PowerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DC5</span></span>&#123;<br>    <span class="hljs-comment">// 这里使用组合的方式，将被适配者组合到了当前类</span><br>    <span class="hljs-keyword">private</span> AC220 ac220 = <span class="hljs-keyword">new</span> AC220();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">outputDC5V</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> adapterInput = ac220.outputAC220V();<br>        <span class="hljs-comment">//变压器...</span><br>        <span class="hljs-keyword">int</span> adapterOutput = adapterInput/<span class="hljs-number">44</span>;<br>        System.out.println(<span class="hljs-string">&quot;使用PowerAdapter输入AC:&quot;</span>+adapterInput+<span class="hljs-string">&quot;V&quot;</span>+<span class="hljs-string">&quot;输出DC:&quot;</span>+adapterOutput+<span class="hljs-string">&quot;V&quot;</span>);<br>        <span class="hljs-keyword">return</span> adapterOutput;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>装饰器模式</title>
    <link href="/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>在不改变原有对象的基础上，将功能附加到对象上</p><p>提供了比继承，更有弹性的替代方案（扩展原有对象功能）</p><p>类型：结构型</p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2 适用场景"></a>2 适用场景</h2><ul><li><p>扩展一个类的功能，或者给一个类添加附加职责</p></li><li><p>动态的给一个对象添加功能，这些功能可以再动态撤销</p></li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a>3 优缺点</h2><p>优点：</p><ul><li><p>继承的有力补充，比继承灵活，不改变原有对象的情况下，给一个对象添加功能</p></li><li><p>通过使用不同的装饰类以及这些装饰类的排列组合，可以实现不同的效果</p></li><li><p>符合开闭原则。装饰者和被装饰者可以独立变化</p></li></ul><p>缺点</p><ul><li><p>会出现更多的代码，更多的类，增加程序复杂性（各种抽象装饰类，抽象实体类）</p></li><li><p>动态装饰时，多层装饰会更复杂</p></li></ul><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h2><ul><li>通常需要一个抽象的实体类，一个具体的实体类。一个抽象的装饰者，一个具体的装饰者。</li><li>通常会将被装饰者，以参数的方式传给装饰者的构造器</li></ul><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2 代码"></a>2 代码</h1><p>业务场景：烧烤店老板制作煎饼，有人加一个鸡蛋，一个肠。有人加两个鸡蛋一个肠</p><p>实体：煎饼</p><p>装饰者：鸡蛋，香肠</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABattercake</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Battercake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ABattercake</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;煎饼&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ABattercake</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ABattercake aBattercake;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractDecorator</span><span class="hljs-params">(ABattercake aBattercake)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.aBattercake = aBattercake;<br>    &#125;<br><br>  <span class="hljs-comment">// 在制作煎饼和香肠时需要的一些额外的操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.aBattercake.getDesc();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.aBattercake.cost();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EggDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDecorator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EggDecorator</span><span class="hljs-params">(ABattercake aBattercake)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(aBattercake);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getDesc()+<span class="hljs-string">&quot; 加一个鸡蛋&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.cost()+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SausageDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SausageDecorator</span><span class="hljs-params">(ABattercake aBattercake)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(aBattercake);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getDesc()+<span class="hljs-string">&quot; 加一根香肠&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.cost()+<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ABattercake aBattercake;<br>        aBattercake = <span class="hljs-keyword">new</span> Battercake();<br>        <span class="hljs-comment">// 加一个鸡蛋</span><br>        aBattercake = <span class="hljs-keyword">new</span> EggDecorator(aBattercake);<br>        <span class="hljs-comment">// 加一个鸡蛋</span><br>        aBattercake = <span class="hljs-keyword">new</span> EggDecorator(aBattercake);<br>        <span class="hljs-comment">// 加一根香肠</span><br>        aBattercake = <span class="hljs-keyword">new</span> SausageDecorator(aBattercake);<br><br>        System.out.println(aBattercake.getDesc()+<span class="hljs-string">&quot; 销售价格:&quot;</span>+aBattercake.cost());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：煎饼 加一个鸡蛋 加一个鸡蛋 加一根香肠 销售价格:12</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>外观模式</title>
    <link href="/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>外观模式（Facade Pattern）：又叫门面模式，引入一个外观角色来简化调用者与各个子系统之间的交互，向客户端提供了一个统一的接口，用来访问子系统中的一群接口。</p><p>类型： 结构型</p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2 适用场景"></a>2 适用场景</h2><ul><li>当调用者需要调用多个子系统来完成自己的逻辑</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a>3 优缺点</h2><p>优点：</p><ul><li>给各个子系统提供统一的入口，无需深入了解子系统，调用者使用起来很简单</li><li>把各个子系统和调用者解耦，扩展性会更好</li><li>更好的划分访问层次。有些子方法是不需要暴露给外部的，有些是需要的。我们把需要暴露的方法，集成在外观类上</li><li>符合迪米特法则，即最小知道法则。客户端只需要和外观类进行交互，不需要和子系统进行交互</li></ul><p>缺点：</p><p>如果设计不合理，增加新的子系统时可能需要修改外观类或调用者的源代码，违背了“开闭原则”</p><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><p>场景：积分商城，根据已有积分购买商品。涉及到的子系统为：积分校验系统，支付系统，物流系统.</p><p>调用者不需要知道校验，支付，物流的情况，只需要知道要使用积分，兑换哪个商品即可，所以构建积分兑换类，使调用者直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointsGift</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PointsGift</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QualifyService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAvailable</span><span class="hljs-params">(PointsGift pointsGift)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;校验&quot;</span>+pointsGift.getName()+<span class="hljs-string">&quot; 积分资格通过,库存通过&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointsPaymentService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">pay</span><span class="hljs-params">(PointsGift pointsGift)</span></span>&#123;<br>        <span class="hljs-comment">//扣减积分</span><br>        System.out.println(<span class="hljs-string">&quot;支付&quot;</span>+pointsGift.getName()+<span class="hljs-string">&quot; 积分成功&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShippingService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">shipGift</span><span class="hljs-params">(PointsGift pointsGift)</span></span>&#123;<br>        <span class="hljs-comment">//物流系统的对接逻辑</span><br>        System.out.println(pointsGift.getName()+<span class="hljs-string">&quot;进入物流系统&quot;</span>);<br>        String shippingOrderNo = <span class="hljs-string">&quot;666&quot;</span>;<br>        <span class="hljs-keyword">return</span> shippingOrderNo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GiftExchangeService</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> QualifyService qualifyService = <span class="hljs-keyword">new</span> QualifyService();<br>    <span class="hljs-keyword">private</span> PointsPaymentService pointsPaymentService = <span class="hljs-keyword">new</span> PointsPaymentService();<br>    <span class="hljs-keyword">private</span> ShippingService shippingService = <span class="hljs-keyword">new</span> ShippingService();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">giftExchange</span><span class="hljs-params">(PointsGift pointsGift)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(qualifyService.isAvailable(pointsGift))&#123;<br>            <span class="hljs-comment">//资格校验通过</span><br>            <span class="hljs-keyword">if</span>(pointsPaymentService.pay(pointsGift))&#123;<br>                <span class="hljs-comment">//如果支付积分成功</span><br>                String shippingOrderNo = shippingService.shipGift(pointsGift);<br>                System.out.println(<span class="hljs-string">&quot;物流系统下单成功,订单号是:&quot;</span>+shippingOrderNo);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        PointsGift pointsGift = <span class="hljs-keyword">new</span> PointsGift(<span class="hljs-string">&quot;T恤&quot;</span>);<br>        GiftExchangeService giftExchangeService = <span class="hljs-keyword">new</span> GiftExchangeService();<br>        giftExchangeService.giftExchange(pointsGift);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker+jenkins实现SpringBoot项目自动化部署</title>
    <link href="/docker+jenkins%E5%AE%9E%E7%8E%B0SpringBoot%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/docker+jenkins%E5%AE%9E%E7%8E%B0SpringBoot%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>当前有一个微服务项目，共包含4个常用的微服务子项目，原始项目升级方式为:</p><ol><li>修改application.yml文件，profile为product</li><li>在自己的电脑上手动利用maven打包，分为clean, package</li><li>分别进入4个项目的target目录下，将打好的jar包拷贝出来。</li><li>将本机拷贝出来的4个jar包上传到跳板机上</li><li>将上传到跳班机上的4个jar包拷贝出来，传到客户服务器上的指定目录</li><li>在服务器上依次执行jps -l（列出当前正在运行的Java进程和它们的进程PID），kill -9 , jar -jar xxx.jar命令</li><li>再次执行jps -l，查看服务是否正常启动</li></ol><p>流程不仅复杂，而且耗费时间，所以考虑自动化部署，来简化这一体系流程</p><h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h1><ol><li><p>从git仓库拉取最新代码</p></li><li><p>利用maven执行clean , package操作，进行打包</p></li><li><p>打包结果通知到飞书（可有可无）</p></li><li><p>将打好的jar包，发送到指定服务器上</p></li><li><p>执行部署脚本 包括kill -9 , jar -jar xxx.jar</p></li></ol><h1 id="3-具体步骤"><a href="#3-具体步骤" class="headerlink" title="3 具体步骤"></a>3 具体步骤</h1><h2 id="1-配置maven和jdk"><a href="#1-配置maven和jdk" class="headerlink" title="1. 配置maven和jdk"></a>1. 配置maven和jdk</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231005191707787.png" alt="image-20231005191707787"></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231005191548704.png" alt="image-20231005191548704"></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231005191644036.png" alt="image-20231005191644036"></p><h2 id="2-新建Job"><a href="#2-新建Job" class="headerlink" title="2. 新建Job"></a>2. 新建Job</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231005191359836.png" alt="image-20231005191359836"></p><h2 id="3-配置git仓库地址和分支名"><a href="#3-配置git仓库地址和分支名" class="headerlink" title="3. 配置git仓库地址和分支名"></a>3. 配置git仓库地址和分支名</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230315160535916.png" alt="img"></p><h2 id="4-配置构建环境"><a href="#4-配置构建环境" class="headerlink" title="4. 配置构建环境"></a>4. 配置构建环境</h2><p>每次构建前删除工作空间（避免由于类转移位置后，两个位置都存在类，引起同名bean冲突）</p><p>打印控制台输出时间戳，便于观察构建进度</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231005191939745.png" alt="image-20231005191939745"></p><h2 id="5-配置编译使用的pom-xml文件"><a href="#5-配置编译使用的pom-xml文件" class="headerlink" title="5 配置编译使用的pom.xml文件"></a>5 配置编译使用的pom.xml文件</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231005192206486.png" alt="image-20231005192206486"></p><h2 id="6-配置给飞书发送通知"><a href="#6-配置给飞书发送通知" class="headerlink" title="6 配置给飞书发送通知"></a>6 配置给飞书发送通知</h2><p>由于不论成功还是失败都需要给飞书发送通知，这里使用了<strong>Post build task</strong> 插件</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231005192341444.png" alt="image-20231005192341444"></p><p>feishu.sh:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#！/bin/bash</span><br>jobName=<span class="hljs-variable">$JOB_BASE_NAME</span><br>json=$(curl -u admin:password https://xxx.com.cn/jenkins/job/<span class="hljs-variable">$jobName</span>/<span class="hljs-variable">$&#123;BUILD_NUMBER&#125;</span>/api/json)<br>state=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$json</span> | sed <span class="hljs-string">&#x27;s/,/\n/g&#x27;</span> | grep <span class="hljs-string">&quot;result&quot;</span> | sed <span class="hljs-string">&#x27;s/:/\n/g&#x27;</span> | sed <span class="hljs-string">&#x27;1d&#x27;</span> | sed <span class="hljs-string">&#x27;s/&#125;//g&#x27;</span>)<br>nowTime=$(TZ=UTC-8 date +%Y-%m-%d<span class="hljs-string">&quot; &quot;</span>%H:%M:%S)<br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;state&#125;</span> == <span class="hljs-string">&quot;\&quot;SUCCESS\&quot;&quot;</span> ] ; <span class="hljs-keyword">then</span> stateText=<span class="hljs-string">&quot;成功&quot;</span>; <span class="hljs-keyword">else</span> stateText=<span class="hljs-string">&quot;失败&quot;</span>; <span class="hljs-keyword">fi</span><br>curl -X POST -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> \<br>        -d <span class="hljs-string">&#x27;&#123;&quot;msg_type&quot;:&quot;post&quot;,&quot;content&quot;: &#123;&quot;post&quot;: &#123;&quot;zh_cn&quot;: &#123;&quot;title&quot;: &quot;jenkins构建报告&quot;,&quot;content&quot;: [[&#123;&quot;tag&quot;: &quot;text&quot;,&quot;text&quot;: &quot;&#x27;</span><span class="hljs-string">&quot;名  称：<span class="hljs-variable">$jobName</span>\n编  号：<span class="hljs-variable">$&#123;BUILD_NUMBER&#125;</span>\n状  态:  <span class="hljs-variable">$stateText</span>\n时  间:  <span class="hljs-variable">$nowTime</span>\n详  情:  https://xxx.com.cn/jenkins/job/<span class="hljs-variable">$jobName</span>/<span class="hljs-variable">$&#123;BUILD_NUMBER&#125;</span>/console\n日  志：https://b1ortdxsoc.feishu.cn/wiki/RbAowYec2iUw72kWlJocapX8n2f&quot;</span><span class="hljs-string">&#x27;&quot;&#125;]]&#125; &#125; &#125;&#125;&#x27;</span> \<br>https://open.feishu.cn/open-apis/bot/v2/hook/ffb88764-379c-4a98-8496-b1a713114f3<br></code></pre></td></tr></table></figure><p>飞书收到的格式为：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231005192946100.png" alt="image-20231005192946100"></p><h2 id="7-每个微服务单独建一个执行job"><a href="#7-每个微服务单独建一个执行job" class="headerlink" title="7 每个微服务单独建一个执行job"></a>7 每个微服务单独建一个执行job</h2><p>配置运行这个job时，将构建好的jar包上传到客户服务器上，并且执行部署脚本</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231005193534214.png" alt="image-20231005193534214"></p><p>deploy.sh：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">source</span> /etc/profile<br>java -version<br>BUILD_ID=dontKillMe<br><span class="hljs-built_in">export</span> TERM=xterm<br>CURRENT_TIMESTAMP=$(date +%s)<br>NOW=$(date -d @<span class="hljs-variable">$CURRENT_TIMESTAMP</span> <span class="hljs-string">&quot;+%Y-%m-%d_%H-%M-%S&quot;</span>)<br>jar=<span class="hljs-variable">$1</span>-1.0.0-SNAPSHOT.jar<br>cp <span class="hljs-variable">$jar</span> <span class="hljs-variable">$1</span>-<span class="hljs-variable">$NOW</span>.jar<br>jar=`ls <span class="hljs-variable">$1</span>*.jar |sort -r|head -n 1`<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$jar</span><br><br>profile_active=sithMes<br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    profile_active=<span class="hljs-variable">$2</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;set profile_active: <span class="hljs-variable">$profile_active</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><br>log_output=/dev/null<br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$3</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    log_output=<span class="hljs-variable">$3</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;set log_output: <span class="hljs-variable">$log_output</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><br>ps -ef | grep java | grep <span class="hljs-variable">$1</span> | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="hljs-built_in">kill</span> -9<br>nohup java -jar <span class="hljs-variable">$jar</span> --spring.profiles.active=<span class="hljs-variable">$profile_active</span> &gt;<span class="hljs-variable">$log_output</span> 2&gt;&amp;1 &amp;<br>sleep 30<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> $(pgrep -f <span class="hljs-variable">$jar</span>|wc -l) -eq 0<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start Failed&quot;</span><br>   <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start Success&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;============================== 执行 top | head -50 =====================&#x27;</span><br><br>top -b| head -40<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;================================== 执行 jps -l ========================&#x27;</span><br><br>jps -l<br></code></pre></td></tr></table></figure><blockquote><p>这里 没查到jar包执行时，执行exit 1，会时jenkins当前job的状态变成黄色，而不是成功时的绿色。</p></blockquote><h1 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4 常见问题"></a>4 常见问题</h1><h2 id="1-jenkins迁移时需要迁移哪些文件夹？"><a href="#1-jenkins迁移时需要迁移哪些文件夹？" class="headerlink" title="1 jenkins迁移时需要迁移哪些文件夹？"></a>1 jenkins迁移时需要迁移哪些文件夹？</h2><p>将老服务器<a href="https://so.csdn.net/so/search?q=jenkins&spm=1001.2101.3001.7020">jenkins</a>主目录下的config.xml文件以及jobs、users、workspace、plugins四个目录拷贝到新机器的jenkins主目录下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker cp /Users/panyurou/.jenkins/<span class="hljs-built_in">jobs</span>  6257c7abfa11:/var/jenkins_home/<span class="hljs-built_in">jobs</span><br></code></pre></td></tr></table></figure><h2 id="2-使用docker增加前缀-x2F-jenkins"><a href="#2-使用docker增加前缀-x2F-jenkins" class="headerlink" title="2 使用docker增加前缀 &#x2F;jenkins"></a>2 使用docker增加前缀 &#x2F;jenkins</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull jenkins/jenkins:2.346<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -p 8089:8080  --name jenkins4 -e JENKINS_OPTS=<span class="hljs-string">&quot;--prefix=/jenkins&quot;</span> jenkins/jenkins:2.346<br></code></pre></td></tr></table></figure><h2 id="3-没权限"><a href="#3-没权限" class="headerlink" title="3 没权限"></a>3 没权限</h2><p>报错：I have experienced this when the $JENKINS_HOME&#x2F;jobs directory had incorrect permissions or ownership.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it --user root 7666058a5629 bash<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">chown -R jenkins:jenkins /var/jenkins_home<br></code></pre></td></tr></table></figure><h2 id="4-SSH服务器验证失败"><a href="#4-SSH服务器验证失败" class="headerlink" title="4 SSH服务器验证失败"></a>4 SSH服务器验证失败</h2><p>报错： stderr: No RSA host key is known for [xxx.xxx.xxx.xxx]:7999 and you have requested strict checking.</p><p>Manage Jenkins -&gt; Security -&gt; Configure Global Security</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231003184529837.png" alt="image-20231003184529837"></p><h2 id="5-Docker部署jenkins配置公私钥拉取代码"><a href="#5-Docker部署jenkins配置公私钥拉取代码" class="headerlink" title="5 Docker部署jenkins配置公私钥拉取代码"></a>5 Docker部署jenkins配置公私钥拉取代码</h2><p><a href="https://blog.csdn.net/weixin_38080573/article/details/128482482">https://blog.csdn.net/weixin_38080573/article/details/128482482</a></p><h2 id="6-jdk，maven需要重新配置docker里安装的路径"><a href="#6-jdk，maven需要重新配置docker里安装的路径" class="headerlink" title="6 jdk，maven需要重新配置docker里安装的路径"></a>6 jdk，maven需要重新配置docker里安装的路径</h2><p>maven settings.xml 仓库需要配置成docker里的仓库</p><h2 id="7-设置开机自启docker"><a href="#7-设置开机自启docker" class="headerlink" title="7 设置开机自启docker"></a>7 设置开机自启docker</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-builtin-name">enable</span> docker<br></code></pre></td></tr></table></figure><h2 id="8-设置docker启动时，启动jenkins容器"><a href="#8-设置docker启动时，启动jenkins容器" class="headerlink" title="8 设置docker启动时，启动jenkins容器"></a>8 设置docker启动时，启动jenkins容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker update --restart=always jenkins<br></code></pre></td></tr></table></figure><p>⚠️如果构建的是pipeline, 可参考以下脚本：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>  agent any<br>  stages &#123;<br>    stage(<span class="hljs-string">&#x27;Git Pull&#x27;</span>) &#123;<br>        steps &#123;<br>            <span class="hljs-comment">// 从 Git 仓库拉取代码</span><br>            deleteDir()<br>            echo <span class="hljs-string">&quot;start fetch code from git&quot;</span><br>            git <span class="hljs-attr">branch:</span> <span class="hljs-string">&#x27;sith_mom/master&#x27;</span>, <span class="hljs-attr">credentialsId:</span> <span class="hljs-string">&#x27;sshkey-cre&#x27;</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;git@codeup.aliyun.com:61794b74d39c439da2ee88ff/SIEMENS_MMF/MMF.git&#x27;</span><br>        &#125;<br>    &#125;<br>    <br>    stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;<br>        steps &#123;<br>            <span class="hljs-comment">// 打印当前 Java 版本</span><br>            sh <span class="hljs-string">&#x27;java -version&#x27;</span><br>            <span class="hljs-comment">// 设置 JAVA_HOME 环境变量为 JDK 1.8 的路径</span><br>            script &#123;<br>                env.JAVA_HOME = <span class="hljs-string">&#x27;/home/jdk1.8.0_381&#x27;</span><br>            &#125;<br><br>            <span class="hljs-comment">// 执行 Maven 编译</span><br>             sh <span class="hljs-string">&#x27;/home/apache-maven-3.6.3/bin/mvn -f mmf-backend/pom.xml -s /home/apache-maven-3.6.3/conf/my-settings.xml -gs /home/apache-maven-3.6.3/conf/my-settings.xml clean package -T 1C -Dmaven.test.skip=true -Dmaven.compile.fork=true&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>post &#123;<br>    always &#123;<br>        script &#123;<br>            sh <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">                cd /home</span><br><span class="hljs-string">                bash feishu.sh</span><br><span class="hljs-string">             &#x27;&#x27;&#x27;</span><br>        &#125;<br>    &#125;<br>    success &#123;<br>        <span class="hljs-comment">// 构建成功后的操作</span><br>        echo <span class="hljs-string">&#x27;Build successful!&#x27;</span><br>    &#125;<br>    failure &#123;<br>        <span class="hljs-comment">// 构建失败后的操作</span><br>        echo <span class="hljs-string">&#x27;Build failed!&#x27;</span><br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或许需要执行的操作：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> -R <span class="hljs-number">777</span> apache-maven-<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">chmod</span> <span class="hljs-number">755</span> /home/jdk<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>_<span class="hljs-number">381</span>/bin<br><span class="hljs-attribute">chmod</span> -R <span class="hljs-number">777</span> /home/node-v<span class="hljs-number">14</span>.<span class="hljs-number">17</span>.<span class="hljs-number">1</span>-linux-x<span class="hljs-number">64</span>/bin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用23种设计模式</title>
    <link href="/%E5%B8%B8%E7%94%A823%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E5%B8%B8%E7%94%A823%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p><em>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。</em></p><p><strong>优点</strong></p><ul><li>重用代码</li><li>让代码更容易被他人理解</li><li>保证代码可靠性</li></ul><h2 id="2-六大原则"><a href="#2-六大原则" class="headerlink" title="2 六大原则"></a>2 六大原则</h2><ul><li><strong>开闭原则</strong>：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</li><li><strong>里氏代换原则</strong>：任何基类可以出现的地方，子类一定可以出现。</li><li><strong>依赖倒转原则</strong>：针对接口编程，依赖于抽象而不依赖于具体。</li><li><strong>接口隔离原则</strong>：使用多个隔离的接口，比使用单个接口要好。</li><li><strong>迪米特法则</strong>：又称最少知道原则。一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</li><li><strong>合成复用原则</strong>：尽量使用合成&#x2F;聚合的方式，而不是使用继承。</li></ul><h1 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h1><h2 id="1-创建型模式（五种）"><a href="#1-创建型模式（五种）" class="headerlink" title="1 创建型模式（五种）"></a>1 创建型模式（五种）</h2><p>这些模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。</p><p><a href="https://pyr9.github.io/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</a></p><p><a href="https://pyr9.github.io/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">工厂模式</a></p><p><a href="https://pyr9.github.io/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">抽象工厂模式</a></p><p><a href="https://pyr9.github.io/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">建造者模式</a></p><p><a href="https://pyr9.github.io/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">原型模式</a></p><h2 id="2-结构型模式（七种）"><a href="#2-结构型模式（七种）" class="headerlink" title="2. 结构型模式（七种）"></a>2. 结构型模式（七种）</h2><p>这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。</p><p><a href="https://pyr9.github.io/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">适配器模式</a></p><p><a href="https://pyr9.github.io/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/">装饰器模式</a></p><p><a href="https://pyr9.github.io/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式</a></p><p><a href="https://pyr9.github.io/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">外观模式</a></p><p><a href="%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接模式</a></p><p><a href="https://pyr9.github.io/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">组合模式</a></p><p><a href="https://pyr9.github.io/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">享元模式</a></p><h2 id="3-行为型模式（十一种）"><a href="#3-行为型模式（十一种）" class="headerlink" title="3 行为型模式（十一种）"></a>3 行为型模式（十一种）</h2><p>这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。</p><p><a href="https://pyr9.github.io/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a></p><p><a href="https://pyr9.github.io/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">模板方法模式</a></p><p><a href="https://pyr9.github.io/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</a></p><p><a href="https://pyr9.github.io/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">迭代器模式</a></p><p><a href="https://pyr9.github.io/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/">责任链模式</a></p><p><a href="https://pyr9.github.io/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">命令模式</a></p><p><a href="https://pyr9.github.io/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">备忘录模式</a></p><p><a href="https://pyr9.github.io/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">状态模式</a></p><p><a href="https://pyr9.github.io/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">访问者模式</a></p><p><a href="https://pyr9.github.io/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">中介者模式</a></p><p><a href="https://pyr9.github.io/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">解释器模式</a></p><h1 id="2-对比"><a href="#2-对比" class="headerlink" title="2 对比"></a>2 对比</h1><h2 id="1-享元模式与单例模式的区别"><a href="#1-享元模式与单例模式的区别" class="headerlink" title="1 享元模式与单例模式的区别"></a>1 享元模式与单例模式的区别</h2><ul><li><p>享元设计模式是一个类有很多对象，而单例是一个类仅一个对象。</p></li><li><p>享元模式是为了节约内存空间，提升程序性能，而单例模式则主要是出于共享一个实例的目的。</p></li></ul><h2 id="2-桥接模式和组合模式"><a href="#2-桥接模式和组合模式" class="headerlink" title="2 桥接模式和组合模式"></a>2 桥接模式和组合模式</h2><ul><li>组合模式强调部分和整体的组合</li><li>桥接模式强调平行级别上不同类的组合</li></ul><h2 id="3-桥接模式和适配器模式"><a href="#3-桥接模式和适配器模式" class="headerlink" title="3 桥接模式和适配器模式"></a>3 桥接模式和适配器模式</h2><p>共同点：都是为了让两个东西配合工作</p><p>区别</p><ul><li>适配器是改变已有的接口，使他们可以配合</li><li>桥接是使类的抽象和实现分离开，使层次结构组合起来</li></ul><h2 id="4-模版方法模式和策略模式"><a href="#4-模版方法模式和策略模式" class="headerlink" title="4 模版方法模式和策略模式"></a>4 模版方法模式和策略模式</h2><ul><li>策略模式可以改变算法的流程，模版方法模式不可以</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>原型模式（Prototype）是一种创建型设计模式，它通过克隆现有的对象来创建新的对象。部分场景下，性能要优于new来创建对象</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2 应用场景"></a>2 应用场景</h2><ul><li>类初始化消耗比较多的资源</li><li>new一个对象需要很繁琐的过程（数据准备，访问权限等）</li><li>构造函数比较复杂</li><li>循环体中产生大量对象。（避免重复执行构造函数的操作，从而提高性能和效率）</li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a>3 优缺点</h2><p>优点：</p><ul><li>不需要调用构造函数，比直接new一个对象性能高</li><li>简化创建过程</li></ul><p>缺点：</p><ul><li>必须配备clone方法</li><li>深拷贝和浅拷贝容易引入bug</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><p>我们可以使用<code>java.lang.Cloneable</code>接口和<code>clone()</code>方法来实现原型模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Date birthday;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>        Date birthday = <span class="hljs-keyword">new</span> Date(<span class="hljs-number">0L</span>);<br>        Pig pig1 = <span class="hljs-keyword">new</span> Pig(<span class="hljs-string">&quot;佩奇&quot;</span>,birthday);<br>        Pig pig2 = (Pig) pig1.clone();<br>        System.out.println(pig1);<br>        System.out.println(pig2);<br><br>        pig1.getBirthday().setTime(<span class="hljs-number">666666666666L</span>);<br>        System.out.println(<span class="hljs-string">&quot;==================更新日期====================&quot;</span>);<br><br>        System.out.println(pig1);<br>        System.out.println(pig2);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231003175638825.png" alt="image-20231003175638825"></p><p>可以看到，通过<code>clone()</code>方法通过调用复制构造函数来创建一个新的<code>Pig</code>对象，但是需要注意深拷贝与浅拷贝的问题。</p><p>在上面的例子中，我们期待的结果是只更新pig1的生日，但是由于pig1和pig2的生日是同一个引用，所以pīg2的生日也更新了。</p><p>clone方法做以下调整，将birthday也进行clone：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>    Pig pig = (Pig)<span class="hljs-keyword">super</span>.clone();<br>    <span class="hljs-comment">////深克隆</span><br>    pig.birthday = (Date) pig.birthday.clone();<br>    <span class="hljs-keyword">return</span> pig;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-克隆破坏单例"><a href="#3-克隆破坏单例" class="headerlink" title="3. 克隆破坏单例"></a>3. 克隆破坏单例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HungrySingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> HungrySingleton hungrySingleton= <span class="hljs-keyword">new</span> HungrySingleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> hungrySingleton;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>        HungrySingleton hungrySingleton = HungrySingleton.getInstance();<br>        Method method = hungrySingleton.getClass().getDeclaredMethod(<span class="hljs-string">&quot;clone&quot;</span>);<br>        method.setAccessible(<span class="hljs-keyword">true</span>);<br>        HungrySingleton cloneHungrySingleton = (HungrySingleton) method.invoke(hungrySingleton);<br>        System.out.println(hungrySingleton);<br>        System.out.println(cloneHungrySingleton);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231003181533190.png" alt="image-20231003181533190"></p><p>解决:</p><ol><li>修改clone方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>  <span class="hljs-keyword">return</span> getInstance();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>避免单例类实现 Cloneable</li></ol><h1 id="3-JDK的使用"><a href="#3-JDK的使用" class="headerlink" title="3. JDK的使用"></a>3. JDK的使用</h1><p>实现了Cloneable的类</p><ul><li>arrayList</li><li>Hashmap</li><li>Object</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul><li><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。</p></li><li><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。</p></li><li><p>这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。它分为懒汉式和饿汉式。注意：</p><ul><li><p>构造器必须私有化</p></li><li><p>对外必须获得一个公有的访问方式来获得实例。</p></li></ul></li></ul><h2 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="2 优缺点"></a>2 优缺点</h2><p>优点：</p><ul><li>在内存中只有一个实例，减少了内存开销</li><li>可以避免对资源的多重占用，不会出现对同一个文件同时进行写操作</li><li>设置全局访问点，严格控制访问</li></ul><p>缺点：</p><ul><li>没有接口，扩展困难</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h1><h2 id="2-1-懒汉式"><a href="#2-1-懒汉式" class="headerlink" title="2.1  懒汉式"></a>2.1  懒汉式</h2><p>当程序第一次访问单例模式实例时才进行创建（延迟加载）。</p><h3 id="1-单线程实现"><a href="#1-单线程实现" class="headerlink" title="1  单线程实现"></a>1  单线程实现</h3><p> 缺点：只能在单线程下使用，多线程下会产生多个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LazySingleton singleton;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> LazySingleton();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-加锁多线程"><a href="#2-加锁多线程" class="headerlink" title="2  加锁多线程"></a>2  加锁多线程</h3><p>缺点：加锁进行同步，虽然可以保证单例，但效率太低，浪费大量时间。每一个线程进来调用getInstance()，都需要去获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton2 singleton;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton2 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> Singleton2();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-双重检查机制"><a href="#3-双重检查机制" class="headerlink" title="3  双重检查机制"></a>3  双重检查机制</h3><p>优点：保证单例的同时，也提高了效率。（每一个线程进来调用getInstance()，只有对象不为空，才需要去获取锁）</p><p>缺点：会被序列化和反射破坏单例（序列化可处理，反射不可处理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyDoubleCheckSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazyDoubleCheckSingleton lazyDoubleCheckSingleton = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazyDoubleCheckSingleton</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazyDoubleCheckSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(lazyDoubleCheckSingleton == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (LazyDoubleCheckSingleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(lazyDoubleCheckSingleton == <span class="hljs-keyword">null</span>)&#123;<br>                    lazyDoubleCheckSingleton = <span class="hljs-keyword">new</span> LazyDoubleCheckSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lazyDoubleCheckSingleton;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：singleton前面要加volatile关键字来保证程序运行的有序性，否则多线程访问下可能会出现对象未初始化错误！</p><blockquote><p>说明：在内存中，创建一个变量需要三步：1.申请一块内存 ；2.调用构造方法初始化 ；3 分配一个指针指向这块内存</p></blockquote><p>在编译原理中，有一个重要的内容叫做编译器优化，即在不改变原来语义的情况下，调整语句的执行顺序，来让程序运行的更快。因此存在这样一种情况，有两个线程A、B同时访问getInstance方法</p><ol><li><p>A线程判断对象为空，没来得及进行第二次判断，（时间片用完了，B线程进入）</p></li><li><p>B线程判断对象为空，执行创建变量的3步，先申请一块内存，后分配一个指针指向这块内存，但还没有进行初始化（时间片用完了，A线程进入）</p></li><li><p>A线程接着执行，发现此时singleton已经不为空了，所以直接返回，但此时返回的singleton对象虽然B线程已经new了，但还没有初始化这个实例并没有构造完成，此时如果A线程使用这个实例，程序就会出现对象未初始化错误了。</p></li></ol><h2 id="2-2-饿汉式"><a href="#2-2-饿汉式" class="headerlink" title="2.2 饿汉式"></a>2.2 饿汉式</h2><p>顾名思义，饿汉法就是在第一次引用该类的时候就创建对象实例，而不管实际是否需要创建。</p><p>优点：写法简单，在类加载的时候就完成实例化，避免线程同步。</p><h3 id="1-简单写法"><a href="#1-简单写法" class="headerlink" title="1 简单写法"></a>1 简单写法</h3><p>缺点：没有达到懒加载的效果，若果自始至终都没有用过这个对象，就会造成内存浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HungrySingleton</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> HungrySingleton hungrySingleton= <span class="hljs-keyword">new</span> HungrySingleton();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HungrySingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> hungrySingleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2  静态内部类"></a>2  静态内部类</h3><p>这里采用了静态内部类实例singleton对象，静态内部类相当于一个静态属性，只有在第一次加载类时才会初始化，在类初始化时，别的线程是无法进入的，因此保证了线程安全。</p><p>缺点：会被序列化和反射破坏单例（序列化可处理，反射不可处理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClassSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StaticInnerClassSingleton staticInnerClassSingleton = <span class="hljs-keyword">new</span> StaticInnerClassSingleton();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StaticInnerClassSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClass.staticInnerClassSingleton;<br>    &#125;<br>  <br>  <span class="hljs-comment">// 避免反射攻击</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">StaticInnerClassSingleton</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(InnerClass.staticInnerClassSingleton != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;单例构造器禁止反射调用&quot;</span>);<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">// 避免序列化破坏单例</span><br>      <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClass.staticInnerClassSingleton;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-枚举单例（推荐）"><a href="#3-枚举单例（推荐）" class="headerlink" title="3 枚举单例（推荐）"></a>3 枚举单例（推荐）</h3><p>对于这种方式的单例，不受反射和序列化的攻击，是最推荐的一种写法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wiki">单元素的枚举类型已经成为实现Singleton的最佳方法               -- 出自 《effective java》<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnumInstance</span> </span>&#123;<br>    INSTANCE;<br>    <span class="hljs-keyword">private</span> Object data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(Object data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EnumInstance <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试序列化和反序列化。可以看出枚举不受序列化影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEnum</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EnumInstance instance = EnumInstance.getInstance();<br>        instance.setData(<span class="hljs-keyword">new</span> Object());<br><br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;singleton_file&quot;</span>));<br>        oos.writeObject(instance);<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;singleton_file&quot;</span>);<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));<br>        EnumInstance newInstance = (EnumInstance) ois.readObject();<br><br>        System.out.println(instance.getData());<br>        System.out.println(newInstance.getData());<br>        System.out.println(instance.getData() == newInstance.getData());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231003161934648.png" alt="image-20231003161934648"></p><p>测试反射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEnumReflect</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EnumInstance instance = EnumInstance.getInstance();<br>        instance.setData(<span class="hljs-keyword">new</span> Object());<br><br>        <span class="hljs-comment">// enum没有无参构造器</span><br>        Constructor&lt;EnumInstance&gt; constructor = EnumInstance.class.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class);<br>        constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>        EnumInstance newInstance = constructor.newInstance(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">111</span>);<br><br>        System.out.println(instance.getData());<br>        System.out.println(newInstance.getData());<br>        System.out.println(instance.getData() == newInstance.getData());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231003163510478.png" alt="image-20231003163510478"></p><p>可以看到，报错 Cannot reflectively create enum objects，无法通过反射创建枚举对象</p><h1 id="3-序列化和反射破坏单例"><a href="#3-序列化和反射破坏单例" class="headerlink" title="3. 序列化和反射破坏单例"></a>3. 序列化和反射破坏单例</h1><h2 id="3-1-序列化破坏单例"><a href="#3-1-序列化破坏单例" class="headerlink" title="3.1 序列化破坏单例"></a>3.1 序列化破坏单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HungrySingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> HungrySingleton hungrySingleton= <span class="hljs-keyword">new</span> HungrySingleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> hungrySingleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        HungrySingleton instance = HungrySingleton.getInstance();<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;singleton_file&quot;</span>));<br>        oos.writeObject(instance);<br><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;singleton_file&quot;</span>);<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));<br>        HungrySingleton newInstance = (HungrySingleton) ois.readObject();<br><br>        System.out.println(instance);<br>        System.out.println(newInstance);<br>        System.out.println(instance == newInstance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231003124316573.png" alt="image-20231003124316573"></p><p>解决方式：</p><p>HungrySingleton 增加readResolve()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> hungrySingleton;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-反射破坏单例"><a href="#3-2-反射破坏单例" class="headerlink" title="3.2 反射破坏单例"></a>3.2 反射破坏单例</h2><p>只可避免反射破坏饿汉式单例，无法避免反射破坏懒汉式单例。</p><h3 id="1-饿汉式单例"><a href="#1-饿汉式单例" class="headerlink" title="1. 饿汉式单例"></a>1. 饿汉式单例</h3><p>对于饿汉式，即在类初始化时创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestReflect</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        HungrySingleton instance = HungrySingleton.getInstance();<br><br>        Constructor&lt;HungrySingleton&gt; constructor = HungrySingleton.class.getDeclaredConstructor();<br>        constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>        HungrySingleton newInstance = constructor.newInstance();<br><br>        System.out.println(instance);<br>        System.out.println(newInstance);<br>        System.out.println(instance == newInstance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231003145832779.png" alt="image-20231003145832779"></p><p>由上可看出，通过反射创建了两个不同的实例。可做如下调整：</p><p>当使用无参构造器构建对象时，由于对象已经在类加载时创建，则不允许再创建新对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HungrySingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>,<span class="hljs-title">Cloneable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> HungrySingleton hungrySingleton;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        hungrySingleton = <span class="hljs-keyword">new</span> HungrySingleton();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HungrySingleton</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(hungrySingleton != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;单例构造器禁止反射调用&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> hungrySingleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-懒汉式单例"><a href="#2-懒汉式单例" class="headerlink" title="2. 懒汉式单例"></a>2. 懒汉式单例</h3><p>即使在私有构造器中，增加了禁止反射调用的逻辑，也无法确保单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LazySingleton lazySingleton = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(lazySingleton != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;单例构造器禁止反射调用&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(lazySingleton == <span class="hljs-keyword">null</span>)&#123;<br>            lazySingleton = <span class="hljs-keyword">new</span> LazySingleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> lazySingleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当先通过反射创建对象，再通过方法调用创建对象的场景，就会产生两个不同的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestReflect2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Constructor&lt;LazySingleton&gt; constructor = LazySingleton.class.getDeclaredConstructor();<br>        constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>        LazySingleton newInstance = constructor.newInstance();<br><br>        LazySingleton instance = LazySingleton.getInstance();<br><br>        System.out.println(instance);<br>        System.out.println(newInstance);<br>        System.out.println(instance == newInstance);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231003172322321.png" alt="image-20231003172322321"></p><p>当先通过方法调用创建对象的场景，再通过反射创建对象，则会根据逻辑阻止第二个对象的产生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestReflect2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        LazySingleton instance = LazySingleton.getInstance();<br><br>        Constructor&lt;LazySingleton&gt; constructor = LazySingleton.class.getDeclaredConstructor();<br>        constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>        LazySingleton newInstance = constructor.newInstance();<br>        <br>        System.out.println(instance);<br>        System.out.println(newInstance);<br>        System.out.println(instance == newInstance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20231003172354599.png" alt="image-20231003172354599"></p><blockquote><p> 因为二者虽然都会调用无参构造器，但是只有getInstance()方法才会将lazySingleton赋值。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>建造者模式</title>
    <link href="/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><ol><li><p>定义</p><p>将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。</p></li><li><p>使用场景</p><ul><li>当对象有复杂的内部结构（很多属性）</li><li>当创造一个对象 需要很多步骤时 , 适合使用建造者模式 ;  当创造一个对象 只需要一个简单的方法就可以完成 , 适合使用工厂模式</li></ul></li><li><p>优缺点</p><ul><li><p>优点：</p><ul><li>创建和使用分离</li><li>建造类之间 相互独立 , 在 一定程度上解耦 ;</li></ul></li><li><p>缺点 :</p><ul><li><p>增加类数量 : 产生多余的 Builder 对象 ;</p></li><li><p>内部修改困难 : 如果 产品内部发生变化 , 建造者也要相应修改 ;</p></li></ul></li></ul></li><li><p>建造者模式 与 工厂模式 :</p><ul><li><p>注重点不同 : 建造者模式 更注重于 方法的调用顺序 ; 工厂模式 注重于 创建产品 , 不关心方法调用的顺序 ;</p></li><li><p>创建对象力度不同 : 创建对象的力度不同 , 建造者模式可以创建复杂的产品 , 由各种复杂的部件组成 , 工厂模式创建出来的都是相同的实例对象 ,</p></li></ul></li></ol><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h1><p>教师创建课程</p><h2 id="2-1-版本1"><a href="#2-1-版本1" class="headerlink" title="2.1 版本1"></a>2.1 版本1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coach</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> CourseBuilder courseBuilder;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCourseBuilder</span><span class="hljs-params">(CourseBuilder courseBuilder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.courseBuilder = courseBuilder;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Course <span class="hljs-title">makeCourse</span><span class="hljs-params">(String courseName,String coursePPT,</span></span><br><span class="hljs-params"><span class="hljs-function">                             String courseVideo,String courseArticle,</span></span><br><span class="hljs-params"><span class="hljs-function">                             String courseQA)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.courseBuilder.buildCourseName(courseName);<br>        <span class="hljs-keyword">this</span>.courseBuilder.buildCoursePPT(coursePPT);<br>        <span class="hljs-keyword">this</span>.courseBuilder.buildCourseVideo(courseVideo);<br>        <span class="hljs-keyword">this</span>.courseBuilder.buildCourseArticle(courseArticle);<br>        <span class="hljs-keyword">this</span>.courseBuilder.buildCourseQA(courseQA);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.courseBuilder.makeCourse();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseBuilder</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCourseName</span><span class="hljs-params">(String courseName)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCoursePPT</span><span class="hljs-params">(String coursePPT)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCourseVideo</span><span class="hljs-params">(String courseVideo)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCourseArticle</span><span class="hljs-params">(String courseArticle)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCourseQA</span><span class="hljs-params">(String courseQA)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Course <span class="hljs-title">makeCourse</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseActualBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CourseBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Course course = <span class="hljs-keyword">new</span> Course();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCourseName</span><span class="hljs-params">(String courseName)</span> </span>&#123;<br>        course.setCourseName(courseName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCoursePPT</span><span class="hljs-params">(String coursePPT)</span> </span>&#123;<br>        course.setCoursePPT(coursePPT);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCourseVideo</span><span class="hljs-params">(String courseVideo)</span> </span>&#123;<br>        course.setCourseVideo(courseVideo);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCourseArticle</span><span class="hljs-params">(String courseArticle)</span> </span>&#123;<br>        course.setCourseArticle(courseArticle);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCourseQA</span><span class="hljs-params">(String courseQA)</span> </span>&#123;<br>        course.setCourseQA(courseQA);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Course <span class="hljs-title">makeCourse</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> course;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String courseName;<br>    <span class="hljs-keyword">private</span> String coursePPT;<br>    <span class="hljs-keyword">private</span> String courseVideo;<br>    <span class="hljs-keyword">private</span> String courseArticle;<br><br>    <span class="hljs-comment">//question &amp; answer</span><br>    <span class="hljs-keyword">private</span> String courseQA;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CourseBuilder courseBuilder = <span class="hljs-keyword">new</span> CourseActualBuilder();<br>        Coach coach = <span class="hljs-keyword">new</span> Coach();<br>        coach.setCourseBuilder(courseBuilder);<br><br>        Course course = coach.makeCourse(<span class="hljs-string">&quot;Java设计模式精讲&quot;</span>,<br>                <span class="hljs-string">&quot;Java设计模式精讲PPT&quot;</span>,<br>                <span class="hljs-string">&quot;Java设计模式精讲视频&quot;</span>,<br>                <span class="hljs-string">&quot;Java设计模式精讲手记&quot;</span>,<br>                <span class="hljs-string">&quot;Java设计模式精讲问答&quot;</span>);<br>        System.out.println(course);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-版本2"><a href="#2-2-版本2" class="headerlink" title="2.2 版本2"></a>2.2 版本2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String courseName;<br>    <span class="hljs-keyword">private</span> String coursePPT;<br>    <span class="hljs-keyword">private</span> String courseVideo;<br>    <span class="hljs-keyword">private</span> String courseArticle;<br><br>    <span class="hljs-comment">//question &amp; answer</span><br>    <span class="hljs-keyword">private</span> String courseQA;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Course</span><span class="hljs-params">(CourseBuilder courseBuilder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.courseName = courseBuilder.courseName;<br>        <span class="hljs-keyword">this</span>.coursePPT = courseBuilder.coursePPT;<br>        <span class="hljs-keyword">this</span>.courseVideo = courseBuilder.courseVideo;<br>        <span class="hljs-keyword">this</span>.courseArticle = courseBuilder.courseArticle;<br>        <span class="hljs-keyword">this</span>.courseQA = courseBuilder.courseQA;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseBuilder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String courseName;<br>        <span class="hljs-keyword">private</span> String coursePPT;<br>        <span class="hljs-keyword">private</span> String courseVideo;<br>        <span class="hljs-keyword">private</span> String courseArticle;<br><br>        <span class="hljs-comment">//question &amp; answer</span><br>        <span class="hljs-keyword">private</span> String courseQA;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> CourseBuilder <span class="hljs-title">buildCourseName</span><span class="hljs-params">(String courseName)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.courseName = courseName;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> CourseBuilder <span class="hljs-title">buildCoursePPT</span><span class="hljs-params">(String coursePPT)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.coursePPT = coursePPT;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> CourseBuilder <span class="hljs-title">buildCourseVideo</span><span class="hljs-params">(String courseVideo)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.courseVideo = courseVideo;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> CourseBuilder <span class="hljs-title">buildCourseArticle</span><span class="hljs-params">(String courseArticle)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.courseArticle = courseArticle;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> CourseBuilder <span class="hljs-title">buildCourseQA</span><span class="hljs-params">(String courseQA)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.courseQA = courseQA;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Course <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Course(<span class="hljs-keyword">this</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Course course = <span class="hljs-keyword">new</span> Course.CourseBuilder()<br>                .buildCourseName(<span class="hljs-string">&quot;Java设计模式精讲&quot;</span>)<br>                .buildCoursePPT(<span class="hljs-string">&quot;Java设计模式精讲PPT&quot;</span>)<br>                .buildCourseVideo(<span class="hljs-string">&quot;Java设计模式精讲视频&quot;</span>)<br>                .build();<br>        System.out.println(course);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-Java的应用"><a href="#3-Java的应用" class="headerlink" title="3. Java的应用"></a>3. Java的应用</h1><ol><li>JDK 中StringBuilder, stringBuffer的append()</li></ol><ul><li><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230926215714433.png" alt="image-20230926215714433"><u></u></li></ul><ol start="2"><li><p>spring中BeanDefinitionBuilder</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230926221325746.png" alt="image-20230926221325746"></p></li><li><p>Mybatis 中MybatisSqlSessionFactoryBuilder</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230926221450251.png" alt="image-20230926221450251"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简单工厂模式</title>
    <link href="/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><ul><li>定义：由一个工厂对象决定创建出哪一种对象的实例</li><li>优缺点：<ul><li>优点：只需要传入一个参数，就可以获取你所需要的对象，而无需知道细节</li><li>缺点：工厂的职责过重，增加新的产品，需要修改工厂的判断逻辑，违反开闭原则</li></ul></li></ul><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h1><p>需求： 需要根据电影类型创建电影</p><h2 id="2-1-版本1：常规写法"><a href="#2-1-版本1：常规写法" class="headerlink" title="2.1 版本1：常规写法"></a>2.1 版本1：常规写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaVideo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Video</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;录制Java课程视频&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PythonVideo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Video</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;录制Python课程视频&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        PythonVideo pythonVideo = <span class="hljs-keyword">new</span> PythonVideo();<br>        pythonVideo.produce();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-版本2：-使用简单工厂模式改造"><a href="#2-2-版本2：-使用简单工厂模式改造" class="headerlink" title="2.2 版本2： 使用简单工厂模式改造"></a>2.2 版本2： 使用简单工厂模式改造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Video <span class="hljs-title">getVideo</span><span class="hljs-params">(String type)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;java&quot;</span>.equalsIgnoreCase(type))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JavaVideo();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;python&quot;</span>.equalsIgnoreCase(type))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PythonVideo();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        VideoFactory videoFactory = <span class="hljs-keyword">new</span> VideoFactory();<br>        Video video = videoFactory.getVideo(<span class="hljs-string">&quot;python&quot;</span>);<br>        <span class="hljs-keyword">if</span>(video == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        video.produce();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-版本3-基于反射改造，避免工厂里逻辑太复杂"><a href="#2-3-版本3-基于反射改造，避免工厂里逻辑太复杂" class="headerlink" title="2.3 版本3:  基于反射改造，避免工厂里逻辑太复杂"></a>2.3 版本3:  基于反射改造，避免工厂里逻辑太复杂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Video <span class="hljs-title">getVideo</span><span class="hljs-params">(Class c)</span></span>&#123;<br>        Video video = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            video = (Video) Class.forName(c.getName()).newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> video;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        VideoFactory videoFactory = <span class="hljs-keyword">new</span> VideoFactory();<br>        Video video = videoFactory.getVideo(JavaVideo.class);<br>        <span class="hljs-keyword">if</span>(video == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        video.produce();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="3-JDK的应用"><a href="#3-JDK的应用" class="headerlink" title="3 JDK的应用"></a>3 JDK的应用</h1><p>JDK1.8的应用：java.util.Calendar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Calendar <span class="hljs-title">createCalendar</span><span class="hljs-params">(TimeZone zone,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           Locale aLocale)</span></span><br><span class="hljs-function">    </span>&#123;<br>        CalendarProvider provider =<br>            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)<br>                                 .getCalendarProvider();<br>        <span class="hljs-keyword">if</span> (provider != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> provider.getInstance(zone, aLocale);<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException iae) &#123;<br>                <span class="hljs-comment">// fall back to the default instantiation</span><br>            &#125;<br>        &#125;<br><br>        Calendar cal = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">if</span> (aLocale.hasExtensions()) &#123;<br>            String caltype = aLocale.getUnicodeLocaleType(<span class="hljs-string">&quot;ca&quot;</span>);<br>            <span class="hljs-keyword">if</span> (caltype != <span class="hljs-keyword">null</span>) &#123;<br>                cal = <span class="hljs-keyword">switch</span> (caltype) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;buddhist&quot;</span> -&gt; <span class="hljs-keyword">new</span> BuddhistCalendar(zone, aLocale);<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;japanese&quot;</span> -&gt; <span class="hljs-keyword">new</span> JapaneseImperialCalendar(zone, aLocale);<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gregory&quot;</span>  -&gt; <span class="hljs-keyword">new</span> GregorianCalendar(zone, aLocale);<br>                    <span class="hljs-keyword">default</span>         -&gt; <span class="hljs-keyword">null</span>;<br>                &#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cal == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// If no known calendar type is explicitly specified,</span><br>            <span class="hljs-comment">// perform the traditional way to create a Calendar:</span><br>            <span class="hljs-comment">// create a BuddhistCalendar for th_TH locale,</span><br>            <span class="hljs-comment">// a JapaneseImperialCalendar for ja_JP_JP locale, or</span><br>            <span class="hljs-comment">// a GregorianCalendar for any other locales.</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The language, country and variant strings are interned.</span><br>            <span class="hljs-keyword">if</span> (aLocale.getLanguage() == <span class="hljs-string">&quot;th&quot;</span> &amp;&amp; aLocale.getCountry() == <span class="hljs-string">&quot;TH&quot;</span>) &#123;<br>                cal = <span class="hljs-keyword">new</span> BuddhistCalendar(zone, aLocale);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aLocale.getVariant() == <span class="hljs-string">&quot;JP&quot;</span> &amp;&amp; aLocale.getLanguage() == <span class="hljs-string">&quot;ja&quot;</span><br>                       &amp;&amp; aLocale.getCountry() == <span class="hljs-string">&quot;JP&quot;</span>) &#123;<br>                cal = <span class="hljs-keyword">new</span> JapaneseImperialCalendar(zone, aLocale);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cal = <span class="hljs-keyword">new</span> GregorianCalendar(zone, aLocale);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cal;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股文</title>
    <link href="/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="1-集合"><a href="#1-集合" class="headerlink" title="1. 集合"></a>1. 集合</h1><ol><li><a href="https://pyr9.github.io/%E9%9B%86%E5%90%88/#1-ArrayList">ArrayList底层实现原理以及如何避免并发</a></li><li><a href="https://pyr9.github.io/%E9%9B%86%E5%90%88/#2-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DhashMap%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F">HashMap如何避免并发&amp;ConcurrentHashMap实现</a></li><li></li></ol><h1 id="2-并发"><a href="#2-并发" class="headerlink" title="2. 并发"></a>2. 并发</h1><h1 id="3-JVM"><a href="#3-JVM" class="headerlink" title="3. JVM"></a>3. JVM</h1><h1 id="4-Redis"><a href="#4-Redis" class="headerlink" title="4. Redis"></a>4. Redis</h1><h1 id="5-Mysql"><a href="#5-Mysql" class="headerlink" title="5. Mysql"></a>5. Mysql</h1><h1 id="6-消息中间件"><a href="#6-消息中间件" class="headerlink" title="6. 消息中间件"></a>6. 消息中间件</h1><h1 id="7-持久层框架"><a href="#7-持久层框架" class="headerlink" title="7. 持久层框架"></a>7. 持久层框架</h1><h1 id="8-XXL-JOb"><a href="#8-XXL-JOb" class="headerlink" title="8. XXL JOb"></a>8. XXL JOb</h1><h1 id="9-ClickHouse"><a href="#9-ClickHouse" class="headerlink" title="9. ClickHouse"></a>9. ClickHouse</h1><h1 id="10-spring"><a href="#10-spring" class="headerlink" title="10. spring"></a>10. spring</h1><h1 id="11-springCloud"><a href="#11-springCloud" class="headerlink" title="11. springCloud"></a>11. springCloud</h1><h1 id="12-设计模式"><a href="#12-设计模式" class="headerlink" title="12 设计模式"></a>12 设计模式</h1><h1 id="13-网络"><a href="#13-网络" class="headerlink" title="13. 网络"></a>13. 网络</h1><ol><li><p><a href="https://pyr9.github.io/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/">三次握手</a></p></li><li><p><a href="https://pyr9.github.io/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">四次挥手</a></p></li><li><p><a href="https://pyr9.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/#1-get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB">get和post的区别</a></p></li><li><p><a href="https://pyr9.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/#2-http%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">http的常用方法</a></p></li><li><p><a href="https://pyr9.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/#3-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB">TCP和UDP的区别与联系</a></p></li><li><p><a href="https://pyr9.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/#4-HTTP%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5">HTTP的长连接和短连接</a></p></li><li><p><a href="HTTP%E5%92%8CHTTPs%E7%9A%84%E5%8C%BA%E5%88%AB">HTTP和HTTPs的区别</a></p></li><li><p><a href="https://pyr9.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/#6-%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F">加密方式</a></p></li><li><p><a href="https://pyr9.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/#7-cookie-%E5%92%8Csession-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB">cookie 和session 的区别和联系</a></p></li></ol><h1 id="14-工作流"><a href="#14-工作流" class="headerlink" title="14. 工作流"></a>14. 工作流</h1><h1 id="15-Docker"><a href="#15-Docker" class="headerlink" title="15 Docker"></a>15 Docker</h1><h1 id="16-项目"><a href="#16-项目" class="headerlink" title="16 项目"></a>16 项目</h1>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java锁常见面试题</title>
    <link href="/java%E9%94%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/java%E9%94%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-sychronized"><a href="#1-sychronized" class="headerlink" title="1. sychronized"></a>1. sychronized</h1><p>Synchronized是Java中解决并发问题的一种最常用的方法，Synchronized的作用主要有三个：</p><ul><li><strong>确保互斥访问</strong>。确保被同步的方法或代码块在同一时刻只能由一个线程执行，其他线程必须等待该线程执行完毕后才能进入。</li><li><strong>保证可见性</strong>。保证线程间对共享变量的修改是可见的。具体来说，当一个线程修改了共享变量的值后，<code>synchronized</code> 关键字确保其他线程能够立即看到这个修改。</li><li><strong>防止指令重排序</strong>。指令重排序是一种优化技术，编译器和处理器可能会重新排列指令的执行顺序，以提高性能。但是在多线程环境下，指令重排序可能会导致线程间的执行顺序和预期的不一致。<code>synchronized</code> 通过内存屏障（Memory Barrier）机制，确保在进入和退出同步块时，内存的读写操作不会被重排序。</li></ul><h2 id="1-应用方式"><a href="#1-应用方式" class="headerlink" title="1. 应用方式"></a>1. 应用方式</h2><p>synchronized关键字最主要有以下3种应用方式，下面分别介绍</p><p>1.修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</p><p>2.修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</p><p>3.修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p><h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h2><p>基于对象锁（monitor）机制。编译用sychronized修饰的同步代码块，再用javap -v查看字节码文件：执行同步代码块后首先要先执行monitorenter指令，退出的时候monitorexit指令。使用Synchronized进行同步，其关键就是必须要对对象的监视器monitor进行获取，当线程获取monitor后才能继续往下执行，否则就只能等待。而这个获取的过程是互斥的，即同一时刻只有一个线程能够获取到monitor。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。</p><h2 id="2-Lock和synchronized区别"><a href="#2-Lock和synchronized区别" class="headerlink" title="2. Lock和synchronized区别"></a>2. Lock和synchronized区别</h2><ol><li><p>Lock是一个接口，而synchronized是Java中的关键字,synchronized是内置的语言实现， lock是通过代码实现的.</p></li><li><p>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p></li><li><p>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p></li><li><p>Lock可以提高多个线程进行读操作的效率。</p></li><li><p>Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p><p><strong>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</strong></p></li></ol><h1 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2. AQS"></a>2. AQS</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>AQS，全称为 <strong>AbstractQueuedSynchronizer</strong>，是 Java 中提供的一种实现同步器的框架。它是 <code>java.util.concurrent.locks</code> 包的一部分。其核心是维护一个同步状态 <code>state</code> 以及一个 FIFO 等待队列。它提供了多种方法来操纵同步状态，并管理进入等待队列的线程。</p><h4 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h4><p>同步状态是一个 <code>int</code> 类型的变量，通常用于表示资源的可用性。例如，在一个独占锁中，<code>state</code> 为 0 表示锁是可用的，1 表示锁已被持有。</p><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>当一个线程尝试获取锁但失败时，它会被加入到 AQS 的等待队列中。这个等待队列是一个双向链表，所有尝试获取锁的线程都排成队列，等待被唤醒并再次尝试获取锁。</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>AQS 通常不会直接使用，而是通过子类实现具体的同步器，如 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code> 等。</p><h1 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3.  ReentrantLock"></a>3.  ReentrantLock</h1><h2 id="1-公平锁的加锁实现："><a href="#1-公平锁的加锁实现：" class="headerlink" title="1. 公平锁的加锁实现："></a>1. 公平锁的加锁实现：</h2><p>公平锁保证线程按照请求锁的顺序来获取锁.</p><p>1.加锁时会调用lock()方法去获取锁，lock()会调用用acquire()(AQS中)，而这个acquire方法内部又去调用了tryAcquire的方法</p><ol><li><p>tryAcquire方法通过getState获取当前同步状态</p><ul><li><p>发现state为0。</p><ol><li><strong>判断是否有比当前线程等待时间更长的线程</strong>。如果有，当前线程将等待。</li><li>没有的话，使用原子操作尝试将锁的状态从 0 改为 1，表示获取锁成功，设置锁的拥有者为当前线程， 获取成功，</li></ol></li><li><p>不为0，检查当前线程是否已经持有锁，判断重入锁的逻辑。</p><ol><li>是重入锁的话，增加重入次数， 也是获取成功，</li></ol></li></ul></li><li><p>获取失败时，调用 <code>addWaiter</code> 将当前线程加入等待队列。尝试通过CAS把当前现在追加到队尾，修改为节点为最新的节点，如果修改失败，意味着有并发，这个时候进入enq中的死循环，进行“自旋”的方式修改</p></li></ol><h2 id="2-公平锁的释放锁实现："><a href="#2-公平锁的释放锁实现：" class="headerlink" title="2. 公平锁的释放锁实现："></a>2. 公平锁的释放锁实现：</h2><ol><li><p>头节点在释放同步状态的时候，会调用unlock（），而unlock会调用release()，release()会调用tryRelease方法尝试释放当前线程持有的锁,先判断当前线程是否为持有锁的线程，如果是，则执行减减操作，否则抛出异常（同步状态）</p></li><li><p>成功的话调用unparkSuccessor() 唤醒后继线程，并返回true，否则直接返回false，</p><p>注意：</p><ul><li>只有线程A把此锁全部释放了，状态值减到0了，其他线程才有机会获取锁，当A把锁完全释放后，state恢复为0</li><li>队列中的节点在被唤醒之前都处于阻塞状态。当一个线程节点被唤醒然后取得了锁，对应节点会从队列中删除</li></ul></li></ol><h2 id="3-非公平锁的加锁实现："><a href="#3-非公平锁的加锁实现：" class="headerlink" title="3. 非公平锁的加锁实现："></a>3. 非公平锁的加锁实现：</h2><ul><li>非公平锁在尝试获取锁时，是先直接 CAS 设置 state 变量，如果设置成功，表明加锁成功，当前线程就成为了锁的持有者。</li><li>抢占失败,再调用 acquire 方法将线程置于队列尾部排队。</li></ul><blockquote><p>非公平锁的机制：如果新来了一个线程，试图访问一个同步资源，只需要确认当前没有其他线程持有这个同步状态，即可获取到。</p></blockquote><p>这个区别很重要，因为线程在阻塞和非阻塞之间切换时需要比较长的时间，如果刚好线程A释放了资源，A会去唤醒下一个排着队的Node节点，当这个唤醒操作还没完成的时候，这时又来了一个线程B，线程B发现当前没人持有这个资源，于是自己就迅速拿到了这个资源，充分利用了线程A去唤醒B的这一段时间，这就是公平锁和非公平锁之间的差异，这里也体现了非公平锁性能较高的地方。</p><h1 id="4-ReentrantReadWriteLock"><a href="#4-ReentrantReadWriteLock" class="headerlink" title="4. ReentrantReadWriteLock"></a>4. ReentrantReadWriteLock</h1><p>ReentrantReadWriteLock是 Lock 的另一种实现方式，我们已经知道了 ReentrantLock 是一个排他锁，同一时间只允许一个线程访问，而 ReentrantReadWriteLock 允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="5-CountDownLatch-amp-CyclicBarrier"><a href="#5-CountDownLatch-amp-CyclicBarrier" class="headerlink" title="5. CountDownLatch &amp; CyclicBarrier"></a>5. CountDownLatch &amp; CyclicBarrier</h1><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h2><p>CountDownLatch是一个计数器闭锁，通过它可以完成类似于阻塞当前线程的功能，即：一个线程或多个线程一直等待，直到其他线程执行的操作完成。</p><p>CountDownLatch用一个给定的计数器来初始化，该计数器的操作是原子操作，即同时只能有一个线程去操作该计数器。调用该类await方法的线程会一直处于阻塞状态，直到其他线程调用countDown方法使当前计数器的值变为零，每次调用countDown计数器的值减1。当计数器值减至零时，所有因调用await()方法而处于等待状态的线程就会继续往下执行。这种现象只会出现一次，因为计数器不能被重置，如果业务上需要一个可以重置计数次数的版本，可以考虑使用CycliBarrier。</p><h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2 CyclicBarrier"></a>2 CyclicBarrier</h2><p>CyclicBarrier也是一个同步辅助类，它允许一组线程相互等待，直到到达某个公共屏障点（common barrier point）。</p><p>通过它可以完成多个线程之间相互等待，只有当每个线程都准备就绪后，才能各自继续往下执行后面的操作。类似于CountDownLatch，它也是通过计数器来实现的。当某个线程调用await方法时，该线程进入等待状态，且计数器加1，当计数器的值达到设置的初始值时，所有因调用await进入等待状态的线程被唤醒，继续执行后续操作。因为CycliBarrier在释放等待线程后可以重用，所以称为循环barrier。CycliBarrier支持一个可选的Runnable，在计数器的值到达设定值后（但在释放所有线程之前），该Runnable运行一次，注，Runnable在每个屏障点只运行一个。</p><h2 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h2><p>CountDownLatch主要是实现了1个或N个线程需要等待其他线程完成某项操作之后才能继续往下执行操作，描述的是1个线程或N个线程等待其他线程的关系。CyclicBarrier主要是实现了多个线程之间相互等待，直到所有的线程都满足了条件之后各自才能继续执行后续的操作，描述的多个线程内部相互等待的关系。<br>CountDownLatch是一次性的，而CyclicBarrier则可以被重置而重复使用。</p><h1 id="6-CAS"><a href="#6-CAS" class="headerlink" title="6 CAS"></a>6 CAS</h1><p>CAS（Compare and Swap）有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><p>java.util.concurrent(J.U.C)种提供的atomic包中的类，使用的是乐观锁，用到的机制就是CAS，当多个线程尝试使用CAS同时更新一个变量时，只有其中一个线程可能更新变量的值，而其他线程都失败，失败的线程不会被挂起，而是被告知这次竞争失败，并可以再次尝试。</p><h2 id="1-AtomicInteger"><a href="#1-AtomicInteger" class="headerlink" title="1. AtomicInteger"></a>1. AtomicInteger</h2><p>以AtomicInteger为例，研究在没有锁的情况下是如何做到数据正确性的。<br>例如 AtomicInteger 中有一个原子方式 i++ 操作，即</p><ol><li>调用incrementAndGet(),而incrementAndGet() 调用 unsafe下的方法getAndAddInt()</li><li>getAndAddInt()中有一个 valueOffset 参数，这个值是 value 值在 AtomicInteger 类型中内存的偏移地址。传入的 valueOffset 参数会在后续方法中，直接从内存位置读取这个字段的值。</li><li>得到最新值后，调用 compareAndSwapInt 来更新最新值，如果对象 o 中 offset 偏移位置的值等于期望值(expected)，就将该 offset 处的值更新为 x，当更新成功时，返回 true。结合前面调用来看，如果当前值是 v，就设置为 v+1。否则重试直到成功为止。</li></ol><h2 id="2-CAS问题"><a href="#2-CAS问题" class="headerlink" title="2. CAS问题"></a>2. CAS问题</h2><ol><li><p><strong>ABA问题</strong>。<br>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。<br>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。<br>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></li><li><p><strong>循环时间长开销大。</strong><br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p></li><li><p><strong>只能保证一个共享变量的原子操作。</strong><br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j&#x3D;a，合并一下ij&#x3D;2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p></li></ol><h1 id="7-ThreadLocal"><a href="#7-ThreadLocal" class="headerlink" title="7 ThreadLocal"></a>7 ThreadLocal</h1><p>ThreadLocal 提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程</p><p><strong>早期设计：</strong></p><p>每个 ThreadLocal类都创建一个 Map，然后用线程的 ID threadID 作为 Map 的 key，要存储的局部变量作为 Map 的 value，这样就能达到各个线程的值隔离的效果。</p><p> <strong>JDK8 ThreadLocal 的设计：</strong></p><p>每个 Thread 维护一个 ThreadLocalMap 哈希表，这个哈希表的 key 是 ThreadLocal 实例本身，value才是真正要存储的值 Object。</p><p><strong>这样设计有如下几点优势：</strong><br>1） 这样设计之后每个 Map 存储的 Entry 数量就会变小，因为之前的存储数量由Thread 的数量决定，现在是由 ThreadLocal 的数量决定。<br>2） 当 Thread 销毁之后，对应的 ThreadLocalMap 也会随之销毁，生命周期与线程相同，能减少内存的使用。<br>注：ThreadLocalMap其实是线程自身的一个成员属性threadLocals的类型。也就是线程本地数据都存在这个threadLocals应用的ThreadLocalMap中。</p><h2 id="1-底层实现"><a href="#1-底层实现" class="headerlink" title="1. 底层实现"></a>1. 底层实现</h2><h2 id="1-set-Tvalue"><a href="#1-set-Tvalue" class="headerlink" title="1. set(Tvalue)"></a>1. set(Tvalue)</h2><p>1 ) 获取当前线程 Thread 对象，进而获取此线程对象中维护的 ThreadLocalMap 对象。<br>2 ) 判断当前的 ThreadLocalMap 是否存在：<br>如果存在，则调用 map.set 设置此实体 entry。<br>如果不存在，则调用 createMap 进行 ThreadLocalMap 对象的初始化，并将此实体 entry 作为第一个值存放至 ThreadLocalMap 中。</p><h2 id="2-get"><a href="#2-get" class="headerlink" title="2. get()"></a>2. get()</h2><ol><li><p>获取当前线程 Thread 对象，进而获取此线程对象中维护的 ThreadLocalMap 对象。</p></li><li><p>判断当前的 ThreadLocalMap 是否存在：</p><ul><li><p>如果存在，则以当前的 ThreadLocal 为 key，调用 ThreadLocalMap 中的 getEntry 方法获取对应的存储实体 e。找到对应的存储实体 e，获取存储实体 e 对应的 value 值，即为我们想要的当前线程对应此 ThreadLocal 的值，返回结果值。</p></li><li><p>如果不存在，则证明此线程没有维护的 ThreadLocalMap 对象，调用 setInitialValue 方法进行初始化。返回 setInitialValue 初始化的值。</p></li></ul></li><li><p>setInitialValue 方法的操作如下：</p><ol><li>调用 initialValue 获取初始化的值。</li><li>获取当前线程 Thread 对象，进而获取此线程对象中维护的 ThreadLocalMap 对象，并判断当前的 ThreadLocalMap 是否存在：<ul><li>如果存在，则调用 map.set 设置此实体 entry。</li><li>如果不存在，则调用 createMap 进行 ThreadLocalMap 对象的初始化，并将此实体 entry 作为第一个值存放至 ThreadLocalMap 中。</li></ul></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>技术选型</title>
    <link href="/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    <url>/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-技术选型所要考虑的"><a href="#1-技术选型所要考虑的" class="headerlink" title="1. 技术选型所要考虑的"></a>1. 技术选型所要考虑的</h1><ul><li>切合业务：在当前的场景以及后续的一些模块的设计，都可以满足我们的业务</li><li>社区活跃度：活跃多，使用的人多，优点缺点都可以呈现出来，包括会遇到的问题</li><li>团队技术水平：针对开发周期的长短，需要考虑我们是采用老技术还是新技术。如果是新技术，团队没有几个人接触过的话，那么就需要整体的一个培训，来提高团队的技术水平。</li><li>版本更新迭代周期：如果版本更新迭代的比较快，可以优先考虑，因为如果你遇到了什么问题，但是版本停更了，就会对公司的业务多多少少造成一定的影响</li><li>试错精神：平时多接触各类技术，就可以有多种备选方案</li><li>安全性：某些技术曾经有安全问题，安全漏洞的话，要多斟酌再使用</li><li>成功案例：可以多使用一些有成功案例的</li><li>开源精神：如果这个技术会闭源的，需要考虑后期会收费的场景</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>幂等性</title>
    <link href="/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <url>/%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-幂等性是什么？"><a href="#1-幂等性是什么？" class="headerlink" title="1. 幂等性是什么？"></a>1. 幂等性是什么？</h1><p>在一个系统中，一个接口，运行多次和运行一次的结果是一致的。</p><p>什么情况下需要幂等性？</p><p>重复提交、接口重试、前端窗口抖动等</p><p>业务场景：</p><ol><li>用户多次点击提交订单，后台应该只生成一个订单。</li><li>支付时，由于发生网络问题重试，应该只扣一次钱。</li></ol><p>保证幂等性的核心思想：通过唯一的业务单号保证幂等。</p><p>实现：</p><ul><li>非并发的情况下，查询业务单号有没有操作过，没有则执行操作</li><li>并发的情况下，整个过程加锁</li></ul><h1 id="2-具体CRUD操作的幂等性"><a href="#2-具体CRUD操作的幂等性" class="headerlink" title="2 具体CRUD操作的幂等性"></a>2 具体CRUD操作的幂等性</h1><h2 id="1-select操作的幂等性"><a href="#1-select操作的幂等性" class="headerlink" title="1. select操作的幂等性"></a>1. select操作的幂等性</h2><p>查询操作天然幂等。</p><h2 id="2-delete操作的幂等性"><a href="#2-delete操作的幂等性" class="headerlink" title="2 delete操作的幂等性"></a>2 delete操作的幂等性</h2><ul><li>有唯一的业务号，如id。<ul><li>第一次操作：根据唯一业务号删除</li><li>第二次操作：由于找不到记录，所以直接返回。可在删除前进行数据的查询。</li></ul></li><li>没有唯一的业务号，比如将审核未通过的商品删除。<ul><li>第一次操作：将所有审核未通过的商品删除</li><li>第二次操作前：又产生了新的审核未通过的商品。这时候需要根据业务需求去处理，新增的审核未通过的商品是否需要删除。</li></ul></li></ul><h2 id="3-update操作的幂等性"><a href="#3-update操作的幂等性" class="headerlink" title="3 update操作的幂等性"></a>3 update操作的幂等性</h2><p>update操作需要区分场景：</p><ul><li><p>比如是set去更新，那么多次set不会有什么问题</p></li><li><p>如果是在当前基础上自增，那么就需要处理 ，分场景：</p><ul><li><p>有唯一的业务号，如id。更新操作传入数据版本号，通过乐观锁实现。</p><ul><li><p>数据库增加版本version字段，用户在查询并展示当前数据时，将version放入隐藏域。当用户点击提交时，将版本号也一同提交。</p></li><li><p>后台去判断版本号，并且进行版本号+1操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> xxx<span class="hljs-operator">=</span>$&#123;xxx&#125;, version<span class="hljs-operator">=</span>$&#123;version&#125;<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>xxx <span class="hljs-keyword">and</span> version<span class="hljs-operator">=</span>$&#123;version&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>没有唯一的业务号，比如用户登录，注册</p><ul><li>采用token机制</li></ul></li></ul></li></ul><h2 id="4-insert操作的幂等性"><a href="#4-insert操作的幂等性" class="headerlink" title="4 insert操作的幂等性"></a>4 insert操作的幂等性</h2><ul><li><p>有唯一的业务号，如秒杀场景，商品ID+用户ID。</p><ul><li>解决方式：分布式锁业务执行完成后，不让锁释放，而是让其过期后释放。比如设置30s，则30s内只会有一个线程获取到锁，当用户点击多次，触发了其他线程，获取不到锁，直接返回。</li></ul></li><li><p>没有唯一业务单号，使用token保证幂等。</p><ul><li><p>具体流程</p><ul><li><p>当用户进入注册页面时，后端生成一个随机token，客户端将token放在隐藏域下，带着token提交。（分布式场景下，需要类似分布式ID的处理方式，保证token唯一）</p></li><li><p>根据token去获取分布式锁，完成insert后，不让锁释放，而是让其过期后释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(SysUser user, String token)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>  InterProcessMutex lock =  <span class="hljs-keyword">new</span> InterProcessMutex(zkClient, <span class="hljs-string">&quot;/&quot;</span>+token);<br>  val isLock = lock.acquire(<span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>  <span class="hljs-keyword">if</span>(isLock)&#123;<br>    <span class="hljs-keyword">return</span> sysUserMapper.insert(user);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="5-混合操作的幂等性"><a href="#5-混合操作的幂等性" class="headerlink" title="5 混合操作的幂等性"></a>5 混合操作的幂等性</h2><p>找到操作的唯一业务单号，有则使用分布式锁，无则通过token保证</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>postgresql 常用SQL整理</title>
    <link href="/postgresql-%E6%9F%A5%E8%AF%A2%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C/"/>
    <url>/postgresql-%E6%9F%A5%E8%AF%A2%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<ol><li>删除id最小的重复行</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> mes.stool_po <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span>(<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(id) <span class="hljs-keyword">FROM</span> mes.stool_po <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> purchasing_doc_number, purchasing_doc_item_number <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(id) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br>)<br></code></pre></td></tr></table></figure><ol start="2"><li>查询根据purchasing_doc_number, purchasing_doc_item_number分组后，重复的数据id</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">array_agg</span>(id) <span class="hljs-keyword">FROM</span> mes.stool_po <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> purchasing_doc_number, purchasing_doc_item_number <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(id) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/dcoker/"/>
    <url>/dcoker/</url>
    
    <content type="html"><![CDATA[<h1 id="1-docker解决了什么问题？"><a href="#1-docker解决了什么问题？" class="headerlink" title="1 docker解决了什么问题？"></a>1 docker解决了什么问题？</h1><p>比如我们现在开发了一个应用程序比如淘宝App，程序员从头到尾搭建了一套环境开始写代码，比如安装JDK等，代码写完后需要交给测试同事去运行，这事测试同学也需要从头到尾搭建一套环境，但比如JDK版本和你安装的不同，导致无法在测试同学的机器上运行起来，找开发去看问题，此时开发也很无辜，“明明在我的机器上是可以跑起来的”。</p><p>在没有容器技术之前，我们可以采用搭建虚拟机，然后测试人员克隆一个同样的虚拟机。</p><p>但是虚拟机里面是有一套完整的操作系统的。单单运行起来都需要耗费很多资源。比如我们新装的系统，还没有装任何的软件，磁盘已经被占用了好几个G，导致我们无法部署更多的应用程序，此外，操作系统的启动也很缓慢。</p><p>因此出现了容器技术。容器和集装箱在概念上是很相似的。需要实现隔离，也就是多个应用程序在运行时互相不干扰。</p><p>容器技术只隔离应用程序运行时环境，但是共享同一个操作系统。这里的运行时环境指的是程序运行依赖的各种库以及配置。</p><p>因此，相比较虚拟机，容器更加的轻量且占用的资源更少。我们可以部署更多的应用程序，同时启动的速度也很快。</p><p>docker就是容器技术的一种实现。</p><h1 id="2-docker是什么"><a href="#2-docker是什么" class="headerlink" title="2 docker是什么"></a>2 docker是什么</h1><p>docker是一个用Go语言实现的开源项目，可以让我们方便的创建和使用容器，docker将程序以及程序所有的依赖都打包到docker container，这样你的程序可以在任何环境都会有一致的表现。</p><p>这里程序运行的依赖也就是容器就好比集装箱，容器所处的操作系统环境就好比货船或港口，<strong>程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系</strong>。</p><p><strong>docker的底层实现</strong></p><p>docker基于<strong>Linux内核</strong>提供这样几项功能实现的：</p><ul><li><strong>NameSpace</strong>： 我们知道Linux中的PID、IPC、网络等资源是全局的，而NameSpace机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰，这就使得每个NameSpace看上去就像一个独立的操作系统一样，但是只有NameSpace是不够。</li><li><strong>Control groups</strong>：虽然有了NameSpace技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是cgroup)，有了cgroup就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。</li></ul><h1 id="3-安装下载"><a href="#3-安装下载" class="headerlink" title="3 安装下载"></a>3 安装下载</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">brew cask install docker<br></code></pre></td></tr></table></figure><h2 id="2-修改镜像源"><a href="#2-修改镜像源" class="headerlink" title="2. 修改镜像源"></a>2. 修改镜像源</h2><p>这里是网易的镜像源</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>   <span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span><br> ]<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230418145138450.png" alt="image-20230418145138450"></p><h1 id="4-docker容器生命周期管理"><a href="#4-docker容器生命周期管理" class="headerlink" title="4 docker容器生命周期管理"></a>4 docker容器生命周期管理</h1><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230418150102287.png" alt="image-20230418150102287"></p><ul><li><p>从镜像仓库中拉取或者更新指定镜像</p><p><code>docker pull nginx</code></p></li><li><p>创建一个新的容器但不启动它</p><p><code>docker create nginx</code></p></li><li><p>列出所有在运行的容器信息。</p><p><code>docker ps</code></p></li><li><p>显示所有的容器，包括未运行的</p><p><code>docker ps -a</code><br><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230418151220544.png" alt="image-20230418151220544"></p></li><li><p>启动一个停止的容器</p></li></ul><p>  <code>docker start d7e105501d1f</code></p><ul><li><p>登录容器，在运行的容器中执行命令</p><p><code> docker exec -it d7e105501d1f /bin/bash</code></p></li><li><p>暂停容器中所有的进程</p><p><code>docker pause d7e105501d1f</code></p></li><li><p>恢复容器中所有的进程。</p><p><code>docker unpause d7e105501d1f</code></p></li><li><p>停止一个运行中的容器</p><p><code>docker stop d7e105501d1f</code></p></li><li><p>杀掉一个运行中的容器。</p><p><code>docker kill d7e105501d1f</code></p></li><li><p>删除一个或多个容器</p><p><code>docker rm -f d7e105501d1f</code></p></li><li><p>在后台启动一个容器</p><p><code>docker run -d redis</code></p></li><li><p>启动一个映射端口的容器</p><p><code>docker run -p 80:80 -d nginx </code></p></li></ul><h1 id="5-docker镜像构建"><a href="#5-docker镜像构建" class="headerlink" title="5 docker镜像构建"></a>5 docker镜像构建</h1><ol><li><p>创建并编辑Dockerfile</p><p><code> vim Dockerfile</code></p></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#Owner by Pan Yu Rou</span><br><span class="hljs-keyword">FROM</span> redis<br><span class="hljs-keyword">MAINTAINER</span> pyr<br><span class="hljs-keyword">RUN</span><span class="bash"> mkdir test01</span><br><span class="hljs-keyword">RUN</span><span class="bash"> touch test02</span><br><span class="hljs-keyword">COPY</span><span class="bash"> test3 .</span><br><span class="hljs-keyword">ADD</span><span class="bash"> test4.tar.gz .</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;/bin/sh&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;ls -l&quot;</span>]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在Dockerfile所在路径下，运行<code>docker build -t your-image-name .</code></li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ruby">➜  docker_dir docker build -t mysh .<br>[+] Building <span class="hljs-number">0</span>.5s (<span class="hljs-number">10</span>/<span class="hljs-number">10</span>) FINISHED<br> =&gt; [internal] load build definition from Dockerfile                                                                                                                                                                                                                                              <span class="hljs-number">0</span>.0s<br> =&gt; =&gt; transferring <span class="hljs-symbol">dockerfile:</span> 199B                                                                                                                                                                                                                                                              <span class="hljs-number">0</span>.0s<br> =&gt; [internal] load .dockerignore                                                                                                                                                                                                                                                                 <span class="hljs-number">0</span>.0s<br> =&gt; =&gt; transferring <span class="hljs-symbol">context:</span> 2B                                                                                                                                                                                                                                                                   <span class="hljs-number">0</span>.0s<br> =&gt; [internal] load metadata for docker.io/library/<span class="hljs-symbol">redis:</span>latest                                                                                                                                                                                                                                   <span class="hljs-number">0</span>.0s<br> =&gt; [internal] load build context                                                                                                                                                                                                                                                                 <span class="hljs-number">0</span>.0s<br> =&gt; =&gt; transferring <span class="hljs-symbol">context:</span> 176B                                                                                                                                                                                                                                                                 <span class="hljs-number">0</span>.0s<br> =&gt; [<span class="hljs-number">1</span>/<span class="hljs-number">5</span>] FROM docker.io/library/redis                                                                                                                                                                                                                                                            <span class="hljs-number">0</span>.0s<br> =&gt; [<span class="hljs-number">2</span>/<span class="hljs-number">5</span>] RUN mkdir test01                                                                                                                                                                                                                                                                        <span class="hljs-number">0</span>.2s<br> =&gt; [<span class="hljs-number">3</span>/<span class="hljs-number">5</span>] RUN touch test02                                                                                                                                                                                                                                                                        <span class="hljs-number">0</span>.1s<br> =&gt; [<span class="hljs-number">4</span>/<span class="hljs-number">5</span>] COPY test3 .                                                                                                                                                                                                                                                                            <span class="hljs-number">0</span>.0s<br> =&gt; [<span class="hljs-number">5</span>/<span class="hljs-number">5</span>] ADD test4.tar.gz .                                                                                                                                                                                                                                                                      <span class="hljs-number">0</span>.0s<br> =&gt; exporting to image                                                                                                                                                                                                                                                                            <span class="hljs-number">0</span>.0s<br> =&gt; =&gt; exporting layers                                                                                                                                                                                                                                                                           <span class="hljs-number">0</span>.0s<br> =&gt; =&gt; writing image <span class="hljs-symbol">sha256:</span>679e723aa319cdb9d1aeb923534c200b6ddb60eb9a87c8e7a3814145f716b3ff                                                                                                                                                                                                      <span class="hljs-number">0</span>.0s<br> =&gt; =&gt; naming to docker.io/library/mysh<br></code></pre></td></tr></table></figure><ol start="3"><li>通过<code>docker run your-image-name</code>运行容器</li></ol><p>可以看到test01，test02， test4 都已经出现在了容器目录中，当不指定参数命令运行时，默认运行CMD里配置的命令，否则执行参数中的命令</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">➜  docker_dir docker run mysh<br>total 8<br>drwxr-xr-x<span class="hljs-number"> 2 </span>root root   <span class="hljs-number"> 4096 </span>Apr<span class="hljs-number"> 18 </span>08:14 test01<br>-rw-r--r--<span class="hljs-number"> 1 </span>root root      <span class="hljs-number"> 0 </span>Apr<span class="hljs-number"> 18 </span>08:14 test02<br>drwxr-xr-x<span class="hljs-number"> 2 </span><span class="hljs-number"> 501 </span>dialout<span class="hljs-number"> 4096 </span>Apr<span class="hljs-number"> 18 </span>08:11 test4<br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">➜  docker_dir docker <span class="hljs-built_in">run</span> mysh -c <span class="hljs-built_in">date</span><br>Tue Apr <span class="hljs-number">18</span> <span class="hljs-number">08</span>:<span class="hljs-number">16</span>:<span class="hljs-number">51</span> UTC <span class="hljs-number">2023</span><br></code></pre></td></tr></table></figure><h1 id="4-Dockerfile常用指令"><a href="#4-Dockerfile常用指令" class="headerlink" title="4 Dockerfile常用指令"></a>4 Dockerfile常用指令</h1><ul><li><p><strong>FROM</strong>：定制的镜像都是基于 某个 基础镜像，这里的FROM就是指定基础镜像。因此在Dockerfile中，FORM是必备指令，并且必须是第一条指令。</p></li><li><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。</p></li><li><p><strong>COPY</strong>: 复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p></li><li><p><strong>ADD</strong>: ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><ul><li><p>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</p></li><li><p>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</p></li></ul></li><li><p><strong>CMD</strong>: </p><ul><li>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同: CMD 在docker run 时运行，RUN 是在 docker build。</li><li>CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</li><li>如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</li></ul></li><li><p><strong>ENTRYPOINT</strong></p><ul><li>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</li><li>如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</li><li>如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</li></ul></li><li><p><strong>ENV</strong></p><ul><li><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">ENV <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>ENV <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value2</span>&gt;</span>...<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>ARG</strong></p><ul><li>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</li><li>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。</li><li>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li></ul></li><li><p><strong>EXPOSE</strong></p><ul><li>仅仅只是声明端口。</li></ul></li></ul><h1 id="6-docker数据持久化"><a href="#6-docker数据持久化" class="headerlink" title="6 docker数据持久化"></a>6 docker数据持久化</h1><p>摆放数据的持久化卷有两种常见的使用方法：Bing mounts 和 Volume</p><h2 id="1-Bind-Mounts（狩猎模式）"><a href="#1-Bind-Mounts（狩猎模式）" class="headerlink" title="1. Bind Mounts（狩猎模式）"></a>1. Bind Mounts（狩猎模式）</h2><p>Bind mounts 是由用户在主机上进行选择目录进行存储，方便指定特定文件或者目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">docker run -v <span class="hljs-tag">&lt;<span class="hljs-name">host_path:</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">container_path</span>&gt;</span> -d <br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜  docker docker run -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/data:/</span>data -d redis:<span class="hljs-number">3.2</span> redis-server<br>d7a6e3dccf100ea42bb1a8168dbf9ea27ed71b0b2837d19239f3eff8497fedd5<br>➜  docker docker ps<br>CONTAINER ID   IMAGE       COMMAND                  CREATED         STATUS         PORTS      NAMES<br>d7a6e3dccf10   redis:<span class="hljs-number">3.2</span>   <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">5</span> seconds ago   Up <span class="hljs-number">4</span> seconds   <span class="hljs-number">6379</span>/tcp   quizzical_swartz<br><span class="hljs-number">2</span>e3ce4212a25   redis       <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">2</span> hours ago     Up <span class="hljs-number">2</span> hours     <span class="hljs-number">6379</span>/tcp   charming_ritchie<br>➜  docker docker exec -it d7a6e3dccf10 <span class="hljs-regexp">/bin/</span>bash<br>root@d7a6e3dccf10:/data<span class="hljs-comment"># touch redis-logs</span><br>root@d7a6e3dccf10:/data<span class="hljs-comment"># exit</span><br><span class="hljs-keyword">exit</span><br>➜  docker ls<br>data         dockerfile01 dockerfile02<br>➜  docker cd data<br>➜  data ls<br>redis-logs<br></code></pre></td></tr></table></figure><h2 id="2-Volumes（靶场模式）"><a href="#2-Volumes（靶场模式）" class="headerlink" title="2. Volumes（靶场模式）"></a>2. Volumes（靶场模式）</h2><p>而Volume则统一将数据放到主机的、var&#x2F;lib&#x2F;docker&#x2F;volumes下，只能对应特定目录下的子目录，不支持文件，但是不容易乱，适合小白进行使用。两种主流volumn的创建方式：</p><ul><li><p>隐式创建卷：<code>docker run -v &lt;container_path&gt; -d </code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜  docker docker run -v data2 -d redis:<span class="hljs-number">3.2</span> redis-server<br><span class="hljs-number">829</span>ea54fbaeef20c7ea1f3f1e3a82d5dd7f7a73d099c74b758926a14b2c4f5ca<br>➜  docker docker ps<br>CONTAINER ID   IMAGE       COMMAND                  CREATED              STATUS              PORTS      NAMES<br><span class="hljs-number">829</span>ea54fbaee   redis:<span class="hljs-number">3.2</span>   <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">4</span> seconds ago        Up <span class="hljs-number">3</span> seconds        <span class="hljs-number">6379</span>/tcp   awesome_euclid<br>d7a6e3dccf10   redis:<span class="hljs-number">3.2</span>   <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   About a minute ago   Up About a minute   <span class="hljs-number">6379</span>/tcp   quizzical_swartz<br><span class="hljs-number">2</span>e3ce4212a25   redis       <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">2</span> hours ago          Up <span class="hljs-number">2</span> hours          <span class="hljs-number">6379</span>/tcp   charming_ritchie<br>➜  docker docker exec -it <span class="hljs-number">829</span>ea54fbaee <span class="hljs-regexp">/bin/</span>bash<br>root@<span class="hljs-number">829</span>ea54fbaee:/data<span class="hljs-comment"># touch redis-log2</span><br>root@<span class="hljs-number">829</span>ea54fbaee:/data<span class="hljs-comment"># exit</span><br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜  docker docker run -it --privileged --pid=host justincormack/nsenter1<br><br><span class="hljs-regexp">/ # cd var/</span>lib<span class="hljs-regexp">/docker/</span>volumes<span class="hljs-regexp">/b4778654451afef91ac2dbf8e6ce7881c065404ebc749d1bc7ea50fa93122e3d/</span>_data<br><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>volumes<span class="hljs-regexp">/b4778654451afef91ac2dbf8e6ce7881c065404ebc749d1bc7ea50fa93122e3d/</span>_data <span class="hljs-comment"># ls</span><br>redis-log2<br></code></pre></td></tr></table></figure></li><li><p>显式创建卷：(先创建卷，再创建容器绑定卷)        <code>docker volume create data3</code></p></li></ul><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"> ➜  docker docker volume create data<span class="hljs-number">3</span><br> ➜  docker docker run -v data<span class="hljs-number">3</span>:/data<span class="hljs-number">3</span> -d redis:<span class="hljs-number">3.2</span> redis-server<br>da<span class="hljs-number">981</span>af<span class="hljs-number">699805</span>bf<span class="hljs-number">18e87</span>ed<span class="hljs-number">7</span>d<span class="hljs-number">986e2</span>e<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">6</span><span class="hljs-keyword">c</span><span class="hljs-number">08220</span><span class="hljs-keyword">c</span><span class="hljs-number">67</span>f<span class="hljs-number">111</span><span class="hljs-keyword">c</span><span class="hljs-number">136597</span><span class="hljs-keyword">c</span><span class="hljs-number">62</span>d<span class="hljs-number">15</span>f<span class="hljs-number">144</span><span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜  docker docker run -it --privileged --pid=host justincormack/nsenter1<br><span class="hljs-regexp">/ #  ls -ld /</span>var<span class="hljs-regexp">/lib/</span>docker<span class="hljs-regexp">/volumes/</span>data3<br>drwx-----x    <span class="hljs-number">3</span> root     root          <span class="hljs-number">4096</span> Apr <span class="hljs-number">18</span> <span class="hljs-number">09</span>:<span class="hljs-number">31</span> <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>volumes/data3<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230418170422909.png" alt="image-20230418170422909"></p><h1 id="7-Docker仓库"><a href="#7-Docker仓库" class="headerlink" title="7 Docker仓库"></a>7 Docker仓库</h1><p>仓库（Repository）是集中存放镜像的地方。 总体来看Docker 仓库可以分为两大类：</p><ul><li>公共仓库：最经典的公共仓库就是Docker Hub。当Docker装好后，其默认的镜像源头就是这个功能仓库。当运行Docker run等命令时系统会自动从Docker Hub下载现有镜像到本地。除了Docker Hub之外还有一些第三方的公共仓库，对外提供服务，比如Quay、阿里云等。</li><li>私有仓库：私有仓库是互联网企业的生产中心的实际操作中的主流选择。不采用公共仓库通常出于以下两个原因：<ul><li>公共仓库通常建于海外，下载速度受限，对于大量节点频繁更新的互联网应用场景不太友好。</li><li>公共仓库位于外网，直接将生产中心的应用和外网相连，存在明显安全隐患。黑客等容易通过网络漏洞渗透到企业内网；并且公共仓库内的容器镜像未通过企业内部的静态文件扫描，无法保证镜像中所采用的运行时和依赖库的安全性。</li></ul></li></ul><h1 id="8-修改Docker默认镜像和容器存储位置"><a href="#8-修改Docker默认镜像和容器存储位置" class="headerlink" title="8 修改Docker默认镜像和容器存储位置"></a>8 修改Docker默认镜像和容器存储位置</h1><p><a href="https://so.csdn.net/so/search?q=Docker&spm=1001.2101.3001.7020">Docker</a> 默认安装的情况下，会使用 <code>/var/lib/docker/</code> 目录作为存储目录，用以存放拉取的镜像和创建的容器等。不过由于此目录一般都位于系统盘，遇到系统盘比较小，而镜像和容器多了后就容易磁盘空间不足</p><ul><li><p>查看当前<a href="https://so.csdn.net/so/search?q=docker&spm=1001.2101.3001.7020">docker</a>的默认存储目录 <code>docker info</code> ,默认为<code>/var/lib/docker/</code> </p></li><li><p>编辑 <code>/etc/docker/daemon.json</code> 文件</p><p><code>sudo vim /etc/docker/daemon.json </code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;data-root&quot;</span>: <span class="hljs-string">&quot;/home/docker&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>重启docker, 并查看 <code>docker info</code></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单点登录</title>
    <link href="/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <url>/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-跨域认证的问题"><a href="#1-跨域认证的问题" class="headerlink" title="1 跨域认证的问题"></a>1 跨域认证的问题</h1><p>互联网服务离不开用户认证。一般流程是下面这样。</p><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><ul><li>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</li><li>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</li></ul><h1 id="2-JWT概述"><a href="#2-JWT概述" class="headerlink" title="2 JWT概述"></a>2 JWT概述</h1><p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;姓名&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-string">&quot;角色&quot;</span>: <span class="hljs-string">&quot;管理员&quot;</span>,<br>  <span class="hljs-string">&quot;到期时间&quot;</span>: <span class="hljs-string">&quot;2018年7月1日0点0分&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展</p><h1 id="3-JWT-的数据结构"><a href="#3-JWT-的数据结构" class="headerlink" title="3 JWT 的数据结构"></a>3 JWT 的数据结构</h1><p>实际的 JWT 大概就像下面这样。<a href="https://jwt.io/">https://jwt.io/</a></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230320140654212.png" alt="image-20230320140654212"></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。依次是：</p><ul><li>Header（头部）：Header 部分是一个 JSON 对象，描述 JWT 的元数据。上图中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</li><li>Payload（负载）：Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。除了官方字段，你还可以在这个部分定义私有字段</li><li>Signature（签名）：Signature 部分是对前两部分的签名，防止数据篡改。首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</li></ul><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><p><strong>Base64URL</strong></p><p>Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com&#x2F;?token&#x3D;xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h1 id="4-JWT-的使用方式"><a href="#4-JWT-的使用方式" class="headerlink" title="4 JWT 的使用方式"></a>4 JWT 的使用方式</h1><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Authorization:</span> Bearer <span class="hljs-params">&lt;token&gt;</span><br></code></pre></td></tr></table></figure><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h1 id="5-JWT特点"><a href="#5-JWT特点" class="headerlink" title="5 JWT特点"></a>5 JWT特点</h1><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁</title>
    <link href="/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是分布式锁"><a href="#1-什么是分布式锁" class="headerlink" title="1 什么是分布式锁"></a>1 什么是分布式锁</h1><ul><li>在单体的应用开发场景中涉及并发同步的时候，大家往往采用Synchronized（同步）或者其他同一个JVM内Lock机制来解决多线程间的同步问题。</li><li>在分布式集群工作的开发场景中，就需要一种更加高级的锁机制来处理跨机器的进程之间的数据同步问题，这种跨机器的锁就是分布式锁</li></ul><h1 id="2-分布式锁的实现"><a href="#2-分布式锁的实现" class="headerlink" title="2 分布式锁的实现"></a>2 分布式锁的实现</h1><p>分布式锁的核心是实现多进程之间互斥，而满足这一点的方式有很多，常见的有三种：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/640.png" alt="图片"></p><ul><li>基于 数据库 的分布式锁  <a href="https://pyr9.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">https://pyr9.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</a></li><li>基于 Redis 的分布式锁  <a href="https://pyr9.github.io/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">https://pyr9.github.io/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</a></li><li>基于 Zookeeper 的分布式锁 <a href="https://pyr9.github.io/Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">https://pyr9.github.io/Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式ID</title>
    <link href="/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    
    <content type="html"><![CDATA[<h1 id="1-分布式ID"><a href="#1-分布式ID" class="headerlink" title="1 分布式ID"></a>1 分布式ID</h1><p>一个好的分布式ID，一般要满足下列特性：</p><ul><li><strong>唯一性</strong>：保证全局唯一</li><li><strong>高可用</strong>，可以由主从、集群等模式保证可用性</li><li><strong>高性能</strong>，比如基于内存</li><li><strong>递增性</strong>：适合作为数据库索引</li><li><strong>安全性</strong>：id如果是顺序递增，则容易暴露业务信息</li></ul><h1 id="2-全局唯一ID生成策略"><a href="#2-全局唯一ID生成策略" class="headerlink" title="2 全局唯一ID生成策略"></a>2 全局唯一ID生成策略</h1><h3 id="1-数据库自增ID"><a href="#1-数据库自增ID" class="headerlink" title="1. 数据库自增ID"></a>1. 数据库自增ID</h3><p>利用数据库的自增主键特性，每次插入记录时，数据库会自动生成一个唯一的ID。</p><p><strong>优点</strong>：</p><ul><li>简单易用，直接使用数据库提供的功能。</li><li>保证唯一性。</li></ul><p><strong>缺点</strong>：</p><ul><li>存在单点故障，数据库成为瓶颈。</li><li>难以水平扩展，性能可能不足。</li></ul><h3 id="2-UUID（Universally-Unique-Identifier）"><a href="#2-UUID（Universally-Unique-Identifier）" class="headerlink" title="2. UUID（Universally Unique Identifier）"></a>2. UUID（Universally Unique Identifier）</h3><p>UUID 是一种标准的唯一标识符，通常为128位长，可以保证全局唯一性。</p><p><strong>优点</strong>：</p><ul><li>生成简单，不依赖中心化服务。</li><li>唯一性强。</li></ul><p><strong>缺点</strong>：</p><ul><li>较长，占用空间大，不适合作为数据库索引。</li><li>无序，不利于数据库性能优化。</li></ul><h3 id="3-Twitter的Snowflake算法"><a href="#3-Twitter的Snowflake算法" class="headerlink" title="3. Twitter的Snowflake算法"></a>3. Twitter的Snowflake算法</h3><p>Snowflake 是 Twitter 开源的分布式ID生成算法，通过组合时间戳、机器ID和序列号生成ID。</p><p><strong>ID结构</strong>：</p><ul><li>1位符号位：始终为0。</li><li>41位时间戳：毫秒级时间戳，可使用69年。</li><li>10位机器ID：支持1024台机器。</li><li>12位序列号：每毫秒支持生成4096个ID。</li></ul><p><strong>优点</strong>：</p><ul><li>高性能，低延迟。</li><li>时间有序生成，适合数据库索引。</li></ul><p><strong>缺点</strong>：</p><ul><li>依赖机器时间，时钟回拨可能导致ID重复或冲突。</li></ul><h3 id="4-使用Redis生成ID"><a href="#4-使用Redis生成ID" class="headerlink" title="4. 使用Redis生成ID"></a>4. 使用Redis生成ID</h3><p>利用Redis的原子性递增操作，生成分布式唯一ID。</p><p><strong>优点</strong>：</p><ul><li>简单，利用Redis的原子操作保证唯一性。</li><li>性能高，Redis操作速度快。</li></ul><p><strong>缺点</strong>：</p><ul><li>依赖Redis服务，可能成为瓶颈。</li><li>需要处理Redis的持久化和高可用性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jenkins部署vue项目</title>
    <link href="/jenkins%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE/"/>
    <url>/jenkins%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-配置nodeJs"><a href="#1-配置nodeJs" class="headerlink" title="1 配置nodeJs"></a>1 配置nodeJs</h1><p>因为Jenkins容器中只有java环境支持运行jenkins，没有node环境，但是jenkins提供在线安装nodejs。<a href="https://plugins.jenkins.io/nodejs">官方文档</a></p><ol><li>系统管理—&gt;管理插件—&gt;下载NodeJS插件</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230315155958382.png" alt="image-20230315155958382"></p><ol start="2"><li>系统管理—&gt;全局工具配置—&gt;选择需要安装的nodejs版本</li></ol><p>Jenkins 会从nodejs官网下载安装，nodejs安装包在：$JENKINS_HOME&#x2F;tools目录下</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230315155909887.png" alt="image-20230315155909887"></p><p>注：这里也需要配置git</p><h1 id="2-新建一个任务"><a href="#2-新建一个任务" class="headerlink" title="2 新建一个任务"></a>2 新建一个任务</h1><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230315160310957.png" alt="image-20230315160310957"></p><h1 id="3-配置仓库地址和分支名"><a href="#3-配置仓库地址和分支名" class="headerlink" title="3 配置仓库地址和分支名"></a>3 配置仓库地址和分支名</h1><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230315160535916.png" alt="image-20230315160535916"></p><h1 id="4-配置构建环境"><a href="#4-配置构建环境" class="headerlink" title="4 配置构建环境"></a>4 配置构建环境</h1><p>构建环境勾选 Provide Node &amp; npm bin&#x2F;folder to PATH</p><ul><li>每次build，都会首先执行环境构建，环境构建无误后，才会开始真正的构建过程</li><li>会下载nodejs并安装配置，并把node添加到当前PATH环境变量中，这样就支持node和npm命令了</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230315160620905.png" alt="image-20230315160620905"></p><h1 id="5-配置shell"><a href="#5-配置shell" class="headerlink" title="5 配置shell"></a>5 配置shell</h1><p>执行：</p><p><code>npm install &amp;&amp; npm run build &amp;&amp; npm run domain &amp;&amp; npm run aliyun</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230322152124371.png" alt="image-20230322152124371"></p><p>至此，可以点击立即构建了</p><h1 id="6-配置远端服务器"><a href="#6-配置远端服务器" class="headerlink" title="6 配置远端服务器"></a>6 配置远端服务器</h1><p>注意：如果使用了echo,需要勾选Verbose output in console才可以在控制台，看到打印的日志</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230324163338300.png" alt="image-20230324163338300"></p><h1 id="7-使用打好的包替换服务器上的包"><a href="#7-使用打好的包替换服务器上的包" class="headerlink" title="7 使用打好的包替换服务器上的包"></a>7 使用打好的包替换服务器上的包</h1><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230322154215106.png" alt="image-20230322154215106"></p><h1 id="8-遇到的问题"><a href="#8-遇到的问题" class="headerlink" title="8 遇到的问题"></a>8 遇到的问题</h1><p>记录下在windows搭建时遇到的问题</p><ol><li>Cannot run program “sh” (in directory “C:\ProgramData\Jenkins.jenkins\workspace\sith-front”): CreateProcess error&#x3D;2, 系统找不到指定的文件。</li></ol><p>解决：Manage Jenkins-&gt; Configure System-&gt; Shell-&gt; Shell execute </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">C:\Windows\system32\cmd.exe<br></code></pre></td></tr></table></figure><ol start="2"><li><p>ssh:&#x2F;&#x2F;&#x2F;<a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#x69;&#x74;&#101;&#101;&#x2e;&#x63;&#111;&#109;">&#x67;&#105;&#x74;&#64;&#103;&#x69;&#x74;&#101;&#101;&#x2e;&#x63;&#111;&#109;</a>:SIEMENS_MMF&#x2F;MMF.git +refs&#x2F;heads&#x2F;<em>:refs&#x2F;remotes&#x2F;origin&#x2F;</em>“ returned status code 128:<br>stdout:<br>stderr: ssh: connect to host  port 22: Connection refused<br>fatal: Could not read from remote repository.</p><p>Please make sure you have the correct access rights<br>and the repository exists.</p></li></ol><p>原因：Jenkins网页登录时，ssh连接使用的是Jenkins自身的账户，并不是我们登录电脑所使用的的账户，该账户下并没有ssh连接所需要的rsa文件，</p><p>解决：</p><p>成功执行git pull等命令的账户，在C:\Users\xxxxxx.ssh目录下（xxxxxx是登录电脑的用户名，不是git的用户名），会有id_rsa，id_rsa.pub，known_hosts文件，把这3个文件拷贝到C:\Windows\System32\config\systemprofile.ssh目录下，再执行jenkins就OK了</p>]]></content>
    
    
    <categories>
      
      <category>jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>权限</title>
    <link href="/%E6%9D%83%E9%99%90/"/>
    <url>/%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<p>![image-20230227215016860](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227215016860.png)</p><p>![image-20230227215417463](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227215417463.png)</p><p>![image-20230227215912534](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227215912534.png)</p><p>![image-20230227220350015](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227220350015.png) </p><p>![image-20230227221024772](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227221024772.png)</p><p>![image-20230227221142243](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227221142243.png)</p><p>![image-20230227221149342](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227221149342.png)</p><ul><li>权限相关更新记录表</li></ul><p>![image-20230227221806073](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227221806073.png)</p><p>![image-20230227223420765](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227223420765.png)</p><ul><li>null被索引的话，需要额外的一个字节</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Shiro入门</title>
    <link href="/Shiro%E5%85%A5%E9%97%A8/"/>
    <url>/Shiro%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-shiro-概念"><a href="#1-shiro-概念" class="headerlink" title="1. shiro 概念"></a>1. shiro 概念</h1><ul><li><strong>Apache Shiro™</strong>是一个强大且易用的Java安全框架,能够用于身份验证、授权、加密和会话管理</li><li>Shiro拥有易于理解的API,您可以快速、轻松地获得任何应用程序——从最小的移动应用程序到最大的网络和企业应用程序。</li></ul><h1 id="2-shiro优缺点"><a href="#2-shiro优缺点" class="headerlink" title="2. shiro优缺点"></a>2. shiro优缺点</h1><p>优点： </p><ul><li>提供了一套框架，易于使用</li><li>更灵活，应对需求能力强，web能力强</li><li>可与很多框架进行集成</li></ul><p>缺点：</p><ul><li>操作的界面需要自己实现</li></ul><h1 id="3-springboot集成shiro"><a href="#3-springboot集成shiro" class="headerlink" title="3 springboot集成shiro"></a>3 springboot集成shiro</h1><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>创建自定义AuthRealm和密码校验规则</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-comment">// 认证登录</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token;<br>        String username = usernamePasswordToken.getUsername();<br>        User user = userService.findByUsername(username);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(user, user.getPassword(), <span class="hljs-keyword">this</span>.getClass().getName());<br>    &#125;<br><br>    <span class="hljs-comment">// 授权</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;<br>        User user = (User) principals.fromRealm(<span class="hljs-keyword">this</span>.getClass().getName()).iterator().next();<br>        List&lt;String&gt; permissionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;String&gt; roleNameList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Set&lt;Role&gt; roleSet = user.getRoles();<br>        <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(roleSet)) &#123;<br>            <span class="hljs-keyword">for</span> (Role role : roleSet) &#123;<br>                roleNameList.add(role.getRname());<br>                Set&lt;Permission&gt; permissionSet = role.getPermissions();<br>                <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(permissionSet)) &#123;<br>                    <span class="hljs-keyword">for</span> (Permission permission : permissionSet) &#123;<br>                        permissionList.add(permission.getName());<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();<br>        info.addStringPermissions(permissionList);<br>        info.addRoles(roleNameList);<br>        <span class="hljs-keyword">return</span> info;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自己实现密码校验规则</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CredentialMatcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleCredentialsMatcher</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doCredentialsMatch</span><span class="hljs-params">(AuthenticationToken token, AuthenticationInfo info)</span> </span>&#123;<br>        UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token;<br>        String password = <span class="hljs-keyword">new</span> String(usernamePasswordToken.getPassword());<br>        String dbPassword = (String) info.getCredentials();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.equals(password, dbPassword);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li>添加配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.shiro.demo1.config;<br><br><span class="hljs-keyword">import</span> com.pyr.shiro.demo1.shiro.AuthRealm;<br><span class="hljs-keyword">import</span> com.pyr.shiro.demo1.shiro.CredentialMatcher;<br><span class="hljs-keyword">import</span> org.apache.shiro.cache.MemoryConstrainedCacheManager;<br><span class="hljs-keyword">import</span> org.apache.shiro.mgt.SecurityManager;<br><span class="hljs-keyword">import</span> org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;<br><span class="hljs-keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;<br><span class="hljs-keyword">import</span> org.apache.shiro.web.filter.mgt.DefaultFilter;<br><span class="hljs-keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;<br><span class="hljs-keyword">import</span> org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfiguration</span> </span>&#123;<br><br>    <span class="hljs-comment">//ShiroFilter过滤所有请求</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">shiroFilter</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;securityManager&quot;)</span> SecurityManager manager)</span> </span>&#123;<br>        ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();<br>        bean.setSecurityManager(manager);<br>        bean.setFilterChainDefinitionMap(filterChainDefinitionMap);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建安全管理器</span><br>    <span class="hljs-meta">@Bean(&quot;securityManager&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SecurityManager <span class="hljs-title">securityManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;authRealm&quot;)</span> AuthRealm authRealm)</span> </span>&#123;<br>        DefaultWebSecurityManager manager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();<br>        manager.setRealm(authRealm);<br>        <span class="hljs-keyword">return</span> manager;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建自定义Realm</span><br>    <span class="hljs-meta">@Bean(&quot;authRealm&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthRealm <span class="hljs-title">authRealm</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;credentialMatcher&quot;)</span> CredentialMatcher matcher)</span> </span>&#123;<br>        AuthRealm authRealm = <span class="hljs-keyword">new</span> AuthRealm();<br>        authRealm.setCacheManager(<span class="hljs-keyword">new</span> MemoryConstrainedCacheManager());<br>        authRealm.setCredentialsMatcher(matcher);<br>        <span class="hljs-keyword">return</span> authRealm;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;credentialMatcher&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CredentialMatcher <span class="hljs-title">credentialMatcher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CredentialMatcher();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * shiro和spring的配置</span><br><span class="hljs-comment">     * 设置spring使用的securityManager是我们自定义的securityManager</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="hljs-title">authorizationAttributeSourceAdvisor</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;securityManager&quot;)</span> SecurityManager securityManager)</span> </span>&#123;<br>        AuthorizationAttributeSourceAdvisor advisor = <span class="hljs-keyword">new</span> AuthorizationAttributeSourceAdvisor();<br>        advisor.setSecurityManager(securityManager);<br>        <span class="hljs-keyword">return</span> advisor;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="hljs-title">defaultAdvisorAutoProxyCreator</span><span class="hljs-params">()</span> </span>&#123;<br>        DefaultAdvisorAutoProxyCreator creator = <span class="hljs-keyword">new</span> DefaultAdvisorAutoProxyCreator();<br>        creator.setProxyTargetClass(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> creator;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h1><p>代码地址： <a href="https://github.com/pyr9/springboot-shiro-demo">https://github.com/pyr9/springboot-shiro-demo</a></p>]]></content>
    
    
    <categories>
      
      <category>权限管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringSecurity</title>
    <link href="/springSecurity/"/>
    <url>/springSecurity/</url>
    
    <content type="html"><![CDATA[<h1 id="1-权限管理"><a href="#1-权限管理" class="headerlink" title="1. 权限管理"></a>1. 权限管理</h1><h2 id="1-1-为什么需要权限管理"><a href="#1-1-为什么需要权限管理" class="headerlink" title="1.1. 为什么需要权限管理"></a>1.1. 为什么需要权限管理</h2><ul><li>安全性：误操作、认为破坏、数据泄漏等</li><li>数据隔离：不同的权限可以看到不同的数据</li><li>明确职责：销售、开发等不同角色，leader和dev不同级别，不同职责可以看到不同的数据</li></ul><h2 id="1-2-理想的权限管理"><a href="#1-2-理想的权限管理" class="headerlink" title="1.2. 理想的权限管理"></a>1.2. 理想的权限管理</h2><ul><li>能实现角色级权限</li><li>能实现功能级、数据级权限</li><li>简单、易操作、能够应对各种需求</li></ul><h1 id="2-SpringSecurity"><a href="#2-SpringSecurity" class="headerlink" title="2. SpringSecurity"></a>2. SpringSecurity</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1.  概念"></a>2.1.  概念</h2><ul><li><p>Spring Security 是 Spring 家族中的一个<strong>安全管理框架</strong>。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。</p></li><li><p>一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。</p></li><li><p>一般Web应用的需要进行认证和授权。而<strong>认证和授权也是SpringSecurity作为安全框架的核心功能</strong>。</p><ul><li>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</li><li>授权：经过认证后判断当前用户是否有权限进行某个操作</li></ul></li></ul><h2 id="2-2-优点和缺点"><a href="#2-2-优点和缺点" class="headerlink" title="2.2 优点和缺点"></a>2.2 优点和缺点</h2><p>优点：</p><ul><li>提供了很多用户认证的功能，实现相关接口即可，节省了大量开发工作</li><li>基于spring，易于集成</li></ul><p>缺点：</p><ul><li>配置文件多，角色被 “编码” 到配置文件和源文件中</li><li>对于系统中的用户、角色、权限之间的关系，没有可操作的界面。后台管理员没办法知道每个人的角色权限是什么样的，增大了管理的难度和分配权限的错误率。</li><li>由于配置多，没有可操作的界面，大数据量情况下，基本不可用。</li></ul><h2 id="2-3-springboot-整合-springSecurity"><a href="#2-3-springboot-整合-springSecurity" class="headerlink" title="2.3  springboot 整合 springSecurity"></a>2.3  springboot 整合 springSecurity</h2><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>添加配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.security.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.WebSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        http.authorizeRequests()<br>                .antMatchers(<span class="hljs-string">&quot;/&quot;</span>).permitAll()<br>                .anyRequest().authenticated()<br>                .and()<br>                .logout().permitAll()<br>                .and()<br>                .formLogin();<br>        http.csrf().disable();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        web.ignoring().antMatchers(<span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/images/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>测试</li></ol><p>根据配置文件，可以得知，所有人可访问”&#x2F;“，其他请求都需要登录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello springboot!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试访问 “&#x2F;“ 路径</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230226185258468.png" alt="image-20230226185258468"></p><ul><li><p>测试访问 “&#x2F;hello” ，会302重定向到shiro框架，默认的login界面（依赖版本不同，login页面会有差异）</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230226185524573.png" alt="image-20230226185524573"></p></li></ul><h2 id="2-4-存储用户信息"><a href="#2-4-存储用户信息" class="headerlink" title="2.4 存储用户信息"></a>2.4 存储用户信息</h2><h3 id="2-4-1-直接存储在内存中"><a href="#2-4-1-直接存储在内存中" class="headerlink" title="2.4.1 直接存储在内存中"></a>2.4.1 直接存储在内存中</h3><p>在SpringSecurityConfig，中重写configure方法，指定用户和角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>  auth.inMemoryAuthentication().passwordEncoder(<span class="hljs-keyword">new</span> BCryptPasswordEncoder()).withUser(<span class="hljs-string">&quot;admin&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;111&quot;</span>)).roles(<span class="hljs-string">&quot;USER&quot;</span>);<br>  auth.inMemoryAuthentication().passwordEncoder(<span class="hljs-keyword">new</span> BCryptPasswordEncoder()).withUser(<span class="hljs-string">&quot;pyr&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;pyr&quot;</span>)).roles(<span class="hljs-string">&quot;ADMIN&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-4-2-存储在数据库中"><a href="#2-4-2-存储在数据库中" class="headerlink" title="2.4.2 存储在数据库中"></a>2.4.2 存储在数据库中</h3><ol><li>定义UserService实现UserDetailsService</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;<br>        <span class="hljs-keyword">return</span>  userMapper.findByUsername(username);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-使用角色控制方法的访问权限"><a href="#2-5-使用角色控制方法的访问权限" class="headerlink" title="2.5 使用角色控制方法的访问权限"></a>2.5 使用角色控制方法的访问权限</h2><ol><li>当ADMIN角色的用户访问&#x2F;roleAuth时，正常访问。当其他角色用户，访问&#x2F;roleAuth时，返回403</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// RoleVoter 里定义了角色名，使用的时候，都必须使用ROLE_作为前缀</span><br><span class="hljs-meta">@PreAuthorize(&quot;hasRole(&#x27;ROLE_ADMIN&#x27;)&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/roleAuth&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">role</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;admin Auth!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>当前登录的用户，有ADMIN或者MANAGER的角色</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize(&quot;hasRole(&#x27;ROLE_ADMIN&#x27;) or hasRole(&#x27;ROLE_MANAGER&#x27;)&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/roleAuth2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">role2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;admin Auth  222!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>传过来的id小于10 且 传过来的userName和数据库查出来的username相等</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize(&quot;#id&lt; 10 and principal.username.equals(#username)&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/roleAuth3&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">role3</span><span class="hljs-params">(Integer id, String username)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;admin Auth  33!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码地址：</p><p><a href="https://github.com/pyr9/springboot-security-demo">https://github.com/pyr9/springboot-security-demo</a></p>]]></content>
    
    
    <categories>
      
      <category>权限管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringSecurity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activiti——网关</title>
    <link href="/%E7%BD%91%E5%85%B3/"/>
    <url>/%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 网关用来控制流程的流向</p></blockquote><h1 id="1-排他网关ExclusiveGateway"><a href="#1-排他网关ExclusiveGateway" class="headerlink" title="1. 排他网关ExclusiveGateway"></a>1. 排他网关ExclusiveGateway</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>排他网关，用来在流程中实现决策。 当流程执行到这个网关，所有分支都会判断条件是否为true，如果为true则执行该分支，排他网关只会选择一个为true的分支执行。如果有两个分支条件都为true，排他网关会选择id值较小的一条分支去执行。</p><p><strong>为什么要用排他网关？</strong></p><p>不用排他网关也可以实现分支，如：在连线的condition条件上设置分支条件。</p><p>在连线设置condition条件的缺点：如果条件都不满足，流程就结束了(是异常结束)。如果从网关出去的线所有条件都不满足则系统抛出异常。</p><h2 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h2><p>出差申请大于等于3天需要先由总经理审批再由财务审批，小于3天直接由财务审批。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230213225917585.png" alt="image-20230213225917585"></p><p>测试：</p><p>当部门经理审批后，当出差天数为5时，会根据条件判断，当前需要走【总经理审批】，当前任务表：SELECT * FROM act_ru_task   </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230213232953567.png" alt="image-20230213232953567"></p><p>上图中：只有总经理审批是当前的任务在执行。</p><h1 id="2-并行网关ParallelGateway"><a href="#2-并行网关ParallelGateway" class="headerlink" title="2. 并行网关ParallelGateway"></a>2. 并行网关ParallelGateway</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><ul><li><p>并行网关允许将流程分成多条分支，也可以把多条分支汇聚到一起。</p></li><li><p>并行网关的功能是基于进入和外出顺序流的：</p><ul><li><p>分支：并行后的所有外出顺序流，为每个顺序流都创建一个并发分支。</p></li><li><p>join汇聚： 所有到达并行网关，在此等待的进入分支， 直到所有进入顺序流的分支都到达以后， 流程就会通过汇聚网关。</p></li></ul></li></ul><p>注意，如果同一个并行网关有多个进入和多个外出顺序流， 它就同时具有分支和汇聚功能。 这时，网关会先汇聚所有进入的顺序流，然后再切分成多个并行分支。</p><p><strong>与其他网关的主要区别是，并行网关不会解析条件。</strong> <strong>即使顺序流中定义了条件，也会被忽略。</strong></p><h2 id="2-2-案例"><a href="#2-2-案例" class="headerlink" title="2.2 案例"></a>2.2 案例</h2><p>出差申请由部门经理审批后，需要同时由总经理审批和财务审批，才可以结束。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230213230034272.png" alt="image-20230213230034272"></p><p>测试：</p><p>当部门经理审批后，当前需要走【财务审批+总经理审批】，当前任务表：SELECT * FROM act_ru_task   </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230213231916621.png" alt="image-20230213231916621"></p><p>上图中：财务审批、总经理审批 都是当前的任务，在并行执行。</p><h1 id="3-包含网关InclusiveGateway"><a href="#3-包含网关InclusiveGateway" class="headerlink" title="3.包含网关InclusiveGateway"></a>3.包含网关InclusiveGateway</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><ul><li><p>包含网关可以看做是排他网关和并行网关的结合体。 </p></li><li><p>和排他网关一样，你可以在外出顺序流上定义条件，包含网关会解析它们。 但是主要的区别是包含网关可以选择多于一条顺序流，这和并行网关一样。</p></li><li><p>包含网关的功能是基于进入和外出顺序流的：</p><ul><li>分支：所有外出顺序流的条件都会被解析，结果为true的顺序流会以并行方式继续执行， 会为每个顺序流创建一个分支。</li><li>汇聚：所有并行分支到达包含网关，会进入等待状态， 直到每个包含流程token的进入顺序流的分支都到达。 这是与并行网关的最大不同。换句话说，包含网关只会等待被选中执行了的进入顺序流。 在汇聚之后，流程会穿过包含网关继续执行。</li></ul></li></ul><h2 id="3-2-案例"><a href="#3-2-案例" class="headerlink" title="3.2 案例"></a>3.2 案例</h2><p>出差申请大于等于3天需要由总经理审批，小于3天由财务审批，出差申请必须经过部门经理审批。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230213225657718.png" alt="image-20230213225657718"></p><p>测试：</p><p>当出差天数为2时，会根据条件判断，当前需要走【财务审批+部门经理审批】，当前任务表：SELECT * FROM act_ru_task   </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230213231023874.png" alt="image-20230213231023874"></p><p>上图中：财务审批、部门经理审批 都是当前的任务，在并行执行。</p>]]></content>
    
    
    <categories>
      
      <category>Activiti</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activiti——组任务</title>
    <link href="/%E7%BB%84%E4%BB%BB%E5%8A%A1/"/>
    <url>/%E7%BB%84%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>在流程定义中在任务结点的 assignee 固定设置任务负责人，在流程定义时将参与者固定设置在.bpmn 文件中，如果临时任务负责人变更则需要修改流程定义，系统可扩展性差。</p><p>针对这种情况可以给任务设置多个候选人，可以从候选人中选择参与者来完成任务。 </p><h1 id="1-设置任务候选人"><a href="#1-设置任务候选人" class="headerlink" title="1. 设置任务候选人"></a>1. 设置任务候选人</h1><p>在流程图中任务节点的配置中设置 candidate-users(候选人)，多个候选人之间用逗号分开。</p>]]></content>
    
    
    <categories>
      
      <category>Activiti</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activiti——分配任务负责人</title>
    <link href="/Activiti%E2%80%94%E2%80%94%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%E8%B4%9F%E8%B4%A3%E4%BA%BA/"/>
    <url>/Activiti%E2%80%94%E2%80%94%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%E8%B4%9F%E8%B4%A3%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-固定分配"><a href="#1-固定分配" class="headerlink" title="1 固定分配"></a>1 固定分配</h1><p>在进行业务流程建模时指定固定的任务负责人， 如图：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230210163130769.png" alt="image-20230210163130769"></p><h1 id="2-表达式分配"><a href="#2-表达式分配" class="headerlink" title="2 表达式分配"></a>2 表达式分配</h1><p>Activiti 使用 UEL 表达式， UEL 是 java EE6 规范的一部分， UEL（Unified Expression Language）即 统一表达式语言， activiti 支持两个 UEL 表达式： UEL-value 和 UEL-method。 </p><h2 id="2-1-UEL-value"><a href="#2-1-UEL-value" class="headerlink" title="2.1  UEL-value"></a>2.1  UEL-value</h2><ul><li>assignee 这个变量是 activiti 的一个流程变量，</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230210163518444.png" alt="image-20230210163518444"></p><ul><li>user 也是 activiti 的一个流程变量， user.name 表示通过调用 user 的 getter 方法获取值</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230210163909807.png" alt="image-20230210163909807"></p><h2 id="2-2-UEL-method"><a href="#2-2-UEL-method" class="headerlink" title="2.2  UEL-method"></a>2.2  UEL-method</h2><p>userBean 是 spring 容器中的一个 bean，表示调用该 bean 的 getUserId()方法。 </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230210164303115.png" alt="image-20230210164303115"></p><h2 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h2><p>表达式支持解析基础类型、 bean、 list、 array 和 map，也可作为条件判断。如下：<br>${order.price &gt; 100 &amp;&amp; order.price &lt; 250} </p><h1 id="3-监听器分配"><a href="#3-监听器分配" class="headerlink" title="3 监听器分配"></a>3 监听器分配</h1><p>可以使用监听器来完成很多Activiti流程的业务。</p><p>任务监听器是发生对应的任务相关事件时执行自定义 java 逻辑 或表达式。</p><p>任务相当事件包括：  </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/1577506842889.png" alt="1577506842889"></p>]]></content>
    
    
    <categories>
      
      <category>Activiti</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activiti——流程定义操作</title>
    <link href="/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C/"/>
    <url>/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-流程定义信息查询"><a href="#1-流程定义信息查询" class="headerlink" title="1 流程定义信息查询"></a>1 流程定义信息查询</h1><p>查询流程相关信息，包含流程定义，流程部署，流程定义版本    -&gt; ACT_RE_PROCDEF</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryProcessDefinition</span><span class="hljs-params">()</span></span>&#123;<br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>       RepositoryService repositoryService = processEngine.getRepositoryService();<br>       ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery();<br>       List&lt;ProcessDefinition&gt; definitionList = processDefinitionQuery.processDefinitionKey(<span class="hljs-string">&quot;myProcess&quot;</span>)<br>               .orderByProcessDefinitionVersion()<br>               .desc()<br>               .list();<br>       <span class="hljs-keyword">for</span> (ProcessDefinition processDefinition : definitionList) &#123;<br>           System.out.println(<span class="hljs-string">&quot;流程定义 id=&quot;</span>+processDefinition.getId());<br>           System.out.println(<span class="hljs-string">&quot;流程定义 name=&quot;</span>+processDefinition.getName());<br>           System.out.println(<span class="hljs-string">&quot;流程定义 key=&quot;</span>+processDefinition.getKey());<br>           System.out.println(<span class="hljs-string">&quot;流程定义 Version=&quot;</span>+processDefinition.getVersion());<br>           System.out.println(<span class="hljs-string">&quot;流程部署ID =&quot;</span>+processDefinition.getDeploymentId());<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="2-流程定义删除"><a href="#2-流程定义删除" class="headerlink" title="2. 流程定义删除"></a>2. 流程定义删除</h1><p>说明：</p><ol><li><pre><code class="hljs">  使用repositoryService删除流程定义，历史表信息不会被删除</code></pre></li><li><pre><code class="hljs">  如果该流程定义下没有正在运行的流程，则可以用普通删除。</code></pre></li></ol><p>如果该流程定义下存在已经运行的流程，使用普通删除报错，可用级联删除方法将流程及相关记录全部删除。</p><p>先删除没有完成流程节点，最后就可以完全删除流程定义信息</p><p>项目开发中级联删除操作一般只开放给超级管理员使用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteDeployment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 流程部署id</span><br>    String deploymentId = <span class="hljs-string">&quot;1&quot;</span>;<br><br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    <span class="hljs-comment">// 通过流程引擎获取repositoryService</span><br>    RepositoryService repositoryService = processEngine<br>            .getRepositoryService();<br>    <span class="hljs-comment">//删除流程定义，如果该流程定义已有流程实例启动则删除时出错</span><br>    <span class="hljs-comment">//repositoryService.deleteDeployment(deploymentId);</span><br>    <span class="hljs-comment">//设置true 级联删除流程定义，即使该流程有流程实例启动也可以删除，设置为false非级别删除方式，如果流程</span><br>    repositoryService.deleteDeployment(deploymentId, <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Activiti</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activiti——流程实例</title>
    <link href="/%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C/"/>
    <url>/%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p><strong>流程实例</strong>（ProcessInstance）代表流程定义的执行实例。例如：用户或程序按照流程定义内容发起一个流程，这就是一个流程实例。</p><p>流程定义和流程实例的图解：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230209223705740.png" alt="image-20230209223705740"></p><h2 id="2-启动流程实例-并添加Businesskey"><a href="#2-启动流程实例-并添加Businesskey" class="headerlink" title="2. 启动流程实例 并添加Businesskey"></a>2. 启动流程实例 并添加Businesskey</h2><ul><li>Businesskey：业务标识，通常为业务表的主键，业务标识和流程实例一一对应。业务标识来源于业务系统。存储业务标识就是根据业务标识来关联查询业务系统的数据。</li><li>启动流程实例时，指定的businesskey，就会在act_ru_execution #流程实例的执行表中存储businesskey。</li><li>比如：出差流程启动一个流程实例，就可以将出差单的id作为业务标识存储到activiti中，将来查询activiti的流程实例信息就可以获取出差单的id从而关联查询业务系统数据库得到出差单信息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动流程实例，添加businessKey</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBusinessKey</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        1、得到ProcessEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        2、得到RunTimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        3、启动流程实例，同时还要指定业务标识businessKey，也就是出差申请单id，这里是1001</span><br>        ProcessInstance processInstance = runtimeService.<br>                startProcessInstanceByKey(<span class="hljs-string">&quot;myProcess&quot;</span>,<span class="hljs-string">&quot;0001&quot;</span>);<br><span class="hljs-comment">//        4、输出processInstance相关属性</span><br>        System.out.println(<span class="hljs-string">&quot;业务id==&quot;</span>+processInstance.getBusinessKey());<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="3-挂起、激活流程实例"><a href="#3-挂起、激活流程实例" class="headerlink" title="3. 挂起、激活流程实例"></a>3. 挂起、激活流程实例</h2><p>某些情况可能由于流程变更需要将当前运行的流程暂停而不是直接删除，流程暂停后将不会继续执行。</p><h3 id="3-1-全部流程实例挂起"><a href="#3-1-全部流程实例挂起" class="headerlink" title="3.1 全部流程实例挂起"></a>3.1 全部流程实例挂起</h3><p>流程定义为挂起状态时：</p><ol><li>该流程定义将不允许启动新的流程实例，</li><li>该流程定义下所有的流程实例将全部挂起暂停执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SuspendAllProcessInstance</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取repositoryService</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        查询流程定义的对象</span><br>        ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().<br>                processDefinitionKey(<span class="hljs-string">&quot;myProcess&quot;</span>).<br>                singleResult();<br><span class="hljs-comment">//        得到当前流程定义的实例是否都为暂停状态</span><br>        <span class="hljs-keyword">boolean</span> suspended = processDefinition.isSuspended();<br><span class="hljs-comment">//        流程定义id</span><br>        String processDefinitionId = processDefinition.getId();<br><span class="hljs-comment">//        判断是否为暂停</span><br>        <span class="hljs-keyword">if</span>(suspended)&#123;<br><span class="hljs-comment">//         如果是暂停，可以执行激活操作 ,参数1 ：流程定义id ，参数2：是否激活，参数3：激活时间</span><br>            repositoryService.activateProcessDefinitionById(processDefinitionId,<br>                    <span class="hljs-keyword">true</span>,<br>                    <span class="hljs-keyword">null</span><br>            );<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已激活&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//          如果是激活状态，可以暂停，参数1 ：流程定义id ，参数2：是否暂停，参数3：暂停时间</span><br>            repositoryService.suspendProcessDefinitionById(processDefinitionId,<br>                    <span class="hljs-keyword">true</span>,<br>                    <span class="hljs-keyword">null</span>);<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已挂起&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-单个流程实例挂起"><a href="#3-2-单个流程实例挂起" class="headerlink" title="3.2 单个流程实例挂起"></a>3.2 单个流程实例挂起</h3><p>单个流程实例挂起，则此流程不再继续执行，完成该流程实例的当前任务将报异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SuspendSingleProcessInstance</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        RuntimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        查询流程定义的对象</span><br>        ProcessInstance processInstance = runtimeService.<br>                createProcessInstanceQuery().<br>                processInstanceId(<span class="hljs-string">&quot;15001&quot;</span>).<br>                singleResult();<br><span class="hljs-comment">//        得到当前流程定义的实例是否都为暂停状态</span><br>        <span class="hljs-keyword">boolean</span> suspended = processInstance.isSuspended();<br><span class="hljs-comment">//        流程定义id</span><br>        String processDefinitionId = processInstance.getId();<br><span class="hljs-comment">//        判断是否为暂停</span><br>        <span class="hljs-keyword">if</span>(suspended)&#123;<br><span class="hljs-comment">//         如果是暂停，可以执行激活操作 ,参数：流程定义id</span><br>            runtimeService.activateProcessInstanceById(processDefinitionId);<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已激活&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//          如果是激活状态，可以暂停，参数：流程定义id</span><br>            runtimeService.suspendProcessInstanceById( processDefinitionId);<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已挂起&quot;</span>);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Activiti</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSH免密登录</title>
    <link href="/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    <url>/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-客户端生成公私钥"><a href="#1-客户端生成公私钥" class="headerlink" title="1. 客户端生成公私钥"></a>1. 客户端生成公私钥</h1><ol><li><p>执行<code>ssh-keygen</code>在用户目录.ssh文件夹下创建公私钥:</p><ul><li><p>id_rsa （私钥）</p></li><li><p>id_rsa.pub (公钥)</p></li></ul></li></ol><h1 id="2-上传公钥到服务器"><a href="#2-上传公钥到服务器" class="headerlink" title="2. 上传公钥到服务器"></a>2. 上传公钥到服务器</h1><ol><li><p>进入服务端.ssh目录下 <code>cd ~/.ssh</code></p></li><li><p>将客户端生成的id_rsa.pub 复制到 authorized_keys 里 <code>vim authorized_keys</code></p></li></ol><h1 id="3-测试免密登录"><a href="#3-测试免密登录" class="headerlink" title="3. 测试免密登录"></a>3. 测试免密登录</h1><p><code>ssh root@localhost</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Activiti——数据表介绍</title>
    <link href="/Activiti%E6%95%B0%E6%8D%AE%E8%A1%A8%E4%BB%8B%E7%BB%8D/"/>
    <url>/Activiti%E6%95%B0%E6%8D%AE%E8%A1%A8%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>Activiti 的表都以   ACT_   开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的 API 对应</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230202215607751.png" alt="image-20230202215607751"></p><h3 id="表的命名规则和作用"><a href="#表的命名规则和作用" class="headerlink" title="表的命名规则和作用"></a>表的命名规则和作用</h3><ul><li><strong>ACT_RE</strong> ：’RE’表示 repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。</li><li><strong>ACT_RU</strong>：’RU’表示 runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti 只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。</li><li><strong>ACT_HI</strong>：’HI’表示 history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。</li><li><strong>ACT_GE</strong> ： GE 表示 general。 通用数据， 用于不同场景下</li></ul><table><thead><tr><th><strong>表分类</strong></th><th><strong>表名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>一般数据</td><td></td><td></td></tr><tr><td></td><td>[ACT_GE_BYTEARRAY]</td><td>通用的流程定义和流程资源</td></tr><tr><td></td><td>[ACT_GE_PROPERTY]</td><td>系统相关属性</td></tr><tr><td>流程历史记录</td><td></td><td></td></tr><tr><td></td><td>[ACT_HI_ACTINST]</td><td>历史的流程实例</td></tr><tr><td></td><td>[ACT_HI_ATTACHMENT]</td><td>历史的流程附件</td></tr><tr><td></td><td>[ACT_HI_COMMENT]</td><td>历史的说明性信息</td></tr><tr><td></td><td>[ACT_HI_DETAIL]</td><td>历史的流程运行中的细节信息</td></tr><tr><td></td><td>[ACT_HI_IDENTITYLINK]</td><td>历史的流程运行过程中用户关系</td></tr><tr><td></td><td>[ACT_HI_PROCINST]</td><td>历史的流程实例</td></tr><tr><td></td><td>[ACT_HI_TASKINST]</td><td>历史的任务实例</td></tr><tr><td></td><td>[ACT_HI_VARINST]</td><td>历史的流程运行中的变量信息</td></tr><tr><td>流程定义表</td><td></td><td></td></tr><tr><td></td><td>[ACT_RE_DEPLOYMENT]</td><td>部署单元信息</td></tr><tr><td></td><td>[ACT_RE_MODEL]</td><td>模型信息</td></tr><tr><td></td><td>[ACT_RE_PROCDEF]</td><td>已部署的流程定义 -&gt; 同一个流程，部署一次增加一条记录</td></tr><tr><td>运行实例表</td><td></td><td></td></tr><tr><td></td><td>[ACT_RU_EVENT_SUBSCR]</td><td>运行时事件</td></tr><tr><td></td><td>[ACT_RU_EXECUTION]</td><td>运行时流程执行实例</td></tr><tr><td></td><td>[ACT_RU_IDENTITYLINK]</td><td>运行时用户关系信息，存储任务节点与参与者的相关信息</td></tr><tr><td></td><td>[ACT_RU_JOB]</td><td>运行时作业</td></tr><tr><td></td><td>[ACT_RU_TASK]</td><td>运行时任务</td></tr><tr><td></td><td>[ACT_RU_VARIABLE]</td><td>运行时变量表</td></tr></tbody></table><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230207214202834.png" alt="image-20230207214202834"></p><p>下面的数据是：一个流程，部署后，开启了两个assginee不同的流程实例：</p><ul><li>act_re_deployment：</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230207221224629.png" alt="image-20230207221224629"></p><ul><li>act_re_procdef：</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230207221402715.png" alt="image-20230207221402715"></p><ul><li>act_hi_procinst：</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230207221437355.png" alt="image-20230207221437355"></p><ul><li>act_hi_actinst：</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230207221609189.png" alt="image-20230207221609189"></p><ul><li>act_hi_taskinst：</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230207221658209.png" alt="image-20230207221658209"></p><ul><li>act_hi_varinst：</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230207221801474.png" alt="image-20230207221801474"></p><ul><li>act_hi_identitylink：</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230207221833964.png" alt="image-20230207221833964"></p><ul><li>act_ru_task：</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230207221951039.png" alt="image-20230207221951039"></p>]]></content>
    
    
    <categories>
      
      <category>Activiti</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activiti——基本操作</title>
    <link href="/activiti%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/activiti%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-流程定义"><a href="#1-流程定义" class="headerlink" title="1 流程定义"></a>1 流程定义</h1><ul><li><p>使用activiti流程建模工具(activity-designer)定义业务流程(.bpmn文件) 。</p></li><li><p>.bpmn文件就是业务流程定义文件，通过xml定义业务流程。</p></li><li><p>使用idea插件设置流程图， 设置流程中需要的节点，节点负责人。具体步骤参考：</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230128164658.png"></p><h1 id="2-流程定义部署"><a href="#2-流程定义部署" class="headerlink" title="2 流程定义部署"></a>2 流程定义部署</h1><ul><li>activiti部署业务流程定义（.bpmn文件）。即：将流程图的内容存储到数据库</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr;<br><br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngine;<br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngines;<br><span class="hljs-keyword">import</span> org.activiti.engine.RepositoryService;<br><span class="hljs-keyword">import</span> org.activiti.engine.repository.Deployment;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivitiDemo</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeployment</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">// 1. 创建ProcessEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>      <span class="hljs-comment">// 2. 获取RepositoryService</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br>      <span class="hljs-comment">// 3. 使用service进行流程的部署，定义流程名字，把bpmn部署到数据库中</span><br>        Deployment deploy = repositoryService.createDeployment()<br>                .name(<span class="hljs-string">&quot;话费报销&quot;</span>)<br>                .addClasspathResource(<span class="hljs-string">&quot;bpmn/phoneExpense.bpmn20.xml&quot;</span>)<br>                .deploy();<br>      <span class="hljs-comment">// 4. 输出部署信息</span><br>        System.out.println(<span class="hljs-string">&quot;流程部署id=&quot;</span>+deploy.getId());<br>        System.out.println(<span class="hljs-string">&quot;流程部署名字=&quot;</span>+deploy.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128210614102.png" alt="image-20230128210614102"></p><p>流程定义部署后操作activiti的3张表如下：</p><ul><li><p>act_re_deployment 流程定义部署表，每部署一次增加一条记录</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230128204308.png"></p></li><li><p>act_re_procdef 流程定义表，部署每个新的流程定义都会在这张表中增加一条记录。比如章三的话费报销是一条记录，李四的话费报销是一条记录。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128204451742.png" alt="image-20230128204451742"> <img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128204449359.png" alt="image-20230128204449359"></p></li><li><p>act_ge_bytearray 流程资源表</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128204546011.png" alt="image-20230128204546011"></p></li></ul><h1 id="3-启动流程实例"><a href="#3-启动流程实例" class="headerlink" title="3 启动流程实例"></a>3 启动流程实例</h1><p>启动一个流程实例表示开始一次业务流程的运行。</p><p>在员工请假流程定义部署完成后，如果张三要请假就可以启动一个流程实例，如果李四要请假也启动一个流程实例，两个流程的执行互相不影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStartProcess</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 1. 创建ProcessEngine</span><br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    <span class="hljs-comment">// 2. 获取RuntimeService</span><br>    RuntimeService runtimeService = processEngine.getRuntimeService();<br>    <span class="hljs-comment">// 3. 根据流程ID启动流程</span><br>    ProcessInstance instance = runtimeService.startProcessInstanceByKey(<span class="hljs-string">&quot;myProcess&quot;</span>);<br>    <span class="hljs-comment">// 4. 输出</span><br>    System.out.println(<span class="hljs-string">&quot;流程定义id=&quot;</span>+instance.getProcessDefinitionId());<br>    System.out.println(<span class="hljs-string">&quot;流程实例id=&quot;</span>+instance.getId());<br>    System.out.println(<span class="hljs-string">&quot;当前活动的id=&quot;</span>+instance.getActivityId());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128210529180.png" alt="image-20230128210529180"></p><p> 操作activiti的表如下：</p><p>​     act_hi_actinst 流程实例执行历史</p><p>​act_hi_identitylink 流程的参与用户历史信息</p><p>​act_hi_procinst 流程实例历史信息</p><p>​act_hi_taskinst 已经完成的任务信息</p><p>​act_ru_execution 流程执行信息</p><p>​act_ru_identitylink 流程的参与用户信息</p><p>​act_ru_task 当前代办的任务信息</p><h1 id="4-用户查询待办任务-Task"><a href="#4-用户查询待办任务-Task" class="headerlink" title="4 用户查询待办任务(Task)"></a>4 用户查询待办任务(Task)</h1><ul><li>因为现在系统的业务流程已经交给activiti管理，通过activiti就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些activiti帮我们管理了，而不需要开发人员自己编写在sql语句查询。</li></ul><p>查询自己所能处理的任务 </p><pre><code class="hljs">   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindPersonalTasks</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 1. 创建ProcessEngine</span><br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    <span class="hljs-comment">// 2. 获取taskService</span><br>    TaskService taskService = processEngine.getTaskService();<br>    <span class="hljs-comment">// 3. 根据流程key和任务负责人 查询任务</span><br>    List&lt;Task&gt; tasks = taskService.createTaskQuery()<br>            .processDefinitionKey(<span class="hljs-string">&quot;myProcess&quot;</span>)<br>            .taskAssignee(<span class="hljs-string">&quot;张三&quot;</span>)<br>            .list();<br>    <span class="hljs-comment">// 4. 输出</span><br>    tasks.forEach(task -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;流程实例id=&quot;</span>+task.getProcessInstanceId());<br>        System.out.println(<span class="hljs-string">&quot;任务id=&quot;</span>+task.getId());<br>        System.out.println(<span class="hljs-string">&quot;任务负责人=&quot;</span>+task.getAssignee());<br>        System.out.println(<span class="hljs-string">&quot;任务名称=&quot;</span>+task.getName());<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128210841640.png" alt="image-20230128210841640"></p><h1 id="5-用户处理任务"><a href="#5-用户处理任务" class="headerlink" title="5 用户处理任务"></a>5 用户处理任务</h1><p>用户查询待办任务后，就可以办理某个任务，如果这个任务办理完成还需要其它用户办理，比如采购单创建后由部门经理审核，这个过程也是由activiti帮我们完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCompleteTask</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 1. 创建ProcessEngine</span><br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    <span class="hljs-comment">// 2. 获取taskService</span><br>    TaskService taskService = processEngine.getTaskService();<br>    <span class="hljs-comment">// 3. 根据任务id完成任务</span><br>    taskService.complete(<span class="hljs-string">&quot;2505&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>操作activiti的表如下：</p><p>act_hi_taskinst:  已经完成的历史任务信息 -&gt; 插入新数据; 更新完成任务的结束时间</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128213152660.png" alt="image-20230128213152660"></p><p>act_ru_task：当前代办的任务信息 -&gt; 删除旧数据，插入新数据</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128213015838.png" alt="image-20230128213015838"></p><p>​       act_hi_identitylink: 流程的参与用户历史信息  -&gt; 插入新数据</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128213626199.png" alt="image-20230128213626199"></p><p>​  </p><p><strong>更加灵活的完成个人任务：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCompleteTask2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 1. 创建ProcessEngine</span><br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    <span class="hljs-comment">// 2. 获取taskService</span><br>    TaskService taskService = processEngine.getTaskService();<br>    <span class="hljs-comment">// 3. 如果可以确定是一个任务，可以直接通过singleResult获得，依次修改taskAssignee为直线经理，部门经理，财务人员</span><br>    Task task = taskService.createTaskQuery()<br>            .processDefinitionKey(<span class="hljs-string">&quot;myProcess&quot;</span>)<br>            .taskAssignee(<span class="hljs-string">&quot;财务人员&quot;</span>)<br>            .singleResult();<br>    <span class="hljs-comment">// 3. 根据任务id完成任务</span><br>    taskService.complete(task.getId());<br>    System.out.println(<span class="hljs-string">&quot;DONE!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>此时查看act_ru_task表，已经没有数据了，因为任务执行完了</p><p>查看act_hi_actinst，可以看到END_TIME都已经填充上了</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128231354324.png" alt="image-20230128231354324"></p><h1 id="6-流程结束"><a href="#6-流程结束" class="headerlink" title="6 流程结束"></a>6 流程结束</h1><p>当任务办理完成没有下一个任务结点了，这个流程实例就完成了。</p><h1 id="7-流程历史信息的查看"><a href="#7-流程历史信息的查看" class="headerlink" title="7. 流程历史信息的查看"></a>7. 流程历史信息的查看</h1><p>即使流程定义已经删除了，流程执行的历史信息通过前面的分析，依然保存在activiti的act_hi_*相关的表中。所以我们还是可以查询流程执行的历史信息，可以通过HistoryService来查看相关的历史记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findHistoryInfo</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//      获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取HistoryService</span><br>        HistoryService historyService = processEngine.getHistoryService();<br><span class="hljs-comment">//        获取 actinst表的查询对象</span><br>        HistoricActivityInstanceQuery instanceQuery = historyService.createHistoricActivityInstanceQuery();<br><span class="hljs-comment">//        查询 actinst表，条件：根据 InstanceId 查询</span><br><span class="hljs-comment">//        instanceQuery.processInstanceId(&quot;2501&quot;);</span><br><span class="hljs-comment">//        查询 actinst表，条件：根据 DefinitionId 查询</span><br>        instanceQuery.processDefinitionId(<span class="hljs-string">&quot;process-variable:3:c8b43296-a886-11ed-90d9-9ec8af959357&quot;</span>);<br><span class="hljs-comment">//        增加排序操作,orderByHistoricActivityInstanceStartTime 根据开始时间排序 asc 升序</span><br>        instanceQuery.orderByHistoricActivityInstanceStartTime().asc();<br><span class="hljs-comment">//        查询所有内容</span><br>        List&lt;HistoricActivityInstance&gt; activityInstanceList = instanceQuery.list();<br><span class="hljs-comment">//        输出</span><br>        <span class="hljs-keyword">for</span> (HistoricActivityInstance hi : activityInstanceList) &#123;<br>            System.out.println(hi.getActivityId());<br>            System.out.println(hi.getActivityName());<br>            System.out.println(hi.getProcessDefinitionId());<br>            System.out.println(hi.getProcessInstanceId());<br>            System.out.println(<span class="hljs-string">&quot;&lt;==========================&gt;&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230209233245014.png" alt="image-20230209233245014"></p><h1 id="8-实战使用"><a href="#8-实战使用" class="headerlink" title="8 实战使用"></a>8 实战使用</h1><p><strong>准备工作：</strong></p><ol><li><p>定义BPMN文件</p></li><li><p>myActProcessDefinitionRegister注册entity对应的工作流信息：entityName, definitionKey，name</p></li><li><p>EmActProcessStatus: entity上存储的taskDefinitionKey，可在这张表查询到对应的中文翻译</p><ul><li><p>processRegisterId</p></li><li><p>taskDefinitionKey</p></li><li><p>name</p></li></ul></li><li><p>entity上冗余了工作流字段：</p><ul><li><p>task1Assignee，taskAssignee2:   任务受理人，根据bpmn文件定义的task数量定义，每个task对应一个受理人</p></li><li><p>currentTaskDefinitionKey:  当前记录的流程状态，即task的标识</p></li></ul></li></ol><p><strong>流程：</strong></p><ol><li>新增entity，afterSaveTrigger发送mq启动流程实例 <ul><li>definitionKey: 根据entityName查询emActProcessDefinitionRegister</li><li>businessKey: entityId</li><li>variables： entity复写自己的</li></ul></li><li>查看认领任务：根据前端传过来的loginName, processDefinitionKeyList查看任务列表</li><li>候选人认领任务（如果有callBack,调用callback）: taskService.claim(task.getId(), claimTaskForm.getUserLoginName());</li><li>查看待办任务：根据前端传过来的loginName, processDefinitionKeyList查看任务列表</li><li>完成任务：completeTask</li><li>执行完成任务回调completeFeedback， 比如：当前流程的填充审批完成时间</li></ol>]]></content>
    
    
    <categories>
      
      <category>Activiti</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activiti BPMN visualizer 的安装和使用</title>
    <link href="/Activiti-BPMN-visualizer-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/Activiti-BPMN-visualizer-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h1><p>插件里搜索Activiti BPMN visualizer安装</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230128163406.png"></p><h1 id="2-画一个流程图"><a href="#2-画一个流程图" class="headerlink" title="2 画一个流程图"></a>2 画一个流程图</h1><h2 id="1-右键生成一个bpmn20-xml文件"><a href="#1-右键生成一个bpmn20-xml文件" class="headerlink" title="1. 右键生成一个bpmn20.xml文件"></a>1. 右键生成一个bpmn20.xml文件</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230128163554.png"></p><h2 id="2-在文件的任意位置点击右键：view-bpmn-Activiti-Diagram"><a href="#2-在文件的任意位置点击右键：view-bpmn-Activiti-Diagram" class="headerlink" title="2. 在文件的任意位置点击右键：view bpmn(Activiti)Diagram"></a>2. 在文件的任意位置点击右键：view bpmn(Activiti)Diagram</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/202301281638479.png"></p><h2 id="3-打开可视化编辑器，"><a href="#3-打开可视化编辑器，" class="headerlink" title="3. 打开可视化编辑器，"></a>3. 打开可视化编辑器，</h2><ol><li>右键start events –&gt;start event画一个开始事件。</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230128163950.png"></p><ol start="2"><li><p>用户任务</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230128164045.png"></p></li><li><p>添加结束</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230128164125.png"></p></li><li><p>连线</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230128164453.png"></p></li><li><p>查看更新后的xml文件</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230128164612.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Activiti</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jenkins集成部署环境构建</title>
    <link href="/jenkins%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/"/>
    <url>/jenkins%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>更新机制是指项目如何进行更新，主要有两种方式：一种是自动推送，另外一种是手动拉取。前者用于开发环境、后者可以用于所有环境</p><h1 id="1-手动拉取"><a href="#1-手动拉取" class="headerlink" title="1. 手动拉取"></a>1. 手动拉取</h1><p>拉取更新流程：</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230126125309.png" style="zoom:40%;" /><ol><li>sudo -i 输入密码，进入root目录</li><li>上述流程由 deploy.sh 脚本实现：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash -e</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;`dirname <span class="hljs-variable">$0</span>`&quot;</span><br>. ./pom.sh<br><br><span class="hljs-comment">#1. download war, ready env</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deploy time: <span class="hljs-variable">$work_time</span>&quot;</span><br>mkdir -p war/<br>war=war/<span class="hljs-variable">$pom_a</span>-<span class="hljs-variable">$pom_v</span>.war<br>download_path=<span class="hljs-string">&quot;<span class="hljs-variable">$nexus_redirect</span>?r=<span class="hljs-variable">$pom_r</span>&amp;g=<span class="hljs-variable">$pom_g</span>&amp;a=<span class="hljs-variable">$pom_a</span>&amp;v=<span class="hljs-variable">$pom_v</span>&amp;e=war&quot;</span><br>wget  <span class="hljs-variable">$download_path</span> -O <span class="hljs-variable">$war</span><br><br>deploy_war<br></code></pre></td></tr></table></figure><p>pom.sh 脚本内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml">#!/bin/bash -e<br>. ../bin/env-set.sh<br><br>pom_g=org.example<br>pom_a=test-jenkins<br>pom_v=1.0-SNAPSHOT<br>pom_r=snapshots<br><br><br>deploy_war() &#123;<br>        target_d=war/$&#123;pom_a&#125;-$&#123;pom_v&#125;-$work_time<br>        target_dir=`pwd`/$target_d<br>        if [ ! -f &quot;$war&quot; ]; then<br>                echo &quot;war not exist: $war&quot;<br>                exit 1<br>        fi<br>        unzip -q $war -d $target_dir<br>        rm -rf appwar<br>        ln -sf $target_d appwar<br><br>        ./tomcat.sh stop<br><br>        target_ln=`pwd`/appwar<br>        echo &#x27;<span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">&quot;&#x27;$target_ln&#x27;&quot;</span> <span class="hljs-attr">allowLinking</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Context</span>&gt;</span>&#x27; &gt; conf/Catalina/localhost/ROOT.xml<br>        ./tomcat.sh start<br>&#125;<br></code></pre></td></tr></table></figure><p>tomcat.sh 内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;`whoami`&quot;</span> != <span class="hljs-string">&quot;root&quot;</span> ];<span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error: You must be apps to run this command.&quot;</span><br><span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;`dirname <span class="hljs-variable">$0</span>`&quot;</span><br>. ../bin/env-set.sh<br>. ./pom.sh<br><br><span class="hljs-built_in">export</span> CATALINA_BASE=<span class="hljs-string">&quot;`pwd`&quot;</span><br>tomcat <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;pom_a&#125;</span>-<span class="hljs-variable">$&#123;pom_v&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><p> env-set.sh内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash -e</span><br><span class="hljs-comment">#当前时间</span><br><span class="hljs-built_in">export</span> now_time=$(date +%Y-%m-%d_%H-%M-%S)<br><span class="hljs-comment">#整个期间的开始时间</span><br>[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$work_time</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">export</span> work_time=$(date +%Y-%m-%d_%H-%M-%S)<br><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$g_env_set</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">unset</span> JRE_HOME JAVA_HOME CLASSPATH<br><span class="hljs-built_in">export</span> nexus_redirect=<span class="hljs-string">&quot;http://localhost:8081/nexus/service/local/artifact/maven/redirect&quot;</span><br><span class="hljs-built_in">export</span> data_home=<span class="hljs-string">&quot;/var/root/svr&quot;</span><br><span class="hljs-built_in">export</span> server_home=<span class="hljs-string">&quot;<span class="hljs-variable">$data_home</span>/services&quot;</span><br><span class="hljs-built_in">export</span> JAVA_HOME=<span class="hljs-string">&quot;<span class="hljs-variable">$data_home</span>/jdk&quot;</span><br><span class="hljs-built_in">export</span> CATALINA_HOME=<span class="hljs-string">&quot;<span class="hljs-variable">$data_home</span>/apache-tomcat&quot;</span><br><span class="hljs-built_in">export</span> CATALINA_BASE=<span class="hljs-string">&quot;<span class="hljs-variable">$CATALINA_HOME</span>&quot;</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> g_env_set=<span class="hljs-literal">true</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment">#能够输入2个grep的字符串用来查找</span><br><span class="hljs-function"><span class="hljs-title">proc_find</span></span>() &#123;<br>        <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$#</span>&quot;</span> = 2 ]; <span class="hljs-keyword">then</span><br>                ps -eo pid,cmd|grep -v <span class="hljs-string">&#x27;cmd\|grep&#x27;</span>|grep <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>|grep <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span>|sed <span class="hljs-string">&#x27;s/^ *\(.*\) *$/\1/&#x27;</span><br>        <span class="hljs-keyword">else</span><br>                ps -eo pid,cmd|grep -v <span class="hljs-string">&#x27;cmd\|grep&#x27;</span>|grep <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>|sed <span class="hljs-string">&#x27;s/^ *\(.*\) *$/\1/&#x27;</span><br>        <span class="hljs-keyword">fi</span><br>&#125;<br><span class="hljs-comment">#能够输入2个grep的字符串用来查找</span><br><span class="hljs-function"><span class="hljs-title">proc_pid</span></span>() &#123;<br>        proc_find <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span> | cut -d <span class="hljs-string">&#x27; &#x27;</span> -f1<br>&#125;<br><span class="hljs-comment">#$1: 要重试的次数，超过此次数后使用kill -9</span><br><span class="hljs-comment">#$2: 能够输入2个grep的字符串用来查找</span><br><span class="hljs-function"><span class="hljs-title">proc_kill</span></span>() &#123;<br>        grep_args=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;@:2&#125;</span>&quot;</span><br>        <span class="hljs-keyword">for</span> ((i=1;i&lt;=<span class="hljs-variable">$1</span>;++i))<br>        <span class="hljs-keyword">do</span><br>                pids=(`proc_pid <span class="hljs-string">&quot;<span class="hljs-variable">$grep_args</span>&quot;</span>`)<br>                [ <span class="hljs-variable">$&#123;#pids[@]&#125;</span> = 0 ] &amp;&amp; <span class="hljs-built_in">return</span> 0<br><br>                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;n=<span class="hljs-variable">$i</span> kill <span class="hljs-variable">$&#123;pids[@]&#125;</span>&quot;</span><br>                <span class="hljs-built_in">kill</span> <span class="hljs-variable">$&#123;pids[@]&#125;</span><br>                sleep 1s<br>        <span class="hljs-keyword">done</span><br>        pids=(`proc_pid <span class="hljs-string">&quot;<span class="hljs-variable">$grep_args</span>&quot;</span>`)<br>        [ <span class="hljs-variable">$&#123;#pids[@]&#125;</span> = 0 ] || <span class="hljs-built_in">kill</span> -9 <span class="hljs-variable">$&#123;pids[@]&#125;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">tomcat_start0</span></span>() &#123;<br><br>[ <span class="hljs-string">&quot;<span class="hljs-variable">$JAVA_OPTS</span>&quot;</span> = <span class="hljs-string">&quot;&quot;</span> ] &amp;&amp; <span class="hljs-built_in">export</span> JAVA_OPTS=<span class="hljs-string">&quot;-server -XX:MaxPermSize=128m -Xms512m -Xmx512m&quot;</span><br>[ <span class="hljs-string">&quot;`echo &quot;</span><span class="hljs-variable">$JAVA_OPTS</span><span class="hljs-string">&quot;|grep &#x27;\-Djava.security.egd=&#x27;`&quot;</span> = <span class="hljs-string">&quot;&quot;</span> ] &amp;&amp; <span class="hljs-built_in">export</span> JAVA_OPTS=<span class="hljs-string">&quot;<span class="hljs-variable">$JAVA_OPTS</span> -Djava.security.egd=file:/dev/./urandom&quot;</span><br><span class="hljs-comment">#防止X11导致awt在X11关闭后异常</span><br><span class="hljs-built_in">export</span> JAVA_OPTS=<span class="hljs-string">&quot;-Djava.awt.headless=true <span class="hljs-variable">$JAVA_OPTS</span> -<span class="hljs-variable">$grep_server</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;START <span class="hljs-variable">$grep_server</span>: JAVA_OPTS=<span class="hljs-variable">$JAVA_OPTS</span>&quot;</span><br><span class="hljs-string">&quot;<span class="hljs-variable">$CATALINA_HOME</span>&quot;</span>/bin/startup.sh<br>&#125;<br><span class="hljs-function"><span class="hljs-title">tomcat_stop0</span></span>() &#123;<br>proc_kill 3 <span class="hljs-string">&quot;<span class="hljs-variable">$grep_server</span>&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">tomcat_status0</span></span>() &#123;<br>tmp=`proc_find <span class="hljs-string">&quot;<span class="hljs-variable">$grep_server</span>&quot;</span>`<br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$tmp</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$grep_server</span> stopped.&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$grep_server</span> running: <span class="hljs-variable">$tmp</span>&quot;</span><br><span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">tomcat</span></span>() &#123;<br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> = <span class="hljs-string">&quot;&quot;</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;Usage: %s &#123;start|stop|restart|status&#125; ????\n&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$prog</span>&quot;</span><br><span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> = <span class="hljs-string">&quot;&quot;</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;java -Dmykey=$&#123;mykey&#125; miss: mykey&#x27;</span><br><span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$CATALINA_BASE</span>&quot;</span> = <span class="hljs-string">&quot;&quot;</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;miss: $CATALINA_BASE=&#x27;</span><br><span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$CATALINA_BASE</span>&quot;</span><br><span class="hljs-built_in">export</span> grep_server=<span class="hljs-string">&quot;Dmykey=<span class="hljs-variable">$&#123;2&#125;</span>x&quot;</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br>start)<br>tmp=`proc_find <span class="hljs-string">&quot;<span class="hljs-variable">$grep_server</span>&quot;</span>`<br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$tmp</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>tomcat_start0<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$grep_server</span> already running: <span class="hljs-variable">$tmp</span>&quot;</span><br><span class="hljs-keyword">fi</span><br>sleep 1s<br><span class="hljs-comment">#tomcat_status0</span><br>;;<br>stop)<br>tomcat_stop0<br>tomcat_status0<br>;;<br>status)<br>tomcat_status0<br>;;<br>restart)<br>tomcat_stop0<br>tomcat_start0<br>sleep 1s<br>tomcat_status0<br>;;<br>*)<br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;Usage: %s &#123;start|stop|restart|status&#125; ????\n&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$prog</span>&quot;</span><br><span class="hljs-built_in">exit</span> 1<br>;;<br><span class="hljs-keyword">esac</span><br>&#125;<br></code></pre></td></tr></table></figure><p>项目打包完成后，运行<code>deploy.sh</code>完成更新</p><p><strong>代码地址</strong>：<a href="https://github.com/pyr9/jenkins-script">pyr9&#x2F;jenkins-script (github.com)</a></p><h1 id="2-自动推送"><a href="#2-自动推送" class="headerlink" title="2 自动推送"></a>2 自动推送</h1><p>自动推送方式采用在 jenkins 构建完成之后，执行远程 sh 脚本用于下载本次构建 WAR 包，在自动部署重启。</p><h3 id="1-jenkins-授予可读权限"><a href="#1-jenkins-授予可读权限" class="headerlink" title="1. jenkins 授予可读权限"></a>1. jenkins 授予可读权限</h3><p>不配置会403</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230206160008255.png" alt="image-20230206160008255"></p><h3 id="2-jenkins-配置执行脚本"><a href="#2-jenkins-配置执行脚本" class="headerlink" title="2. jenkins 配置执行脚本"></a>2. jenkins 配置执行脚本</h3><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230206154056839.png" alt="image-20230206154056839"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">BUILD_ID=dontKillMe<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$BUILD_ID</span><br>ssh root@localhost BUILD_URL=<span class="hljs-variable">$BUILD_URL</span> /var/root/svr/services/test-jenkins-demo/jenkins.sh<br></code></pre></td></tr></table></figure><p> jenkins.sh内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash -e</span><br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;`dirname <span class="hljs-variable">$0</span>`&quot;</span><br>. ./pom.sh<br><br><br><span class="hljs-comment">#1. download war, ready env</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deploy time: <span class="hljs-variable">$work_time</span>&quot;</span><br>mkdir -p war/<br><span class="hljs-comment"># 配置下载存放目录</span><br>war=war/<span class="hljs-variable">$pom_a</span>-<span class="hljs-variable">$pom_v</span>.war<br><span class="hljs-comment"># 基于远程传过来的 BUILD_URL下载本次构建</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BUILD_URL&#125;</span><span class="hljs-variable">$&#123;pom_g&#125;</span>\$<span class="hljs-variable">$&#123;pom_a&#125;</span>/artifact/<span class="hljs-variable">$pom_g</span>/<span class="hljs-variable">$pom_a</span>/<span class="hljs-variable">$pom_v</span>/<span class="hljs-variable">$pom_a</span>-<span class="hljs-variable">$pom_v</span>.war&quot;</span><br>/opt/homebrew/bin/wget  <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BUILD_URL&#125;</span><span class="hljs-variable">$&#123;pom_g&#125;</span>\$<span class="hljs-variable">$&#123;pom_a&#125;</span>/artifact/<span class="hljs-variable">$pom_g</span>/<span class="hljs-variable">$pom_a</span>/<span class="hljs-variable">$pom_v</span>/<span class="hljs-variable">$pom_a</span>-<span class="hljs-variable">$pom_v</span>.war&quot;</span> -O <span class="hljs-variable">$war</span><br><span class="hljs-comment"># 执行部署函数</span><br>deploy_war<br></code></pre></td></tr></table></figure><h3 id="3-ssh设置免密登录"><a href="#3-ssh设置免密登录" class="headerlink" title="3. ssh设置免密登录"></a>3. ssh设置免密登录</h3><p>（添加公钥到服务器）<a href="https://pyr9.github.io/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/">SSH免密登录 - 楼上有只喵 (pyr9.github.io)</a></p><p>注意事项⚠️：</p><ol><li>上面如果使用wget 而不是&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;wget 会出现  404 Not Found</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目部署到tomcat的三种方式</title>
    <link href="/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0tomcat/"/>
    <url>/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0tomcat/</url>
    
    <content type="html"><![CDATA[<h1 id="1-项目直接放入-webapps-目录中"><a href="#1-项目直接放入-webapps-目录中" class="headerlink" title="1.项目直接放入 webapps 目录中"></a>1.<strong>项目直接放入 webapps 目录中</strong></h1><ol><li>把项目打包，放入webapps目录下</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/202301242001681.png"></p><ol start="2"><li><p>依次运行tomcat 的bin目录下<code>shutdown.sh</code>,<code>startup.sh</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230124200306.png"></p></li><li><p>在浏览器输入：<a href="http://localhost:8080/%E9%A1%B9%E7%9B%AE%E5%90%8D%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E5%85%A5%E5%88%B0%E9%A1%B9%E7%9B%AE%E7%9A%84index%E9%A1%B5%E9%9D%A2">http://localhost:8080/项目名，就可以进入到项目的index页面</a></p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230124200912.png"  /><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230124200828.png"></p></li></ol><h1 id="2-修改-conf-x2F-server-xml-文件"><a href="#2-修改-conf-x2F-server-xml-文件" class="headerlink" title="2 修改 conf&#x2F;server.xml 文件"></a>2 <strong>修改 conf&#x2F;server.xml 文件</strong></h1><p>进入tomcat下conf&#x2F;server.xml，在<code>&lt;Host&gt; &lt;/Host&gt;</code>标签之间输入项目配置信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/test01&quot;</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">&quot;/Users/xxx/test-jenkins-1.0-RELEASE&quot;</span> <span class="hljs-attr">reloadable</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>path</strong>:浏览器访问时的路径名</p></li><li><p><strong>docBase</strong>:web项目的WebRoot所在的路径，注意是WebRoot的路径，不是项目的路径，其实也<strong>就是编译后的项目路径</strong>（解压后的j ar包路径）。</p></li><li><p><em><strong>reloadble</strong>:设定项目有改动时，tomcat是否重新加载该项目</em></p></li></ul><h1 id="3-conf-x2F-Catalina"><a href="#3-conf-x2F-Catalina" class="headerlink" title="3 conf&#x2F;Catalina"></a>3 <strong>conf&#x2F;Catalina</strong></h1><ol><li><p>入到 apache-tomcat-7.0.52\conf\Catalina\localhost 目录，新建一个 <code>ROOT.xml</code> 文件</p></li><li><p>在那个新建的 xml 文件中，增加下面配置语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">&quot;/Users/panyurou/test-jenkins-1.0-RELEASE&quot;</span> <span class="hljs-attr">reloadable</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在浏览器输入路径：localhost:8080</p></li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230126154643.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>版本快速迭代流程设计</title>
    <link href="/%E7%89%88%E6%9C%AC%E5%BF%AB%E9%80%9F%E8%BF%AD%E4%BB%A3%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    <url>/%E7%89%88%E6%9C%AC%E5%BF%AB%E9%80%9F%E8%BF%AD%E4%BB%A3%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-整体流程设计"><a href="#1-整体流程设计" class="headerlink" title="1 整体流程设计"></a>1 整体流程设计</h1><ol><li>不同的开发提交当天的变动到统一的代码仓库</li><li>jenkins集成部署到开发环境</li><li>测试手动从jenkins的test仓库拉取打好的jar包，部署到测试环境，进行测试</li><li>测试完成后由运维从jenkins的release仓库拉取打好的jar包，部署到生产环境</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230124123255413.png" alt="image-20230124123255413"></p><h1 id="2-发布窗口机制"><a href="#2-发布窗口机制" class="headerlink" title="2. 发布窗口机制"></a>2. 发布窗口机制</h1><p>上述发布流程是比较重的，我们不可能每天走一遍。可以设置一个固定的发布时间，一般设置在周四。</p><ul><li><p>比如周四下午四点，如果这个点还没有来得及实现或者完成测试，则需要等到下个窗口才能发布。</p></li><li><p>这样的目的：是为了让团队的每个人有一个清晰的时间观念，知道什么时候干什么事，避免手忙脚乱脚乱的随意发布。</p></li></ul><h1 id="3-发布计划"><a href="#3-发布计划" class="headerlink" title="3. 发布计划"></a>3. 发布计划</h1><ul><li><p>很多时候我们的需求之间是有联系的，因此我们需要提前计划好下个窗口能上线的需求，避免A需求上线时，他所依赖的B需求不能上线。</p></li><li><p>中间随意添加需求，会使发布变的困难。</p></li></ul><h1 id="4-实施计划"><a href="#4-实施计划" class="headerlink" title="4 实施计划"></a>4 实施计划</h1><p>除了发布计划，我们需要有实施说明，比如：需要更新那些sql脚本，修改哪些配置文件</p><h1 id="5-时间节点"><a href="#5-时间节点" class="headerlink" title="5 时间节点"></a>5 时间节点</h1><p>整个过程涉及团队协作，只要有一方延误，就会造成其他方等待或者工作推迟发生。为避免这种情况我们需要设计精细的时间节点如下：</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230128200518146.png" alt="image-20230128200518146" style="zoom:50%;" />]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mac下启动tomcat</title>
    <link href="/mac%E4%B8%8B%E5%90%AF%E5%8A%A8tomcat/"/>
    <url>/mac%E4%B8%8B%E5%90%AF%E5%8A%A8tomcat/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><p>登录Apache Tomcat官网，地址 <a href="http://tomcat.apache.org/">http://tomcat.apache.org</a> ，左边的Download，点击选择需要下载的版本 Tomcat8</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230115204748.png"></p><h2 id="2-启动"><a href="#2-启动" class="headerlink" title="2 启动"></a>2 启动</h2><p>下载下来解压，进入bin目录，运行<code>./startup.sh</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230115205133.png"></p><p>停止运行 <code>./shutdown.sh</code></p><h1 id="3-修改默认端口号"><a href="#3-修改默认端口号" class="headerlink" title="3 修改默认端口号"></a>3 修改默认端口号</h1><p>不修改的话，可以直接访问8080端口，我这里修改成了8888</p><ol><li>进入conf 目录 <code>cd conf</code></li><li>修改server.xml  <code>vim server.xml</code></li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230115205500.png"></p><h1 id="4-设置用户信息"><a href="#4-设置用户信息" class="headerlink" title="4 设置用户信息"></a>4 设置用户信息</h1><p>如果需要manager App，还需要增加用户名和密码</p><ol><li><p>进入conf 目录 <code>cd conf</code></p></li><li><p>修改server.xml  <code>vim tomcat-users.xml</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230115205918.png"></p></li></ol><h1 id="5-访问-8888端口"><a href="#5-访问-8888端口" class="headerlink" title="5 访问 8888端口"></a>5 访问 8888端口</h1><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230115210632.png"></p>]]></content>
    
    
    <categories>
      
      <category>tomcat</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nexus私服搭建与核心功能</title>
    <link href="/nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"/>
    <url>/nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="1-私服是什么？"><a href="#1-私服是什么？" class="headerlink" title="1. 私服是什么？"></a>1. 私服是什么？</h1><p>私服是一个特殊的远程仓库，它是架设在局域网内的仓库服务。私服代理广域网上的远程仓库，供局域网内的Maven用户使用。</p><p>当Maven需要下载构建的使用，它先从私服请求，如果私服上没有的话，则从外部的远程仓库下载，然后缓存在私服上，再为Maven的下载请求提供服务。</p><p><strong>使用私服的好处</strong></p><ul><li>节省自己的外网带宽：大量的对于外部远程仓库的重复请求会消耗很大的带宽</li><li>加速Maven的构建：不停的请求外部仓库无疑是比较耗时的， 但Maven的一些内部机制（如快照检测）要求Maven在执行构建的时候不停地检查远程仓库的数据。因此当配置了很多远程仓库时，构建的速度会被大大降低。</li><li>部署第三方构件：当某个构件无法从外部远程仓库下载。如Oracle的JDBC驱动由于版权原因不能发布到外网的中心仓库，建立私服之后便可以将这些构件部署到本地私服中，供内部的Maven项目使用。</li><li>提高稳定行，增强控制。Maven构建搞定依赖于远程仓库，因此，当Internet不稳定的时候，Maven构建也会变的不稳定，甚至无法构建。使用私服后即使暂时没有Internet连接Maven也可以正常运行，因为私服中缓存了大量的构件。此外一些私服软件（如：Nexus）还提供了很多额外的功能，如权限管理，RELEASE&#x2F;SNAPSHOT区分等，管理员可以对仓库进行一些更高级的控制。</li><li>降低中央仓库的负荷。数百万的请求，存储数T的数据，需要相相当大的财力。使用私服可以避免很多对中央仓库的重复请求。</li></ul><h1 id="2-nexus-是什么？"><a href="#2-nexus-是什么？" class="headerlink" title="2 nexus 是什么？"></a>2 nexus 是什么？</h1><p>Nexus 是 Sonatype 公司发布的一款仓库（Repository）管理软件，常用来搭建 Maven 私服，所以也有人将 Nexus 称为“Maven仓库管理器”。</p><p>Nexus 开源版具有以下特性：</p><ul><li>占用内存小（28 M 左右）</li><li>具有基于 ExtJs 得操作界面，用户体验较好</li><li>使用基于 Restlet 的完全 REST API</li><li>支持代理仓库、宿主仓库和仓库组</li><li>基于文件系统，不需要依赖数据库</li><li>支持仓库索引以及搜索</li><li>支持在界面上上传构件</li><li>安全控制</li></ul><h1 id="3-nexus安装"><a href="#3-nexus安装" class="headerlink" title="3 nexus安装"></a>3 nexus安装</h1><ol><li><p>进入<a href="https://help.sonatype.com/repomanager2">Repository Manager 2 (sonatype.com)</a>，选择对应的版本进行下载</p></li><li><p>下载解压后，进入bin目录，运行 <code>./nexus start</code></p></li><li><p>访问<a href="http://localhost:8081/nexus">http://localhost:8081/nexus</a></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230116212514.png"></p></li></ol><p>注：nexus启动失败，查看报错日志（nexus-2.15.1-02&#x2F;logs&#x2F;wrapper.log）</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230116212959.png"></p><p>修复：将javax.activation-1.2.0.jar 和jaxb-api-2.3.0.jar包放到nexus的lib下</p><p>4  登陆nexus，nexus2 默认用户名和密码是<code>admin</code> and <code>admin123</code> .不确定的可以查看官方文档<a href="https://help.sonatype.com/repomanager2/installing-and-running/running">Running (sonatype.com)</a></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230116215507.png"></p><ol start="5"><li><p>查看仓库</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230116220006.png"></p></li></ol><p>​       如果私服下载不到，就会去远端仓库下载，远端仓库的下载路径就是Central配置的地址，这里我修改成阿里镜像地址</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230117095523.png"></p><h1 id="4-配置从nexus下载依赖"><a href="#4-配置从nexus下载依赖" class="headerlink" title="4 配置从nexus下载依赖"></a>4 配置从nexus下载依赖</h1><ol><li>pom.xml里配置仓库，仓库地址就是nexus的public Repositories的地址，如果有多个项目可以直接配到setting.xml中</li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;repositories&gt;<br>&lt;repository&gt;<br>&lt;id&gt;nexus-repository&lt;/id&gt;<br>&lt;name&gt;nexus repository&lt;/name&gt;<br>&lt;url&gt;http:<span class="hljs-comment">//localhost:8081/nexus/content/groups/public/&lt;/url&gt;</span><br>&lt;/repository&gt;<br>&lt;/repositories&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>测试</p><p>删除项目已有的依赖，重新compile项目，可以看到是从nexus去下载的依赖，我这里是测试的junit4</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230117100714.png"></p></li></ol><p>​      此时进入public仓库，可以看到私服里已经多了junit</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230117100859.png"></p><h1 id="5-配置发布到nexus"><a href="#5-配置发布到nexus" class="headerlink" title="5 配置发布到nexus"></a>5 配置发布到nexus</h1><ol><li>修改pom.xml，配置发布版本和快照版本的仓库地址</li></ol>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>release-repository<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>release repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://localhost:8081/nexus/content/repositories/releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>snapshots-repository<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>snapshots repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://localhost:8081/nexus/content/repositories/snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>修改setting.xml，配置服务用户名和密码（上传到私服需要有权限）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>release-repository<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>snapshots-repository<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>部署项目</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230117111441.png"></p></li></ol><p>​        由于我的项目是快照版本（pom.xm配置的<version>1.0-SNAPSHOT</version>），所以上传到了快照仓库里如果需要上传到发               布仓库里修改pom.xml</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/202301171117149.png"></p><p>可以看到目前项目上传到了release仓库</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230117113859.png"></p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jenkins之war包部署</title>
    <link href="/jekins%E6%94%AFwar%E5%8C%85%E9%83%A8%E7%BD%B2/"/>
    <url>/jekins%E6%94%AFwar%E5%8C%85%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-插件安装"><a href="#1-插件安装" class="headerlink" title="1. 插件安装"></a>1. 插件安装</h1><ul><li><p>Maven Integration</p></li><li><p>Pipeline Maven Integration</p></li><li><p>Deploy to container</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230115200509.png"></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230115200537.png"></p><h1 id="2-新建任务"><a href="#2-新建任务" class="headerlink" title="2. 新建任务"></a>2. 新建任务</h1><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/202301152009848.png"></p><h1 id="3-源码配置"><a href="#3-源码配置" class="headerlink" title="3 源码配置"></a>3 源码配置</h1><ul><li>Credentials 需要选择在用户列表，配置了该仓库ssh key的用户</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230115201137.png"></p><h1 id="4-构建后操作"><a href="#4-构建后操作" class="headerlink" title="4 构建后操作"></a>4 构建后操作</h1><h2 id="4-1-部署到服务器"><a href="#4-1-部署到服务器" class="headerlink" title="4.1 部署到服务器"></a>4.1 部署到服务器</h2><p>构建后，部署war包到指定服务器，我这里是部署在了本地的tomcat服务上</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/202301152014790.png"></p><p>注意：</p><ul><li><p>war文件地址，如果不在当前项目的target下，需要写成类似 <code>**/target/*.war</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230115202448.png"></p></li></ul><h2 id="4-2-上传到私服"><a href="#4-2-上传到私服" class="headerlink" title="4.2 上传到私服"></a>4.2 上传到私服</h2><p>我这里是上传到了nexus上</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230122205100.png"></p><p>对英需要修改setting.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="5-构建项目"><a href="#5-构建项目" class="headerlink" title="5  构建项目"></a>5  构建项目</h1><p>如果构建失败，可以在控制台查看报错信息</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230115202724.png"></p><h1 id="6-启动tomcat"><a href="#6-启动tomcat" class="headerlink" title="6 启动tomcat"></a>6 启动tomcat</h1><p>可以查看已经部署成功的服务了</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/202301152016375.png"></p><h1 id="7-登陆nexus"><a href="#7-登陆nexus" class="headerlink" title="7. 登陆nexus"></a>7. 登陆nexus</h1><p>可以看到war包已经上传到了nexus</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/202301222054195.png"></p>]]></content>
    
    
    <categories>
      
      <category>jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA解决resources资源找不到</title>
    <link href="/IDEA%E8%A7%A3%E5%86%B3resources%E8%B5%84%E6%BA%90%E6%89%BE%E4%B8%8D%E5%88%B0/"/>
    <url>/IDEA%E8%A7%A3%E5%86%B3resources%E8%B5%84%E6%BA%90%E6%89%BE%E4%B8%8D%E5%88%B0/</url>
    
    <content type="html"><![CDATA[<p>pom中删除<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code>。加了这个pom不会处理resources目录</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/202301121549744.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac下安装jenkins</title>
    <link href="/Mac%E4%B8%8B%E5%AE%89%E8%A3%85jekins/"/>
    <url>/Mac%E4%B8%8B%E5%AE%89%E8%A3%85jekins/</url>
    
    <content type="html"><![CDATA[<h1 id="1-可持续化集成CI"><a href="#1-可持续化集成CI" class="headerlink" title="1. 可持续化集成CI"></a>1. 可持续化集成CI</h1><p>​      持续集成即CI（Continuous integration）是一种软件开发实践,可以让团队在持续的基础上不断收到反馈并进行改进，不必等到开发周期后期才寻找缺陷。持续集成要点：</p><ul><li>统一的代码库 git</li><li>统一的依赖包管理 nexus</li><li>测试自动化</li><li>构建全自动化 maven</li><li>部署自动化</li><li>可追踪的集成记录 ：某一次有问题，可以找到上次集成。或者上上次集成，然后代码回滚</li></ul><p>持续集成的流程：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230108202610.png"></p><h1 id="2-jenkins概述"><a href="#2-jenkins概述" class="headerlink" title="2 jenkins概述"></a>2 jenkins概述</h1><p>jenkins就是为了满足上述持续集成的要点而设计的一款工具，主体框架是采用java开发，实质内部功能都是通过插件实现，极大程度提高了系统的扩展性。</p><p>其不仅可以满足java系统的集成，也可以实现PHP等语言的集成发布。</p><p>通过pipeline插件，用户可以随自己需要定制集成流程。</p><h1 id="3-mac-下安装-jenkins"><a href="#3-mac-下安装-jenkins" class="headerlink" title="3 mac 下安装 jenkins"></a>3 mac 下安装 jenkins</h1><p>用brew 安装</p><p><code> brew install jenkins</code></p><p>启动jenkins</p><p><code>brew services start jenkins</code></p><p>停止jenkins</p><p><code> brew services stop jenkins</code></p><h1 id="4-修改jenkins默认端口配置"><a href="#4-修改jenkins默认端口配置" class="headerlink" title="4 修改jenkins默认端口配置"></a>4 修改jenkins默认端口配置</h1><h2 id="1-查看jenkins安装路径"><a href="#1-查看jenkins安装路径" class="headerlink" title="1.查看jenkins安装路径"></a>1.查看jenkins安装路径</h2><ul><li><code>brew list jenkins</code></li></ul><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230110221220.png" style="zoom:150%;" /><h2 id="2-修改homebrew-mxcl-jenkins-plist"><a href="#2-修改homebrew-mxcl-jenkins-plist" class="headerlink" title="2. 修改homebrew.mxcl.jenkins.plist"></a>2. 修改homebrew.mxcl.jenkins.plist</h2><ul><li><p>打开文件 <code>vim /opt/homebrew/Cellar/jenkins/2.385/homebrew.mxcl.jenkins.plist</code></p></li><li><p>修改默认端口号</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230110221801.png"></p></li></ul><h2 id="3-修改jenkins系统配置url"><a href="#3-修改jenkins系统配置url" class="headerlink" title="3. 修改jenkins系统配置url"></a>3. 修改jenkins系统配置url</h2><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230110222629.png"  /><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/202301221541401.png"></p><h1 id="5-pipeline-集成原理"><a href="#5-pipeline-集成原理" class="headerlink" title="5 pipeline 集成原理  "></a>5 pipeline 集成原理  <img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230124113315.png"></h1>]]></content>
    
    
    <categories>
      
      <category>jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>工作流</title>
    <link href="/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <url>/%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1-工作流是什么？"><a href="#1-工作流是什么？" class="headerlink" title="1. 工作流是什么？"></a>1. 工作流是什么？</h1><p>工作流就是计算机对业务流程自动化执行管理。有了工作流可以更好的管理业务流程，提高系统扩展性。</p><h1 id="2-Activity-7"><a href="#2-Activity-7" class="headerlink" title="2. Activity 7"></a>2. Activity 7</h1><ul><li>activity是一个工作流引擎，activity可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义。</li><li>业务流程按照预先定义的流程进行执行，实现了系统的流程由activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时也减少了系统开发的维护成本。</li></ul><h1 id="3-BPMN"><a href="#3-BPMN" class="headerlink" title="3 BPMN"></a>3 BPMN</h1><p>BPMN（Business Process Model AndNotation）- 业务流程模型和符号 是由BPMI（BusinessProcess Management Initiative）<strong>开发的一套标准的业务流程建模符号</strong>，使用BPMN提供的<strong>符号</strong>可以创建业务流程。</p><h1 id="4-使用步骤"><a href="#4-使用步骤" class="headerlink" title="4.  使用步骤"></a>4.  使用步骤</h1><h2 id="4-1-流程定义"><a href="#4-1-流程定义" class="headerlink" title="4.1 流程定义"></a>4.1 流程定义</h2><p>使用activiti流程建模工具(activity-designer)定义业务流程(.bpmn文件) 。</p><h2 id="4-1-流程定义部署"><a href="#4-1-流程定义部署" class="headerlink" title="4.1 流程定义部署"></a>4.1 流程定义部署</h2><ul><li><p>activiti部署业务流程定义（.bpmn文件）</p></li><li><p>使用activiti提供的api把流程定义内容存储起来，在Activiti执行过程中可以查询定义的内容</p></li><li><p>Activiti执行把流程定义内容存储在数据库中</p></li></ul><h2 id="4-2-启动一个流程实例"><a href="#4-2-启动一个流程实例" class="headerlink" title="4.2 启动一个流程实例"></a>4.2 启动一个流程实例</h2><ul><li>流程实例也叫：ProcessInstance</li><li>启动一个流程实例表示开始一次业务流程的运行。</li><li>在员工请假流程定义部署完成后，如果张三要请假就可以启动一个流程实例，如果李四要请假也启动一个流程实例，两个流程的执行互相不影响。</li></ul><h2 id="4-3-用户查询待办任务-Task"><a href="#4-3-用户查询待办任务-Task" class="headerlink" title="4.3 用户查询待办任务(Task)"></a>4.3 用户查询待办任务(Task)</h2><p>因为现在系统的业务流程已经交给activiti管理，通过activiti就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些activiti帮我们管理了，而不需要开发人员自己编写在sql语句查询。</p><h2 id="4-4-用户办理任务"><a href="#4-4-用户办理任务" class="headerlink" title="4.4 用户办理任务"></a>4.4 用户办理任务</h2><p>用户查询待办任务后，就可以办理某个任务，如果这个任务办理完成还需要其它用户办理，比如采购单创建后由部门经理审核，这个过程也是由activiti帮我们完成了。</p><h2 id="4-5-流程结束"><a href="#4-5-流程结束" class="headerlink" title="4.5 流程结束"></a>4.5 流程结束</h2><p>当任务办理完成没有下一个任务结点了，这个流程实例就完成了。</p><h1 id="5-spring集成activiti"><a href="#5-spring集成activiti" class="headerlink" title="5 spring集成activiti"></a>5 spring集成activiti</h1><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activiti.version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">activiti.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- bpmn 模型处理 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- bpmn 转换 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- bpmn json数据转换 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-json-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- bpmn 布局 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-layout<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- activiti 云支持 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-cloud-services-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- mybatis --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- 链接池 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- log start --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-增加activiti配置文件"><a href="#2-增加activiti配置文件" class="headerlink" title="2. 增加activiti配置文件"></a>2. 增加activiti配置文件</h2><p>resources下增加activiti配置文件activiti.cfg.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/contex</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/tx</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;19980617pyr&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--    默认方式下bean的id 固定为processEngineConfiguration--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 引用数据源 上面已经设置好了--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!-- activiti数据库表处理策略 databaseSchemaUpdate：如果数据库中已经存在相应的表直接使用，不存在，直接创建--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-生成activiti需要的表"><a href="#3-生成activiti需要的表" class="headerlink" title="3 生成activiti需要的表"></a>3 生成activiti需要的表</h2><p>利用测试类生成activiti需要的表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngine;<br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngines;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCreate</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成 activiti的数据库表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateDbTable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 使用classpath下的activiti.cfg.xml中的配置创建processEngine</span><br><span class="hljs-comment">         * getDefaultProcessEngine会默认从resources下读取名字为activiti.cfg.xml文件</span><br><span class="hljs-comment">         * 创建processEngine时，就会创建mysql表</span><br><span class="hljs-comment">         */</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>        System.out.println(processEngine);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以上代码，会在数据库里生成25张表</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20230128155215.png"></p>]]></content>
    
    
    <categories>
      
      <category>Activiti</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>maven基本概念</title>
    <link href="/maven%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/maven%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="maven遵循约定大于配置"><a href="#maven遵循约定大于配置" class="headerlink" title="maven遵循约定大于配置"></a>maven遵循约定大于配置</h2><ul><li>maven编译的路径为 src&#x2F;main&#x2F;java</li><li>maven 打包后的路径在 &#x2F;target&#x2F;classes</li><li>maven项目的配置文件存储在&#x2F;resources目录下</li><li>maven打包就是，运行<code>mvn package</code>把 &#x2F;target&#x2F;classes下的文件，打成一个jar包或者war包，打在target目录下</li><li>maven运行测试用例，运行<code>mvn test</code>，将运行src&#x2F;test下以test开后的文件里的，以test开头的方法、  如果引入了junit，将会运行以@test注解的方法。</li></ul><h2 id="maven-生命周期"><a href="#maven-生命周期" class="headerlink" title="maven 生命周期"></a>maven 生命周期</h2><ul><li>Maven 的内部有三个标准生命周期</li><li>生命周期中的阶段是有严格的执行顺序的。比如：必须执行完compile才会执行package</li><li>生命周期中的阶段是有执行逻辑的。即当你执行一个阶段时，其前面的阶段会自动执行。</li><li>生命周期的阶段可以绑定具体的插件和目标</li></ul><h2 id="Clean-生命周期"><a href="#Clean-生命周期" class="headerlink" title="Clean 生命周期"></a>Clean 生命周期</h2><p>当我们执行 mvn post-clean 命令时，Maven 调用 clean 生命周期，它包含以下阶段：</p><ul><li>pre-clean：执行一些需要在clean之前完成的工作</li><li>clean：移除所有上一次构建生成的文件</li><li>post-clean：执行一些需要在clean之后立刻完成的工作</li></ul><h2 id="Default-Build-生命周期"><a href="#Default-Build-生命周期" class="headerlink" title="Default (Build) 生命周期"></a>Default (Build) 生命周期</h2><p>这是 Maven 的主要生命周期，被用于构建应用，包括 23 个阶段，核心阶段包括：</p><table><thead><tr><th>核心阶段</th><th>详解</th></tr></thead><tbody><tr><td>validate</td><td>验证项目是否正确，所有必要信息是否可用<code>（很少单独使用）</code></td></tr><tr><td>compile</td><td>编译项目的源代码（将src&#x2F;main中的java代码编译成class文件，输出到targe目录下）</td></tr><tr><td>test</td><td>将单元测试的资源文件和代码进行编译，生成的文件位于target&#x2F;test-classes （打包部署请跳过该阶段）</td></tr><tr><td>package</td><td>把class文件，resources文件打包成jar包（也可以是war包），生成的jar包位于target目录下</td></tr><tr><td>verify</td><td>检查包是否有效<code>（很少单独使用）</code></td></tr><tr><td>install</td><td>将jar部署到本地仓库，本地的其他模块依赖该jar包时，可以直接从本地仓库去获取</td></tr><tr><td>deploy</td><td>将jar包部署到远端仓库，需要在maven的setting.xml中配置私服的用户名和密码，以及在pom.xml配置</td></tr></tbody></table><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221227224007.png"></p><h2 id="Site-生命周期"><a href="#Site-生命周期" class="headerlink" title="Site 生命周期"></a>Site 生命周期</h2><p>Maven Site 插件一般用来创建新的报告文档、部署站点等。包括4各阶段</p><ul><li>pre-site：执行一些需要在生成站点文档之前完成的工作</li><li>site：生成项目的站点文档</li><li>post-site： 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li><li>site-deploy：将生成的站点文档部署到特定的服务器上</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue的生命周期选项</title>
    <link href="/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-beforeCreate"><a href="#1-beforeCreate" class="headerlink" title="1. beforeCreate"></a>1. beforeCreate</h2><ul><li><p>在组件实例初始化之后调用，也就是new Vue()之后</p></li><li><p>初始化了主要的生命周期函数</p></li></ul><h2 id="2-created"><a href="#2-created" class="headerlink" title="2. created"></a>2. created</h2><ul><li>初始化了data()，computed()，methods()，watch()</li><li>使用场景：调用ajax来获取自己的首屏数据</li></ul><h2 id="3-beforeMount"><a href="#3-beforeMount" class="headerlink" title="3.beforeMount"></a>3.beforeMount</h2><ul><li>内存中已经编译生成好了html结构，但是还没有渲染。</li></ul><blockquote><p>mount表示挂载的意思，就是说要将内存中渲染的html结构，渲染到页面上。</p></blockquote><h2 id="4-mounted"><a href="#4-mounted" class="headerlink" title="4. mounted"></a>4. mounted</h2><ul><li>内存中渲染好的html结构，替换到页面上</li><li>其自身的 DOM 树已经创建完成并插入了父容器中。</li><li>所有同步子组件都已经被挂载</li></ul><p><strong>使用场景</strong>：</p><p>在此处发送 异步请求 （ajax，fetch，axios等），获取服务器上的数据，显示在DOM里。</p><p>比如：根据输入框里输入的元素，去服务器查询数据</p><h2 id="5-beforeUpdate"><a href="#5-beforeUpdate" class="headerlink" title="5. beforeUpdate"></a>5. <strong>beforeUpdate</strong></h2><ul><li>组件更新（数据更新）之前执行的函数</li></ul><h2 id="6-updated"><a href="#6-updated" class="headerlink" title="6.updated"></a>6.<strong>updated</strong></h2><p>组件更新（数据更新）后执行的函数</p><h2 id="7-beforeDestroy"><a href="#7-beforeDestroy" class="headerlink" title="7. beforeDestroy"></a>7. beforeDestroy</h2><ul><li>vue（组件）对象销毁之前</li></ul><h2 id="8-destroyed"><a href="#8-destroyed" class="headerlink" title="8. destroyed"></a>8. destroyed</h2><ul><li>组件销毁后</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>响应式开发</title>
    <link href="/Bootstrap%E4%BD%BF%E7%94%A8/"/>
    <url>/Bootstrap%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-响应式开发"><a href="#1-响应式开发" class="headerlink" title="1 响应式开发"></a>1 响应式开发</h1><h2 id="1-1-响应式开发原理"><a href="#1-1-响应式开发原理" class="headerlink" title="1.1 响应式开发原理"></a>1.1 响应式开发原理</h2><p>响应式开发就是使用媒体查询，针对不同宽度的设备进行布局和样式的调整，从而适配不同设备。</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221127201119.png" style="zoom:50%;" /><h2 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-comment">/*1. 超小屏幕下 小于768 容器宽度为100%*/</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">767px</span>) &#123;<br>    <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*2. 小屏幕下 &gt;= 768, 容器布局改为750px*/</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) &#123;<br>    <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">750px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*2. 中等屏幕 &gt;= 992, 容器布局改为970px*/</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">992px</span>) &#123;<br>    <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">970px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*2. 小屏幕下 &gt;= 1200, 容器布局改为1170px*/</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1200px</span>) &#123;<br>    <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">1170px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221127201326.png" style="zoom:70%;" />]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>响应式开发</title>
    <link href="/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    <url>/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-响应式开发"><a href="#1-响应式开发" class="headerlink" title="1 响应式开发"></a>1 响应式开发</h1><h2 id="1-1-响应式开发原理"><a href="#1-1-响应式开发原理" class="headerlink" title="1.1 响应式开发原理"></a>1.1 响应式开发原理</h2><p>响应式开发就是使用媒体查询，针对不同宽度的设备进行布局和样式的调整，从而适配不同设备。</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221127201119.png" style="zoom:50%;" /><h2 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-comment">/*1. 超小屏幕下 小于768 容器宽度为100%*/</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">767px</span>) &#123;<br>    <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*2. 小屏幕下 &gt;= 768, 容器布局改为750px*/</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) &#123;<br>    <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">750px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*2. 中等屏幕 &gt;= 992, 容器布局改为970px*/</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">992px</span>) &#123;<br>    <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">970px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*2. 小屏幕下 &gt;= 1200, 容器布局改为1170px*/</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1200px</span>) &#123;<br>    <span class="hljs-selector-class">.container</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">1170px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221127201326.png" style="zoom:70%;" />]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS定位</title>
    <link href="/CSS%E5%AE%9A%E4%BD%8D/"/>
    <url>/CSS%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1-为什么需要定位？"><a href="#1-为什么需要定位？" class="headerlink" title="1. 为什么需要定位？"></a>1. 为什么需要定位？</h1><p>有些场景，使用标准流和浮动都没办法实现。比如：</p><ul><li>某个元素可以随意在一个盒子内移动位置，并且压住其他盒子。</li><li>滚动窗口的时候，盒子是固定在某个位置的。</li></ul><h1 id="2-定位是什么？"><a href="#2-定位是什么？" class="headerlink" title="2 定位是什么？"></a>2 定位是什么？</h1><ul><li><p>定位组成：定位 &#x3D; 定位模式 + 边偏移</p></li><li><p>定位特性：</p><ol><li><p>绝对定位和固定定位和浮动类似</p><ul><li>行内元素添加绝对定位或固定定位，可以直接设置宽度和高度</li><li>块级元素添加绝对定位或固定定位，如果没有设置宽度和高度，默认大小是内容的大小。</li></ul></li><li><p>绝对定位和固定定位会压住它下面标准流的盒子</p></li></ol></li></ul><h2 id="2-1-定位模式"><a href="#2-1-定位模式" class="headerlink" title="2.1 定位模式"></a>2.1 定位模式</h2><p>定位模式，决定元素的定位方式，通过CSS的position属性来设置，分为4种：</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221127143043.png" style="zoom:70%;" /><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221127175619.png" style="zoom:70%;" /><h2 id="2-2-边偏移"><a href="#2-2-边偏移" class="headerlink" title="2.2 边偏移"></a>2.2 边偏移</h2><p>边偏移，决定元素的最终位置，有top,bottom,left,right 4个属性</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221127143307.png" style="zoom:70%;" /><h1 id="3-定位方式"><a href="#3-定位方式" class="headerlink" title="3 定位方式"></a>3 定位方式</h1><h2 id="3-1-静态定位"><a href="#3-1-静态定位" class="headerlink" title="3.1 静态定位"></a>3.1 静态定位</h2><ul><li>定义：静态定位是元素的默认定位方式，即无定位。</li><li>语法：<code>&#123;position： static&#125;</code></li><li>特点：<ul><li>按照标准流的特性，没有位偏移</li></ul></li><li>应用：<ul><li>静态定位在布局时很少用到</li></ul></li></ul><h2 id="3-2-相对定位"><a href="#3-2-相对定位" class="headerlink" title="3.2 相对定位"></a>3.2 相对定位</h2><ul><li>定义： 相对定位是元素在移动位置的时候，相对它原来的位置来说的。</li><li>语法 ：<code>&#123;position： relative&#125;</code></li><li>特点：<ul><li>移动的位置是参照自己原先的位置</li><li>不脱标，继续保留原来的位置</li></ul></li><li>应用：<ul><li>给决定定位当爹</li></ul></li></ul><h2 id="3-3-绝对定位"><a href="#3-3-绝对定位" class="headerlink" title="3.3 绝对定位"></a>3.3 绝对定位</h2><ul><li>定义：绝对定位是元素在移动位置的时候，相对它<strong>祖辈元素</strong>的位置来说的。</li><li>语法：<code>&#123;position： absolute&#125;</code></li><li>特点：<ul><li>如果没有祖先元素，或祖先元素没有定位，则以浏览器为准定位（Document文档）</li><li>如果祖先元素有定位（相对，绝对，固定定位），则以最近一级有定位的祖先元素，为参考点移动位置。</li><li>绝对定位不再占有原先的位置（脱标）</li></ul></li></ul><p><strong>子绝父相的由来</strong></p><ul><li>意思是：子级是绝对定位的话，父级要是相对定位</li><li>理由：<ul><li>父级需要占有位置，所以是相对定位</li><li>子级需要不占有位置，并且可以放到父盒子的任意一个地方。所以是绝对定位。</li></ul></li></ul><h2 id="3-4-固定定位"><a href="#3-4-固定定位" class="headerlink" title="3.4 固定定位"></a>3.4 固定定位</h2><ul><li>定义：固定定位是元素固定于浏览器的可视区的位置</li><li>语法：<code>&#123;position： fixed&#125;</code></li><li>特点：<ul><li>以浏览器的可视窗口为参照点移动元素</li><li>浏览器滚动时，元素的位置不会改变</li><li>跟父元素没有关系</li><li>不占有原先的位置（脱标）</li></ul></li></ul><blockquote><p>固定定位可以看做是一种特殊的绝对定位</p></blockquote><h2 id="3-5-粘性定位"><a href="#3-5-粘性定位" class="headerlink" title="3.5 粘性定位"></a>3.5 粘性定位</h2><ul><li>定义：粘性定位可以看做相对定位和固定定位的混合。一般跟页面滚动条搭配使用</li><li>语法：<code>&#123;position： sticky; top: 10px&#125;</code>（刚开始随滚动条滚动，等到达了距距离浏览器可视窗口上方的10px后，就固定在了窗口上）</li><li>特点：<ul><li>以浏览器的可视窗口为参照点移动元素</li><li>不脱标，继续保留原来的位置</li><li>必须添加top，left,  right， bottom中的一个才有效</li><li>兼容性差，不支持IE</li></ul></li></ul><h1 id="4-定位叠放次序"><a href="#4-定位叠放次序" class="headerlink" title="4 定位叠放次序"></a>4 定位叠放次序</h1><ul><li>定义： 使用定位布局时，可能会出现盒子的重叠情况。此时，使用z-index 来设置叠放次序</li><li>语法：<code>&#123;z-index: 1&#125;</code></li><li>特点：<ul><li>数值可以是正整数、负整数、0，默认是auto</li><li>数值越大，盒子越靠上</li><li>数字后面不能加单位</li><li>只有定位的盒子才能有z-index属性</li></ul></li></ul><h1 id="5-绝对定位盒子居中"><a href="#5-绝对定位盒子居中" class="headerlink" title="5 绝对定位盒子居中"></a>5 绝对定位盒子居中</h1><ul><li>加了绝对定位的盒子不能通过<code>margin: 0 auto</code>水平居中，但是可以通过以下计算方法实现居中。<ol><li><code>left: 50%</code>: 让盒子的左侧移动父容器宽度的一半</li><li><code>margin-left: -0.5*自身宽度 px</code>: 让盒子向左移动自身盒子宽度的一般</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS元素显示模式</title>
    <link href="/CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/"/>
    <url>/CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h1><ul><li><p>元素显示模式就是：元素（标签）以什么方式进行显示。比如<div>自己占一行，一行可以放多个<span></p></li><li><p>html元素一般可以分为：块元素和行元素</p></li></ul><h1 id="2-块元素"><a href="#2-块元素" class="headerlink" title="2 块元素"></a>2 块元素</h1><p>常见的块级元素有div、hr、p、h1 - h6, ul , ol , form , table</p><h2 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h2><ul><li>独占一行</li><li>可以控制：宽度，高度，内外边距</li><li>宽度默认是父容器的100%</li><li>是一个容器，里面可以放行内元素或者块级元素</li></ul><p>注意：文字类的元素内不能使用块级元素。如<code>&lt;p&gt;, &lt;h1&gt;~&lt;h6&gt;</code>里面不可以使用div</p><h1 id="3-行内元素"><a href="#3-行内元素" class="headerlink" title="3 行内元素"></a>3 行内元素</h1><p>常见的行内元素有a, span, a, i ,em 等</p><h2 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1 特点"></a>3.1 特点</h2><ul><li><p>行内元素在一行可以显示多个</p></li><li><p>高和宽设置是无效的</p></li><li><p>宽度默认就是他本身内容的宽度</p></li><li><p>行内元素只能容纳文本或者其他行内元素</p></li></ul><p><strong>注意：</strong></p><ul><li>链接里面不能再放链接</li></ul><h1 id="4-行内块元素"><a href="#4-行内块元素" class="headerlink" title="4 行内块元素"></a>4 行内块元素</h1><p> 常见的行内块元素有：input, img, td。他们同事具有块元素和行内元素的特点。</p><h2 id="4-1-特点"><a href="#4-1-特点" class="headerlink" title="4. 1 特点"></a>4. 1 特点</h2><ul><li>一行可以显示多个，但是多个间会有空白缝隙。</li><li>宽度默认就是他本身内容的宽度</li><li>可以控制：宽度，高度，内外边距</li></ul><h1 id="5-元素显示模式的转换"><a href="#5-元素显示模式的转换" class="headerlink" title="5 元素显示模式的转换"></a>5 元素显示模式的转换</h1><p>常见的操作：想增加a链接的触发范围</p><ul><li>转为块元素：<code>display:block</code></li><li>转为行内元素：<code>display:inline</code></li><li>转为行内块元素：<code>display:inline-block</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决手机端1像素边框问题</title>
    <link href="/%E8%A7%A3%E5%86%B3%E6%89%8B%E6%9C%BA%E7%AB%AF1%E5%83%8F%E7%B4%A0%E8%BE%B9%E6%A1%86%E9%97%AE%E9%A2%98/"/>
    <url>/%E8%A7%A3%E5%86%B3%E6%89%8B%E6%9C%BA%E7%AB%AF1%E5%83%8F%E7%B4%A0%E8%BE%B9%E6%A1%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义border-css文件"><a href="#1-定义border-css文件" class="headerlink" title="1. 定义border.css文件"></a>1. 定义border.css文件</h1><p><a href="https://github.com/panyuro/Travel/blob/main/src/assets/styles/border.css">Travel&#x2F;border.css at main · panyuro&#x2F;Travel (github.com)</a></p><h1 id="2-在main-js引入"><a href="#2-在main-js引入" class="headerlink" title="2. 在main.js引入"></a>2. 在main.js引入</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./assets/styles/border.css&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS浮动</title>
    <link href="/CSS%E6%B5%AE%E5%8A%A8/"/>
    <url>/CSS%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>多个块级元素纵向排列找标准流，横向排列找浮动。</p></blockquote><h1 id="1-普通流（标准流）"><a href="#1-普通流（标准流）" class="headerlink" title="1 普通流（标准流）"></a>1 普通流（标准流）</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>标准流就是标签按照规定好默认方式排列。标准流是最基本的布局方式。</p><ol><li>块级元素会独占一行，从上到下顺序排列。如：div、hr、p、h1 - h6, ul , ol , form , table</li><li>行内元素会按照顺序，从左往右排序,如：span, a, i ,em</li></ol><h1 id="2-浮动"><a href="#2-浮动" class="headerlink" title="2 浮动"></a>2 浮动</h1><h2 id="2-1-为什么需要浮动？"><a href="#2-1-为什么需要浮动？" class="headerlink" title="2.1 为什么需要浮动？"></a>2.1 为什么需要浮动？</h2><ul><li>有很多布局效果，标准流没有办法完成。比如：多个块级盒子一行没有缝隙排列。</li><li>浮动，可以改变元素标签的默认排列方式。</li><li>浮动最初产生的目的：做文字环绕。</li></ul><h2 id="2-2-什么是浮动？"><a href="#2-2-什么是浮动？" class="headerlink" title="2.2 什么是浮动？"></a>2.2 什么是浮动？</h2><ul><li><p>float属性，用于创建浮动框，将其移动到一边，直至左边缘或者右边缘触及到包含块或者另一个浮动框的边缘</p></li><li><p>语法：<code>&#123;float: 属性值&#125;</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221126195705.png"></p></li></ul><h2 id="2-3-浮动特性"><a href="#2-3-浮动特性" class="headerlink" title="2.3 浮动特性"></a>2.3 浮动特性</h2><ol><li><p>设置了浮动的元素，脱离了标准流的控制（简称“脱标”）。浮动的盒子不再保留原来的位置。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221126200811.png"></p></li><li><p>如果多个盒子都设置了浮动，则他们会按照属性值，一行显示并且顶端对齐排列。</p><ul><li><p>注意：浮动的元素是互相贴在一起的（不会有缝隙），如果父级元素装不下这些浮动的盒子，多出的盒子会另起一行对齐。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221126222207.png"></p></li></ul></li><li><p>设置了浮动的元素，会具有行内块元素的特性</p><ul><li>块级元素，没有设置宽度时，默认宽度和父级一样。但是添加浮动后，他的大小根据内容来决定。</li><li>行内元素，添加浮动后，就可以直接设置高度和宽度。</li></ul></li><li><p>浮动不会压住它下面标准流盒子里的文字。因为他最初设置的目的就是为了做文字环绕。</p></li></ol><h2 id="2-4-浮动布局的注意点"><a href="#2-4-浮动布局的注意点" class="headerlink" title="2.4 浮动布局的注意点"></a>2.4 浮动布局的注意点</h2><h3 id="2-4-1-浮动和标准流父级搭配使用"><a href="#2-4-1-浮动和标准流父级搭配使用" class="headerlink" title="2.4.1  浮动和标准流父级搭配使用"></a>2.4.1  浮动和标准流父级搭配使用</h3><p>为了约束浮动元素的位置，我们一般采取的策略是：<strong>先用标准流的父元素排列上下位置，之后内部元素采取浮动，排列左右位置。</strong></p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221126230639.png" style="zoom:50%;" /><h3 id="2-4-2-一个元素浮动了，理论上其余的兄弟元素都应该浮动"><a href="#2-4-2-一个元素浮动了，理论上其余的兄弟元素都应该浮动" class="headerlink" title="2.4.2 一个元素浮动了，理论上其余的兄弟元素都应该浮动"></a>2.4.2 一个元素浮动了，理论上其余的兄弟元素都应该浮动</h3><p>浮动的盒子，只会影响他后面的标准流，不会影响前面的标准流。因为前面的标准流已经独占一行了</p><h1 id="2-5-清除浮动"><a href="#2-5-清除浮动" class="headerlink" title="2.5 清除浮动"></a>2.5 清除浮动</h1><h3 id="2-5-1-为什么需要清除浮动？"><a href="#2-5-1-为什么需要清除浮动？" class="headerlink" title="2.5.1 为什么需要清除浮动？"></a>2.5.1 为什么需要清除浮动？</h3><p>在某些情况下，如：文字长短不定，列表展示高度不定。父盒子不方便给高度。</p><p>但是子盒子浮动又不占有位置，最后会导致父盒子不占用原文档流的位置，高度为0，会影响后面的元素排版。</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221127000827.png" style="zoom:50%;" /><h3 id="2-5-2-清除浮动的本质"><a href="#2-5-2-清除浮动的本质" class="headerlink" title="2.5.2 清除浮动的本质"></a>2.5.2 清除浮动的本质</h3><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响后面的元素排版了。</p><h3 id="2-5-3-清除浮动的方式"><a href="#2-5-3-清除浮动的方式" class="headerlink" title="2.5.3 清除浮动的方式"></a>2.5.3 清除浮动的方式</h3><ul><li><p>语法：<code>&#123;clear: 属性值&#125;</code>，实际工作中，几乎只用clear:both</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20221127112835.png" style="zoom:50%;" /></li></ul><h4 id="1-额外标签法"><a href="#1-额外标签法" class="headerlink" title="1 额外标签法"></a>1 额外标签法</h4><ul><li><p>定义： 额外标签法也称之为<strong>隔墙法</strong>， 是W3C最推荐的做法。</p></li><li><p>使用：在浮动元素末尾添加一个空的标签，例如：<code>&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;</code></p></li><li><p>优缺点：</p><ul><li>优点：通俗易懂，书写方便</li><li>缺点：增加了无意义的标签，结构化差</li></ul></li></ul><h4 id="2-给父级添加overflow"><a href="#2-给父级添加overflow" class="headerlink" title="2 给父级添加overflow"></a>2 给父级添加overflow</h4><ul><li>使用：给父级添加overflow属性，将其属性值设置为：hidden, auto 或 scroll</li><li>优缺点：<ul><li>优点：代码简介</li><li>缺点： 无法展示溢出的部分</li></ul></li></ul><h4 id="3-after-伪元素法"><a href="#3-after-伪元素法" class="headerlink" title="3 :after 伪元素法"></a>3 :after 伪元素法</h4><ul><li>使用：after方式是额外标签法的升级版。只需要给父类元素添加：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span>:after &#123;<br>    content: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">clear</span>: both;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-class">.clearfix</span> &#123;<br>    <span class="hljs-comment">/*IE6,IE7*/</span><br>    zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优缺点：<ul><li>优点：没有增加标签，结构简单</li><li>缺点：需要照顾低版本浏览器</li></ul></li><li>代表网站：百度，淘宝，网易</li></ul><h4 id="4-双伪元素法"><a href="#4-双伪元素法" class="headerlink" title="4. 双伪元素法"></a>4. 双伪元素法</h4><ul><li>使用：父元素添加：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span>:before, .clearfix:after &#123;<br>    content: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span>:after &#123;<br>    clear: both;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span> &#123;<br>    <span class="hljs-comment">/*IE6,IE7*/</span><br>    zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优缺点：<ul><li>优点：代码更简洁</li><li>缺点：需要照顾低版本浏览器</li></ul></li><li>代表网站：小米，腾讯</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS盒子模型</title>
    <link href="/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-块级元素水平居中"><a href="#1-块级元素水平居中" class="headerlink" title="1 块级元素水平居中"></a>1 块级元素水平居中</h1><ol><li>必须满足两个条件<ul><li>盒子必须指明了宽度</li><li>盒子左右的外边剧都设置为auto</li></ul></li><li>常规写法<ul><li>margin-left: auto ; margin-right: auto</li><li>margin: auto</li><li>margin: 0 auto</li></ul></li></ol><h1 id="2-行内元素或者行内块元素水平居中"><a href="#2-行内元素或者行内块元素水平居中" class="headerlink" title="2 行内元素或者行内块元素水平居中"></a>2 行内元素或者行内块元素水平居中</h1><p>解决方案：给父元素添加： text-align: center</p><h1 id="3-嵌套块元素垂直外边距塌陷"><a href="#3-嵌套块元素垂直外边距塌陷" class="headerlink" title="3 嵌套块元素垂直外边距塌陷"></a>3 嵌套块元素垂直外边距塌陷</h1><p>对于两个嵌套关系（父子关系）的块元素，父元素和子元素同时都有上外边距，此时父元素会塌陷较大的外边距值</p><p>解决方案</p><ul><li>给父元素定义上边框</li><li>给父元素定义上内边距</li><li>给父元素添加：overflow: hidden</li></ul><h1 id="4-清除内外边距"><a href="#4-清除内外边距" class="headerlink" title="4 清除内外边距"></a>4 清除内外边距</h1><p>网页元素很多都带有默认的内外边距，不同的浏览器默认的也不一致。因此我们在布局前，需要清除下网页元素的内外边距。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">* &#123;<br>  padding: 0; /* 清除内边距 */<br>  margin: 0; /* 清除外边距 */<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Padding-会影响盒子的大小"><a href="#5-Padding-会影响盒子的大小" class="headerlink" title="5 Padding 会影响盒子的大小"></a>5 Padding 会影响盒子的大小</h1><ul><li>如果盒子已经有了宽度和高度，此时再指定内边距，会撑大盒子</li></ul><p>​解决方案：让width和height减去多出来的内边距大小</p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8bv0i7jx1j314g0u0aet.jpg" style="zoom: 33%;" /><ul><li>如果盒子本身没有指定宽度和高度，则此时padding不会撑大盒子</li></ul><h1 id="6-padding-bottom实现普通元素固定宽高比"><a href="#6-padding-bottom实现普通元素固定宽高比" class="headerlink" title="6 padding-bottom实现普通元素固定宽高比"></a>6 padding-bottom实现普通元素固定宽高比</h1><p>将<code>div</code>元素的高度设为了<code>0</code>，通过<code>padding-bottom</code>来撑开盒子的高度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;father&quot;</span>&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">.father &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">50</span>%;<br>  background-color: #25a4bb;<br>&#125;<br><br>.son &#123;<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">0</span>;<br>  padding-bottom: <span class="hljs-number">50</span>%; <span class="hljs-comment">//规定基于父元素的宽度的百分比的内边距。</span><br>  background-color: red;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESLint</title>
    <link href="/ESLint/"/>
    <url>/ESLint/</url>
    
    <content type="html"><![CDATA[<h1 id="1-ESLint是什么？"><a href="#1-ESLint是什么？" class="headerlink" title="1 ESLint是什么？"></a>1 ESLint是什么？</h1><p>ESLint最初是由<a href="http://nczonline.net/">Nicholas C. Zakas</a> 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具。</p><ul><li>ESLint 的初衷是为了让程序员可以创建自己的检测规则</li><li>ESLint 并不推荐任何编码风格，规则是自由的</li></ul><p><strong>官网：</strong><a href="https://eslint.bootcss.com/">ESLint - 插件化的 JavaScript 代码检测工具 - ESLint中文文档 (bootcss.com)</a></p><h1 id="2-优势"><a href="#2-优势" class="headerlink" title="2 优势"></a>2 优势</h1><h3 id="2-1-避免低级bug，找出可能发生的语法错误"><a href="#2-1-避免低级bug，找出可能发生的语法错误" class="headerlink" title="2.1. 避免低级bug，找出可能发生的语法错误"></a>2.1. 避免低级bug，找出可能发生的语法错误</h3><blockquote><p>使用未声明变量、修改 const 变量……</p></blockquote><h3 id="2-2-提示删除多余的代码"><a href="#2-2-提示删除多余的代码" class="headerlink" title="2.2. 提示删除多余的代码"></a>2.2. 提示删除多余的代码</h3><blockquote><p>声明而未使用的变量、重复的 case ……</p></blockquote><h3 id="2-3-统一团队的代码风格"><a href="#2-3-统一团队的代码风格" class="headerlink" title="2.3. 统一团队的代码风格"></a>2.3. 统一团队的代码风格</h3><blockquote><p>加不加分号？使用 tab 还是空格？</p></blockquote><h1 id="3-ESLint检查语法的规则"><a href="#3-ESLint检查语法的规则" class="headerlink" title="3 ESLint检查语法的规则"></a>3 ESLint检查语法的规则</h1><p><a href="http://eslint.cn/docs/rules/">List of available rules - ESLint中文</a></p><h1 id="4-Eslint-配置"><a href="#4-Eslint-配置" class="headerlink" title="4 Eslint 配置"></a>4 Eslint 配置</h1><p><strong>1 可以通过vue脚手架创建项目时自动下载配置</strong></p><p><strong>2 项目已经创建好，手动下载配置</strong></p><ul><li><p>安装并初始化配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install eslint --save-dev   <span class="hljs-comment">// 安装并保存到项目开发依赖</span><br>./node_modules/.bin/eslint -- --init <span class="hljs-comment">// 初始化命令</span><br></code></pre></td></tr></table></figure></li><li><p>ESLint 会询问一系列问题，根据你的回答生成对应的<code>.eslintrc.js</code>配置文件。<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8bjfywzaxj31k80iqgr7.jpg"></p></li></ul><h1 id="5-配置文件介绍"><a href="#5-配置文件介绍" class="headerlink" title="5 配置文件介绍"></a>5 配置文件介绍</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-string">&quot;env&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;browser&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;es6&quot;</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-string">&quot;extends&quot;</span>: <span class="hljs-string">&quot;standard&quot;</span>,<br>    <span class="hljs-string">&quot;globals&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;Atomics&quot;</span>: <span class="hljs-string">&quot;readonly&quot;</span>,<br>        <span class="hljs-string">&quot;SharedArrayBuffer&quot;</span>: <span class="hljs-string">&quot;readonly&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;parserOptions&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;ecmaVersion&quot;</span>: <span class="hljs-number">2018</span>,<br>        <span class="hljs-string">&quot;sourceType&quot;</span>: <span class="hljs-string">&quot;module&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;plugins&quot;</span>: [<br>        <span class="hljs-string">&quot;vue&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;rules&quot;</span>: &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-1-env"><a href="#5-1-env" class="headerlink" title="5.1 env"></a>5.1 env</h2><p>告诉eslint，当前代码是运行在哪些环境中</p><ul><li><p>开发中经常会用到 一些运行环境自带的 api，如：</p><ul><li><p>浏览器中的 <strong>window&#x2F;document</strong> 等</p></li><li><p>nodejs中的 <strong>__dirname</strong> 等</p></li></ul></li><li><p>如果不指定的话，检查时就会报错</p></li></ul><h2 id="5-2-extends"><a href="#5-2-extends" class="headerlink" title="5.2 extends"></a>5.2 extends</h2><p> 直接使用别人已经写好的 lint 规则，方便快捷。扩展一般支持三种类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;extends&quot;</span>: [<br>    <span class="hljs-string">&quot;eslint:recommended&quot;</span>,<br>    <span class="hljs-string">&quot;plugin:react/recommended&quot;</span>,<br>    <span class="hljs-string">&quot;eslint-config-standard&quot;</span>,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ESLint 官方的扩展:  一共有两个：<code>eslint:recommended</code> 、<code>eslint:all</code></li><li>插件类型。</li><li>npm 包的扩展。官方规定 npm 包的扩展必须以 <code>eslint-config-</code> 开头，使用时可以省略这个头，上面案例中 <code>eslint-config-standard</code> 可以直接简写成 <code>standard</code>。</li></ul><h2 id="5-3-globals"><a href="#5-3-globals" class="headerlink" title="5.3 globals"></a>5.3 globals</h2><p>在 ESLint 中定义全局变量</p><ul><li>当访问当前源文件内未定义的变量时，<a href="https://link.juejin.cn/?target=https://eslint.bootcss.com/docs/rules/no-undef">no-undef</a> 规则将发出警告。</li><li>如果你想在一个源文件里使用全局变量，推荐你在 ESLint 中定义这些全局变量，这样 ESLint 就不会发出警告了。</li></ul><h2 id="5-4-parserOptions"><a href="#5-4-parserOptions" class="headerlink" title="5.4  parserOptions"></a>5.4  parserOptions</h2><p>ESLint 解析器 解析代码时，可以指定 用哪个 js 的版本</p><ul><li>ecmaVersion： <em>你可以使用 6、7、8、9 或 10 来指定你想要使用的 ECMAScript 版本。你也可以用使用年份命名的版本号指定为 2015（同 6），2016（同 7），或 2017（同 8）或 2018（同 9）或 2019 (same as 10)</em></li><li>sourceType： sourceType 有两个值，script 和 module。 对于 ES6+ 的语法和用 import &#x2F; export 的语法必须用 module.</li></ul><h2 id="5-5-plugins"><a href="#5-5-plugins" class="headerlink" title="5.5 plugins"></a>5.5 plugins</h2><p>许多 ESLint 插件为使用特定的库和框架提供了额外的规则。</p><ul><li><p>官方的规则只能检查标准的 JavaScript 语法，如果你写的是 JSX 或者 Vue 单文件组件，就需要安装 ESLint 的插件，来定制一些特定的规则进行检查。</p></li><li><p>ESLint 的插件与扩展一样有固定的命名格式，以 <code>eslint-plugin-</code> 开头，使用的时候也可以省略这个头。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;plugins&quot;</span>: [<br>    <span class="hljs-string">&quot;react&quot;</span>, <span class="hljs-comment">// eslint-plugin-react</span><br>    <span class="hljs-string">&quot;vue&quot;</span>,   <span class="hljs-comment">// eslint-plugin-vue</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>或者是在扩展中引入插件，前面有提到 <code>plugin:</code> 开头的是扩展是进行插件的加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;extends&quot;</span>: [<br>    <span class="hljs-string">&quot;plugin:react/recommended&quot;</span>,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-6-rules"><a href="#5-6-rules" class="headerlink" title="5.6 rules"></a>5.6 rules</h2><p>ESLint 附带有<a href="https://link.zhihu.com/?target=https://cn.eslint.org/docs/rules/">大量的规则</a>，你可以在配置文件的 <code>rules</code> 属性中配置你想要的规则</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>代码规范</tag>
      
      <tag>eslint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型</title>
    <link href="/Java%E6%B3%9B%E5%9E%8B/"/>
    <url>/Java%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-泛型概念"><a href="#1-泛型概念" class="headerlink" title="1.泛型概念"></a>1.泛型概念</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>泛型是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查</p><ul><li>java范型在生成字节码的时候会进行擦除</li><li>范型格式：<code>&lt;数据类型&gt;</code></li><li>注意：泛型只能支持引用数据类型，因为定义的范型，其实在存入的时候还是会变成Object类型，而基本数据类型，不可以变成Object类型</li><li>指定范型类型后，可以传入该类类型及其子类类型</li></ul><h2 id="1-2-好处"><a href="#1-2-好处" class="headerlink" title="1.2 好处"></a>1.2 好处</h2><ul><li>统一数据类型</li><li>运行时期的问题，提到了编译期间，避免了强制类型转换出现的异常。</li></ul><h1 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2 使用场景"></a>2 使用场景</h1><h2 id="2-1-范型类"><a href="#2-1-范型类" class="headerlink" title="2.1 范型类"></a>2.1 范型类</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>当编写一个类时，如果不确定类型，那么这个类就称为范型类,.如： ArrayList</p><ul><li>创建这个类的时候，就可以确定类型</li><li>这里的类型可以定义为变量，是用来记录数据的类型的，可以写成T，E，K , V，也可以写成其他变量</li></ul><h3 id="2-2-格式"><a href="#2-2-格式" class="headerlink" title="2.2 格式"></a>2.2 格式</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">修饰符 <span class="hljs-keyword">class</span> 类名&lt;<span class="hljs-symbol">E</span>&gt;&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>  Object[] obj = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">10</span>];<br>  <span class="hljs-keyword">int</span> size;<br><br>  <span class="hljs-comment">// E表示不确定的类型，该类型在类后面定义过了</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    obj[size] = e;<br>    size++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) obj[index];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>  MyArray&lt;String&gt; myArray = <span class="hljs-keyword">new</span> MyArray&lt;&gt;();<br>  myArray.add(<span class="hljs-string">&quot;q&quot;</span>);<br>  System.out.println(myArray.get(<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-范型方法"><a href="#2-2-范型方法" class="headerlink" title="2.2 范型方法"></a>2.2 范型方法</h2><h3 id="2-2-1-使用类型后面定义的类型"><a href="#2-2-1-使用类型后面定义的类型" class="headerlink" title="2.2.1 使用类型后面定义的类型"></a>2.2.1 使用类型后面定义的类型</h3><ul><li><p>方法中形参类型不确定时，可以使用类型后面定义的类型。</p></li><li><p>所有的方法都可以使用这个类型</p></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) obj[index];<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-在方法上定义自己的类型"><a href="#2-2-2-在方法上定义自己的类型" class="headerlink" title="2.2.2 在方法上定义自己的类型"></a>2.2.2 <strong>在方法上定义自己的类型</strong></h3><p>只能在本方法中使用</p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符&lt;E&gt; 返回值类型 方法名(类型 变量名)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span>&lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(T t)</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">buildList</span><span class="hljs-params">(T... t)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> Arrays.asList(t);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getValue</span><span class="hljs-params">(T t)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>  List&lt;Integer&gt; integers = buildList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>  System.out.println(integers);<br><br>  Integer value = getValue(<span class="hljs-number">1</span>);<br>  System.out.println(value);<br><br>  String str = getValue(<span class="hljs-string">&quot;111&quot;</span>);<br>  System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-范型接口"><a href="#2-3-范型接口" class="headerlink" title="2.3 范型接口"></a>2.3 范型接口</h2><p>当编写一个接口时，如果不确定类型，那么这个类就称为范型接口，如： list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-使用一：-实现类给出具体类型"><a href="#1-使用一：-实现类给出具体类型" class="headerlink" title="1 使用一： 实现类给出具体类型"></a>1 使用一： 实现类给出具体类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>  MyList list = <span class="hljs-keyword">new</span> MyList();<br>  list.add(<span class="hljs-string">&quot;string&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用二：实现类继续延续泛型，创建对象时再确定"><a href="#2-使用二：实现类继续延续泛型，创建对象时再确定" class="headerlink" title="2 使用二：实现类继续延续泛型，创建对象时再确定"></a>2 使用二：实现类继续延续泛型，创建对象时再确定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList2</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>  MyList2&lt;String&gt; list2 = <span class="hljs-keyword">new</span> MyList2();<br>  list2.add(<span class="hljs-string">&quot;string&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-泛型通配符"><a href="#3-泛型通配符" class="headerlink" title="3 泛型通配符"></a>3 泛型通配符</h1><ul><li><p><code>?</code>可以表示不确定的类型</p></li><li><p><code>? extends E</code>: 表示只能传递E或者E的子类</p></li><li><p><code>? super E</code>: 表示只能传递E或者E的父类</p></li></ul><h2 id="3-1-示例"><a href="#3-1-示例" class="headerlink" title="3.1 示例"></a>3.1 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> String id;<br>  <span class="hljs-keyword">public</span> String name;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">(String id, String name)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.id = id;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;学习状态中------&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">(String id, String name)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(id, name);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrandSon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Son</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GrandSon</span><span class="hljs-params">(String id, String name)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(id, name);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>? extends Son</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">(List&lt;? extends Son&gt; array)</span> </span>&#123;<br>        array.forEach(Son::study);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h80c7s1nt7j30p20cmgmq.jpg" style="zoom:50%;" /><ul><li>? extends Son</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> Son&gt; array)</span> </span>&#123;<br>  array.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h80cw8fu3wj30p00bumy2.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6语法学习笔记</title>
    <link href="/ES6%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/ES6%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Let和const"><a href="#1-Let和const" class="headerlink" title="1 Let和const"></a>1 Let和const</h1><ul><li>Let:  所声明的变量，只在let命令所在的代码块内有效。</li><li><code>const</code>声明一个只读的<code>常量</code>。一旦声明，常量的值就不能改变。const一旦声明变量，就必须立即<code>初始化</code>，不能留到以后赋值。类似final</li></ul><h1 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2 解构赋值"></a>2 解构赋值</h1><ul><li>ES6 允许按照一定模式，从<strong>数组和对象</strong>中提取值，对变量进行赋值，这被称为<code>解构</code>（Destructuring）。</li><li>本质上，这种写法属于<code>“模式匹配”</code>，只要等号两边的模式相同，左边的变量就会被赋予对应的值</li></ul><h2 id="2-1-数组的解构赋值"><a href="#2-1-数组的解构赋值" class="headerlink" title="2.1  数组的解构赋值"></a>2.1  数组的解构赋值</h2><ul><li><p>可以从数组中提取值，按照对应位置，对变量赋值。</p></li><li><p>数组的元素是按次序排列的，变量的取值由它的位置决定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">let</span> [ , , third] = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;baz&quot;</span>];<br><br><span class="hljs-keyword">let</span> [head, ...tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>head <span class="hljs-comment">// 1</span><br>tail <span class="hljs-comment">// [2, 3, 4]</span><br><br><span class="hljs-keyword">let</span> [x, y, ...z] = [<span class="hljs-string">&#x27;a&#x27;</span>];<br>x <span class="hljs-comment">// &quot;a&quot;</span><br>y <span class="hljs-comment">// undefined</span><br>z <span class="hljs-comment">// []</span><br><br><span class="hljs-keyword">let</span> [x, y, z] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>])<br></code></pre></td></tr></table></figure></li><li><p>解构赋值<code>允许指定</code>默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [foo = <span class="hljs-literal">true</span>] = [];<br>foo <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span><br><br><span class="hljs-comment">// 只有当一个数组成员严格等于undefined，默认值才会生效。</span><br><span class="hljs-keyword">let</span> [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">undefined</span>]; <span class="hljs-comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span><br><br><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>] = [<span class="hljs-literal">null</span>];<br>x <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><h2 id="2-2-对象的解构赋值"><a href="#2-2-对象的解构赋值" class="headerlink" title="2.2 对象的解构赋值"></a>2.2 对象的解构赋值</h2><ul><li>对象的属性没有次序，<code>变量</code>必须与<code>属性</code>同名，才能取到正确的值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>foo <span class="hljs-comment">// &quot;aaa&quot;</span><br>bar <span class="hljs-comment">// &quot;bbb&quot;</span><br><br><span class="hljs-keyword">let</span> &#123;foo&#125; = &#123;<span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;baz&#x27;</span>&#125;;<br>foo <span class="hljs-comment">// undefined</span><br><br><span class="hljs-keyword">const</span> &#123; log &#125; = <span class="hljs-built_in">console</span>;<br>log(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure><p>如果变量名与属性名不一致，必须写成下面这样。</p><p>foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">foo</span>: baz &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>baz <span class="hljs-comment">// &quot;aaa&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>解构也可以用于嵌套结构的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">p</span>: [<br>    <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>    &#123; <span class="hljs-attr">y</span>: <span class="hljs-string">&#x27;World&#x27;</span> &#125;<br>  ]<br>&#125;;<br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">p</span>: [x, &#123; y &#125;] &#125; = obj;<br>x <span class="hljs-comment">// &quot;Hello&quot;</span><br>y <span class="hljs-comment">// &quot;World&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>对象<code>的</code>解构<code>也可以指定</code>默认值</p><ul><li>默认值生效的条件是，对象的<code>属性值</code>严格等于<code>undefined</code>。</li><li>null与undefined不严格相等，所以是个有效的赋值，导致默认值不会生效。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> &#123;x, y = <span class="hljs-number">5</span>&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;<br>x <span class="hljs-comment">// 1</span><br>y <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-3-字符串的解构赋值"><a href="#2-3-字符串的解构赋值" class="headerlink" title="2.3 字符串的解构赋值"></a>2.3 字符串的解构赋值</h2><ul><li>字符串被转换成了一个类似数组的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [a, b, c, d, e] = <span class="hljs-string">&#x27;hello&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">length</span> : len&#125; = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>len <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h2 id="2-4-用途"><a href="#2-4-用途" class="headerlink" title="2.4 用途"></a>2.4 用途</h2><ol><li><strong>交换变量的值</strong></li></ol><p>交换变量<code>x</code>和<code>y</code>的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[x, y] = [y, x];<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>从函数返回多个值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 返回一个数组</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">example</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-keyword">let</span> [a, b, c] = example();<br><br><span class="hljs-comment">// 返回一个对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">example</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span><br>  &#125;;<br>&#125;<br><span class="hljs-keyword">let</span> &#123; foo, bar &#125; = example();<br></code></pre></td></tr></table></figure></li><li><p><strong>提取 JSON 数据</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> jsonData = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;OK&quot;</span>,<br>  <span class="hljs-attr">data</span>: [<span class="hljs-number">867</span>, <span class="hljs-number">5309</span>]<br>&#125;;<br><span class="hljs-keyword">let</span> &#123; id, status, <span class="hljs-attr">data</span>: number &#125; = jsonData;<br><span class="hljs-built_in">console</span>.log(id, status, number);<br><span class="hljs-comment">// 42, &quot;OK&quot;, [867, 5309]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>遍历 Map 结构</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">&quot; is &quot;</span> + value);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取键名</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// 获取键值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [,value] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>输入模块的指定方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;source-map&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><h1 id="3-函数的扩展"><a href="#3-函数的扩展" class="headerlink" title="3. 函数的扩展"></a>3. 函数的扩展</h1><h2 id="3-1-参数设置默认值"><a href="#3-1-参数设置默认值" class="headerlink" title="3.1 参数设置默认值"></a>3.1 参数设置默认值</h2><ul><li><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">x, y = <span class="hljs-string">&#x27;World&#x27;</span></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(x, y);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">&#123;x, y = <span class="hljs-number">5</span>&#125;</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(x, y);<br>&#125;<br>foo(&#123;&#125;) <span class="hljs-comment">// undefined 5</span><br>foo(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// 1 5</span><br>foo(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>&#125;) <span class="hljs-comment">// 1 2</span><br></code></pre></td></tr></table></figure></li><li><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> getTempItem = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> (&#123; <span class="hljs-attr">id</span>: id, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Temp&quot;</span> &#125;);<br></code></pre></td></tr></table></figure></li><li><p>ES6 引入<code>rest 参数</code>（形式为 …变量名 ），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个<code>数组</code>，该变量将多余的参数放入数组中。</p><p>⚠️： rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...values</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> val <span class="hljs-keyword">of</span> values) &#123;<br>    sum += val;<br>  &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-comment">// 利用 rest 参数，可以向该函数传入任意数目的参数。</span><br>add(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="4-数组的扩展"><a href="#4-数组的扩展" class="headerlink" title="4 数组的扩展"></a>4 数组的扩展</h1><p><code>扩展运算符</code>（spread）是三个点（ … ）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><p><strong>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(...[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-comment">// 1 2 3</span><br></code></pre></td></tr></table></figure><p>用途：</p><ul><li><p>该运算符主要用于<code>函数调用</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">38</span>];<br>add(...numbers) <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure></li><li><p>应用 Math.max 方法，简化求出一个数组最大元素的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Math</span>.max(...[<span class="hljs-number">14</span>, <span class="hljs-number">3</span>, <span class="hljs-number">77</span>])<br></code></pre></td></tr></table></figure></li><li><p>push 函数，将一个数组添加到另一个数组的尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr1.push(...arr2);<br></code></pre></td></tr></table></figure></li><li><p>复制数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">const</span> a2 = [...a1];<br><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">const</span> [...a2] = a1;<br></code></pre></td></tr></table></figure></li><li><p><strong>合并数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];<br>[...arr1, ...arr2, ...arr3]<br><span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>与解构赋值结合</strong>，<strong>生成数组</strong></p><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>first <span class="hljs-comment">// 1</span><br>rest  <span class="hljs-comment">// [2, 3, 4, 5]</span><br><br><span class="hljs-keyword">const</span> [first, ...rest] = [];<br>first <span class="hljs-comment">// undefined</span><br>rest  <span class="hljs-comment">// []</span><br><br><span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-string">&quot;foo&quot;</span>];<br>first  <span class="hljs-comment">// &quot;foo&quot;</span><br>rest   <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure></li><li><p>将<code>字符串</code>转为真正的<code>数组</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[...<span class="hljs-string">&#x27;hello&#x27;</span>]<br><span class="hljs-comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></code></pre></td></tr></table></figure></li><li><p>map获取key</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<br>  [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;one&#x27;</span>],<br>  [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;two&#x27;</span>],<br>  [<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;three&#x27;</span>],<br>]);<br><span class="hljs-keyword">let</span> arr = [...map.keys()]; <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="5-对象的扩展"><a href="#5-对象的扩展" class="headerlink" title="5 对象的扩展"></a>5 对象的扩展</h1><h2 id="5-1-属性的简洁表示法"><a href="#5-1-属性的简洁表示法" class="headerlink" title="5.1 属性的简洁表示法"></a>5.1 属性的简洁表示法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;x, y&#125;;<br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  <span class="hljs-comment">//等同于birth: birth</span><br>  birth,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-日志的打印"><a href="#5-2-日志的打印" class="headerlink" title="5.2 日志的打印"></a>5.2 日志的打印</h2><p>输出 user 和 foo 两个对象时，就是两组键值对，可能会混淆。把它们放在大括号里面输出，就变成了对象的简洁表示法，每组键值对前面会打印对象名，这样就比较清晰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span><br>&#125;;<br><span class="hljs-keyword">let</span> foo = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;baz&#x27;</span><br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(user, foo)<br><span class="hljs-comment">// &#123;name: &quot;test&quot;&#125; &#123;bar: &quot;baz&quot;&#125;</span><br><span class="hljs-built_in">console</span>.log(&#123;user, foo&#125;)<br><span class="hljs-comment">// &#123;user: &#123;name: &quot;test&quot;&#125;, foo: &#123;bar: &quot;baz&quot;&#125;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="5-3-解构赋值"><a href="#5-3-解构赋值" class="headerlink" title="5.3 解构赋值"></a>5.3 解构赋值</h2><ul><li><p>对象的<code>解构赋值</code>用于从一个对象<code>取值</code>，所有的键和它们的值，都会拷贝到新对象上面。</p></li><li><p>解构赋值要求等号右边是一个对象，所以如果等号右边是 undefined 或 null ，就会报错，因为它们无法转为对象。</p></li><li><p>解构赋值必须是最后一个参数，否则会报错。</p></li><li><p>解构赋值<code>的拷贝是</code>浅拷贝</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">4</span> &#125;;<br>x <span class="hljs-comment">// 1</span><br>y <span class="hljs-comment">// 2</span><br>z <span class="hljs-comment">// &#123; a: 3, b: 4 &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> z = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">4</span> &#125;;<br><span class="hljs-keyword">let</span> n = &#123; ...z &#125;;<br>n <span class="hljs-comment">// &#123; a: 3, b: 4 &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> foo = &#123; ...[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>] &#125;;<br>foo<br><span class="hljs-comment">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br></code></pre></td></tr></table></figure><ul><li>如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;...<span class="hljs-string">&#x27;hello&#x27;</span>&#125;<br><span class="hljs-comment">// &#123;0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="5-4-链判断运算符"><a href="#5-4-链判断运算符" class="headerlink" title="5.4 链判断运算符"></a>5.4 链判断运算符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> firstName = message?.body?.user?.firstName || <span class="hljs-string">&#x27;default&#x27;</span>;<br></code></pre></td></tr></table></figure><p>?. 运算符，直接在链式调用的时候判断，左侧的对象是否为 null 或 undefined 。如果是的，就不再往下运算，而是返回 undefined </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">a?.b<br><span class="hljs-comment">// 等同于</span><br>a == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : a.b<br>a?.[x]<br><span class="hljs-comment">// 等同于</span><br>a == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : a[x]<br>a?.b()<br><span class="hljs-comment">// 等同于</span><br>a == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : a.b()<br>a?.()<br><span class="hljs-comment">// 等同于</span><br>a == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : a()<br><br>表单可能没有 checkValidity 这个方法，这时 ?. 运算符就会返回 <span class="hljs-literal">undefined</span> ，判断语句就变成了 <span class="hljs-literal">undefined</span> === <span class="hljs-literal">false</span> ，所以就会跳过下面的代码。<br><span class="hljs-keyword">if</span> (myForm.checkValidity?.() === <span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-comment">// 表单校验失败</span><br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-判断运算符"><a href="#5-5-判断运算符" class="headerlink" title="5.5   ?? 判断运算符"></a>5.5   ?? 判断运算符</h2><p> <code>||</code>: 左侧的值如果为 null，undefined，空字符串， false ， 0 ，默认值会生效</p><p><code>??</code>: 左侧的值为 null 或 undefined 时，默认值会生效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> headerText = response.settings.headerText || <span class="hljs-string">&#x27;Hello, world!&#x27;</span>;<br><span class="hljs-keyword">const</span> headerText = response.settings.headerText ?? <span class="hljs-string">&#x27;Hello, world!&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="6-对象的新增方法"><a href="#6-对象的新增方法" class="headerlink" title="6 对象的新增方法"></a>6 对象的新增方法</h1><h2 id="6-1-Object-is"><a href="#6-1-Object-is" class="headerlink" title="6.1 Object.is()"></a>6.1 Object.is()</h2><ul><li><p><code>严格相等运算符</code>（ &#x3D;&#x3D;&#x3D; ） </p><ul><li>类型不同，直接返回false</li><li>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。</li><li>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false</li><li>undefined 和 null 与自身严格相等</li></ul></li><li><p><code>相等运算符</code>（ &#x3D;&#x3D; ）</p><ul><li>在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较</li></ul></li><li><p>Object.is()</p><ul><li><p>它用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致。</p></li><li><p>不同之处只有两个：一是 +0 不等于 -0 ，二是 NaN 等于自身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.is(+<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="6-2-Object-assign"><a href="#6-2-Object-assign" class="headerlink" title="6.2 Object.assign()"></a>6.2 Object.assign()</h2><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）</p><ul><li><code>Object.assign</code>方法实行的是<code>浅拷贝</code>，</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-built_in">Object</span>.assign(target, source1, source2);<br>target <span class="hljs-comment">// &#123;a:1, b:2, c:3&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bootstrap基本样式</title>
    <link href="/bootstrap%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F/"/>
    <url>/bootstrap%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h1><ul><li>class&#x3D;”border”  添加边框属性，</li><li>class&#x3D;”border-top” 显示指定边框。</li><li>class&#x3D;””border-0”：边框-删除</li><li>class&#x3D;”border-top-0“： 删除或显示特定边框</li><li><code>.rounded</code>元素可以轻松的定义四个圆角的孤度及显示效果</li></ul><h1 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h1><ul><li>.text-danger</li><li>.text-secondary</li><li>.text-success</li></ul><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h7ku4yzhrwj305n05fjrb.jpg"></p><h1 id="Flex弹性布局"><a href="#Flex弹性布局" class="headerlink" title="Flex弹性布局"></a>Flex弹性布局</h1><ul><li><p><code>d-flex </code>将 <strong>直属内部子元素</strong> 转换为flex属性</p></li><li><p><code>.flex-row</code> 可设置子元素水平方向排版呈现【单行】</p></li><li><p><code>.flex-row-reverse</code> 可实现元素在水平上作反方向排列, 右对齐</p></li><li><p><code>.flex-column</code> 设置垂直方向布局</p></li><li><p><code>.flex-column-reverse</code> 实现垂直方向的反转布局（从底向上铺开）</p></li><li><p><code>justify-content-*</code> 通用样式可以改变flx项目在主轴上的对齐，选方向（值）包括： <code>start</code> (浏览器默认值),、<code>end</code>、 <code>center</code>、 <code>between</code>、 <code>around</code></p></li><li><p><code>.flex-fill</code>在一系列兄弟元素上使用该类来强制它们变成相等的宽度，同时占据所有可用的水平空间。<a href="https://getbootstrap.net/docs/4.1/components/navs/#working-with-flex-utilities">特别适用于等宽或正确的导航。</a></p></li><li><p>向右推两个项目(<code>.mr-auto</code>)、向左推两个项目 (<code>.ml-auto</code>)，<strong>IE10和IE11不能正确支持在父层具有非默认的 <code>justify-content</code> 值自边距浮动auto margin</strong> </p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h7ksut55d5j30vj01m0sm.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;d-flex&quot;</span>&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mr-auto p-2&quot;</span>&gt;</span>Flex item<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p-2&quot;</span>&gt;</span>Flex item<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p-2&quot;</span>&gt;</span>Flex item<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>order-*</code>排序方法的响应式属性：</p></li><li><p><code>align-content</code> 通用样式定义，可以将flex物价于横轴上 <em>一起对齐</em>，适用于多行的Flex项目</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Data JPA 使用JPQL和SQL</title>
    <link href="/Spring-Data-JPA-%E4%BD%BF%E7%94%A8JPQL%E5%92%8CSQL/"/>
    <url>/Spring-Data-JPA-%E4%BD%BF%E7%94%A8JPQL%E5%92%8CSQL/</url>
    
    <content type="html"><![CDATA[<h1 id="2-spring-Data-JPA-使用JPQL"><a href="#2-spring-Data-JPA-使用JPQL" class="headerlink" title="2 spring Data JPA 使用JPQL"></a>2 spring Data JPA 使用JPQL</h1><p>JPQL（Java Presistence Query Language ）是EJB3.0中的JPA造出来的对象查询语言。JPQL是完全面向对象的，具备继承、多态和关联等特性，和hibernate HQL很相似。</p><ul><li>Repository 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.pyr.repositories;<br><br><span class="hljs-keyword">import</span> org.pyr.entity.Customer;<br><span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.Modifying;<br><span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.Query;<br><span class="hljs-keyword">import</span> org.springframework.data.repository.PagingAndSortingRepository;<br><span class="hljs-keyword">import</span> org.springframework.data.repository.query.Param;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomerJPQLRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PagingAndSortingRepository</span>&lt;<span class="hljs-title">Customer</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Query(&quot;From Customer where custName = :custName&quot;)</span><br>    <span class="hljs-function">Customer <span class="hljs-title">findCustomerByCustName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;custName&quot;)</span> String custName)</span></span>;<br><br>    <span class="hljs-meta">@Query(&quot;From Customer where custName = ?1&quot;)</span><br>    <span class="hljs-function">Customer <span class="hljs-title">findCustomerByCustName2</span><span class="hljs-params">(String custName)</span></span>;<br><br>    <span class="hljs-meta">@Transactional</span> <span class="hljs-comment">// 通常在业务逻辑中service增加，而不是这里</span><br>    <span class="hljs-meta">@Modifying</span><br>    <span class="hljs-meta">@Query(&quot;UPDATE Customer set custName = :custName where custId = :custId&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateCutomserNameById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;custName&quot;)</span> String custName, <span class="hljs-meta">@Param(&quot;custId&quot;)</span> <span class="hljs-keyword">long</span> custId)</span></span>;<br><br>    <span class="hljs-meta">@Transactional</span> <span class="hljs-comment">// 通常在业务逻辑中service增加，而不是这里</span><br>    <span class="hljs-meta">@Modifying</span><br>    <span class="hljs-meta">@Query(&quot;DELETE from Customer where custId = :custId&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteCutomserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;custId&quot;)</span> <span class="hljs-keyword">long</span> custId)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>测试方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.pyr;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.pyr.config.JPAConfig;<br><span class="hljs-keyword">import</span> org.pyr.entity.Customer;<br><span class="hljs-keyword">import</span> org.pyr.repositories.CustomerJPQLRepository;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br><br><span class="hljs-meta">@ContextConfiguration(classes = JPAConfig.class)</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JPATest2</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    CustomerJPQLRepository customerJPQLRepository;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindByName</span><span class="hljs-params">()</span></span>&#123;<br>        Customer customer = customerJPQLRepository.findCustomerByCustName(<span class="hljs-string">&quot;徐庶143&quot;</span>);<br>        System.out.println(customer);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindById</span><span class="hljs-params">()</span></span>&#123;<br>        Customer customer = customerJPQLRepository.findCustomerByCustName2(<span class="hljs-string">&quot;徐庶143&quot;</span>);<br>        System.out.println(customer);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span></span>&#123;<br>        customerJPQLRepository.updateCutomserNameById(<span class="hljs-string">&quot;lisa&quot;</span>, <span class="hljs-number">2L</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span></span>&#123;<br>        customerJPQLRepository.deleteCutomserById(<span class="hljs-number">2L</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-spring-Data-JPA-使用SQL"><a href="#3-spring-Data-JPA-使用SQL" class="headerlink" title="3  spring Data JPA 使用SQL"></a>3  spring Data JPA 使用SQL</h1><ul><li>Repository 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Query(value = &quot;select * from cst_customer where cust_name = :custName&quot;, nativeQuery = true)</span><br><span class="hljs-function">Customer <span class="hljs-title">findCustomerByCustNameWithNative</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;custName&quot;)</span> String custName)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindCustomerByCustNameWithNative</span><span class="hljs-params">()</span></span>&#123;<br>    Customer customer = customerJPQLRepository.findCustomerByCustNameWithNative(<span class="hljs-string">&quot;aa&quot;</span>);<br>    System.out.println(customer);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JPA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>springData JPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Data JPA 使用QueryDSL</title>
    <link href="/Spring-Data-JPA-%E4%BD%BF%E7%94%A8QueryDSL/"/>
    <url>/Spring-Data-JPA-%E4%BD%BF%E7%94%A8QueryDSL/</url>
    
    <content type="html"><![CDATA[<h1 id="1-QueryDSL-是什么？"><a href="#1-QueryDSL-是什么？" class="headerlink" title="1 QueryDSL 是什么？"></a>1 QueryDSL 是什么？</h1><ul><li><p>QueryDSL是基于ORM框架或SQL平台上的<strong>一个通用查询框架</strong>。借助QueryDSL可以在任何支持的ORM框架或SQL平台 <strong>上以通用API方式构建查询。</strong></p></li><li><p>JPA是QueryDSL的主要集成技术，是JPQL和Criteria查询的代替方法。目前QueryDSL支持的平台包括 JPA,JDO,SQL,Mongodb 等等</p></li><li><p>Querydsl扩展能让我们以<strong>链式方式代码编写查询方法</strong>。该扩展需要一个接口QueryDslPredicateExecutor，它定义了很多查询方法。</p></li></ul><h1 id="2-Spring-Data-JPA-使用QueryDSL"><a href="#2-Spring-Data-JPA-使用QueryDSL" class="headerlink" title="2 Spring Data JPA 使用QueryDSL"></a>2 Spring Data JPA 使用QueryDSL</h1><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java">    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>            &lt;artifactId&gt;druid&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">1.2</span><span class="hljs-number">.8</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/com.querydsl/querydsl-jpa --&gt;</span><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.querydsl&lt;/groupId&gt;<br>            &lt;artifactId&gt;querydsl-jpa&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">4.1</span><span class="hljs-number">.4</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">5.3</span><span class="hljs-number">.19</span>&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;<br>            &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">1.1</span><span class="hljs-number">.3</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.querydsl&lt;/groupId&gt;<br>            &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">4.2</span><span class="hljs-number">.1</span>&lt;/version&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>&lt;!--  Spring不同模块或者与外部进行集成时，依赖处理就需要各自对应版本号。BOM是由Maven提供的功能，用以统一间接或者直接依赖的类库版本--&gt;<br>&lt;!--    在maven的pom.xml中无需指定具体的类库版本，直接使用，即默认使用bom中指定的版本<br>&lt;dependencyManagement&gt;<br>        &lt;dependencies&gt;<br>            &lt;dependency&gt;<br>                &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;<br>                &lt;artifactId&gt;spring-data-bom&lt;/artifactId&gt;<br>                &lt;version&gt;<span class="hljs-number">2021.1</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>                &lt;scope&gt;<span class="hljs-keyword">import</span>&lt;/scope&gt;<br>                &lt;type&gt;pom&lt;/type&gt;<br>            &lt;/dependency&gt;<br>        &lt;/dependencies&gt;<br>    &lt;/dependencyManagement&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;!--该插件可以生成querysdl需要的查询对象(命名方式为：<span class="hljs-string">&quot;Q&quot;</span>+对应实体名，执行mvn compile即可--&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;<br>                &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt;<br>                &lt;executions&gt;<br>                    &lt;execution&gt;<br>                        &lt;goals&gt;<br>                            &lt;goal&gt;process&lt;/goal&gt;<br>                        &lt;/goals&gt;<br>                        &lt;configuration&gt;<br>                            &lt;outputDirectory&gt;target/generated‐sources/queries&lt;/outputDirectory&gt;<br>                            &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;/processor&gt;<br>                            &lt;logOnlyOnError&gt;<span class="hljs-keyword">true</span>&lt;/logOnlyOnError&gt;<br>                        &lt;/configuration&gt;<br>                    &lt;/execution&gt;<br>                &lt;/executions&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br></code></pre></td></tr></table></figure><h2 id="2-添加实体类和Jpa的配置"><a href="#2-添加实体类和Jpa的配置" class="headerlink" title="2 . 添加实体类和Jpa的配置"></a>2 . 添加实体类和Jpa的配置</h2><p>参考：[Spring data JPA的CRUD - 楼上有只喵 (pyr9.github.io)](<a href="https://pyr9.github.io/Spring">https://pyr9.github.io/Spring</a> data JPA的CRUD&#x2F;)</p><h2 id="3-编写Repository"><a href="#3-编写Repository" class="headerlink" title="3. 编写Repository"></a>3. 编写Repository</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.pyr.repositories;<br><br><span class="hljs-keyword">import</span> org.pyr.entity.Customer;<br><span class="hljs-keyword">import</span> org.springframework.data.querydsl.QuerydslPredicateExecutor;<br><span class="hljs-keyword">import</span> org.springframework.data.repository.CrudRepository;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomerRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">Customer</span>, <span class="hljs-title">Long</span>&gt; , <span class="hljs-title">QuerydslPredicateExecutor</span>&lt;<span class="hljs-title">Customer</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-编写测试类"><a href="#4-编写测试类" class="headerlink" title="4 编写测试类"></a>4 编写测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.pry;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.pyr.config.JPAConfig;<br><span class="hljs-keyword">import</span> org.pyr.entity.Customer;<br><span class="hljs-keyword">import</span> org.pyr.entity.QCustomer;<br><span class="hljs-keyword">import</span> org.pyr.repositories.CustomerRepository;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br><br><span class="hljs-meta">@ContextConfiguration(classes = JPAConfig.class)</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryDslTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    CustomerRepository customerRepository;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindOne</span><span class="hljs-params">()</span> </span>&#123;<br>        QCustomer qCustomer = QCustomer.customer;<br>        Customer customer = customerRepository.findOne(<br>                qCustomer.custId.eq(<span class="hljs-number">4L</span>)<br>                        .and(qCustomer.custName.eq(<span class="hljs-string">&quot;aa&quot;</span>))<br>        ).orElse(<span class="hljs-keyword">null</span>);<br>        System.out.println(customer);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span> </span>&#123;<br>        QCustomer qCustomer = QCustomer.customer;<br>        Iterable&lt;Customer&gt; customers = customerRepository.findAll(<br>                qCustomer.custId.in(<span class="hljs-number">4L</span>, <span class="hljs-number">5L</span>, <span class="hljs-number">6L</span>, <span class="hljs-number">7L</span>)<br>                        .and(qCustomer.custName.eq(<span class="hljs-string">&quot;aa&quot;</span>))<br>        );<br>        System.out.println(customers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JPA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springdata jpa</tag>
      
      <tag>queryDSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring data JPA的CRUD</title>
    <link href="/Spring%20data%20JPA%E7%9A%84CRUD/"/>
    <url>/Spring%20data%20JPA%E7%9A%84CRUD/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Spring-data-JPA的CRUD"><a href="#1-Spring-data-JPA的CRUD" class="headerlink" title="1 Spring data JPA的CRUD"></a>1 Spring data JPA的CRUD</h1><h2 id="1-1-引入依赖"><a href="#1-1-引入依赖" class="headerlink" title="1.1 引入依赖"></a>1.1 引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml">dependencies&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.19<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-2-配置spring-Data-JPA"><a href="#1-2-配置spring-Data-JPA" class="headerlink" title="1.2 配置spring Data JPA"></a>1.2 配置spring Data JPA</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.pyr.config;<br><br><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;<br><span class="hljs-keyword">import</span> org.springframework.orm.jpa.JpaTransactionManager;<br><span class="hljs-keyword">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;<br><span class="hljs-keyword">import</span> org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;<br><span class="hljs-keyword">import</span> org.springframework.transaction.PlatformTransactionManager;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;<br><br><span class="hljs-keyword">import</span> javax.persistence.EntityManagerFactory;<br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableJpaRepositories(&quot;org.pyr.repositories&quot;)</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JPAConfig</span> </span>&#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>    DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>    dataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>    dataSource.setPassword(<span class="hljs-string">&quot;19980617pyr&quot;</span>);<br>    dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>    dataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/springdata_jpa&quot;</span>);<br>    <span class="hljs-keyword">return</span> dataSource;<br>  &#125;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="hljs-title">entityManagerFactory</span><span class="hljs-params">()</span> </span>&#123;<br><br>    HibernateJpaVendorAdapter vendorAdapter = <span class="hljs-keyword">new</span> HibernateJpaVendorAdapter();<br>    vendorAdapter.setGenerateDdl(<span class="hljs-keyword">true</span>);<br><br>    LocalContainerEntityManagerFactoryBean factory = <span class="hljs-keyword">new</span> LocalContainerEntityManagerFactoryBean();<br>    factory.setJpaVendorAdapter(vendorAdapter);<br>    factory.setPackagesToScan(<span class="hljs-string">&quot;org.pyr.entity&quot;</span>);<br>    factory.setDataSource(dataSource());<br>    <span class="hljs-keyword">return</span> factory;<br>  &#125;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;<br><br>    JpaTransactionManager txManager = <span class="hljs-keyword">new</span> JpaTransactionManager();<br>    txManager.setEntityManagerFactory(entityManagerFactory);<br>    <span class="hljs-keyword">return</span> txManager;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-添加实体类"><a href="#1-3-添加实体类" class="headerlink" title="1.3 添加实体类"></a>1.3 添加实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.pyr.entity;<br><br><span class="hljs-keyword">import</span> javax.persistence.*;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;cst_customer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span></span>&#123;<br><br>    <span class="hljs-meta">@Id</span> <span class="hljs-comment">//声明主键的配置</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="hljs-comment">//:配置主键的生成策略: .IDENTITY ：自增，mysql</span><br>    <span class="hljs-meta">@Column(name = &quot;cust_id&quot;)</span> <span class="hljs-comment">// 配置属性和字段的映射关系  name：数据库表中字段的名称</span><br>    <span class="hljs-keyword">private</span> Long custId; <span class="hljs-comment">//客户的主键</span><br><br>    <span class="hljs-meta">@Column(name = &quot;cust_name&quot;)</span><br>    <span class="hljs-keyword">private</span> String custName;<span class="hljs-comment">//客户名称</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCustId</span><span class="hljs-params">(Long custId)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.custId = custId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCustName</span><span class="hljs-params">(String custName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.custName = custName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Customer&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;custId=&quot;</span> + custId +<br>                <span class="hljs-string">&quot;, custName=&#x27;&quot;</span> + custName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-4-编写Repository"><a href="#1-4-编写Repository" class="headerlink" title="1.4 编写Repository"></a>1.4 编写Repository</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.pyr.repositories;<br><br><span class="hljs-keyword">import</span> org.pyr.entity.Customer;<br><span class="hljs-keyword">import</span> org.springframework.data.repository.CrudRepository;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomerRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">Customer</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-4-编写测试类"><a href="#1-4-编写测试类" class="headerlink" title="1.4 编写测试类"></a>1.4 编写测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.pyr;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.pyr.config.JPAConfig;<br><span class="hljs-keyword">import</span> org.pyr.entity.Customer;<br><span class="hljs-keyword">import</span> org.pyr.repositories.CustomerRepository;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br><br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-meta">@ContextConfiguration(classes = JPAConfig.class)</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JPATest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    CustomerRepository customerRepository;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFind</span><span class="hljs-params">()</span></span>&#123;<br>        Optional&lt;Customer&gt; customer = customerRepository.findById(<span class="hljs-number">3L</span>);<br>        System.out.println(customer.get());<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSave</span><span class="hljs-params">()</span></span>&#123;<br>        Customer customer = <span class="hljs-keyword">new</span> Customer();<br>        customer.setCustName(<span class="hljs-string">&quot;aa&quot;</span>);<br>        customerRepository.save(customer);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span></span>&#123;<br>        Customer customer = <span class="hljs-keyword">new</span> Customer();<br>        customer.setCustId(<span class="hljs-number">3L</span>);<br>        customer.setCustName(<span class="hljs-string">&quot;aa123&quot;</span>);<br>        customerRepository.save(customer);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span></span>&#123;<br>        Customer customer = <span class="hljs-keyword">new</span> Customer();<br>        customer.setCustId(<span class="hljs-number">3L</span>);<br>        customer.setCustName(<span class="hljs-string">&quot;aa123&quot;</span>);<br>        customerRepository.delete(customer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JPA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>springData JPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于JPA的数据库操作</title>
    <link href="/%E5%9F%BA%E4%BA%8EJPA%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <url>/%E5%9F%BA%E4%BA%8EJPA%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>产生原因：<strong>如果单独使用hibernate的API来进行持久化操作，则不能随意切换其他ORM框架</strong></p><h1 id="1-操作步骤"><a href="#1-操作步骤" class="headerlink" title="1 操作步骤"></a>1 操作步骤</h1><h2 id="1-1-导入依赖"><a href="#1-1-导入依赖" class="headerlink" title="1.1 导入依赖"></a>1.1 导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.6.8.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-2-添加META-INF-persistence-xml"><a href="#1-2-添加META-INF-persistence-xml" class="headerlink" title="1.2 添加META-INF\persistence.xml"></a>1.2 添加META-INF\persistence.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">persistence</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/persistence&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--需要配置persistence‐unit节点持久化单元：name：持久化单元名称</span><br><span class="hljs-comment">    transaction‐type：事务管理的方式 JTA：分布式事务管理 RESOURCE_LOCAL：本地事务管理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">persistence-unit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernateJPA&quot;</span> <span class="hljs-attr">transaction-type</span>=<span class="hljs-string">&quot;RESOURCE_LOCAL&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--        jpa的实现方式 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">provider</span>&gt;</span>org.hibernate.jpa.HibernatePersistenceProvider<span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--            配置jpa实现方的配置信息--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;javax.persistence.jdbc.url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/springdata_jpa&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;javax.persistence.jdbc.user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;javax.persistence.jdbc.password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;19980617pyr&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;javax.persistence.jdbc.driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!--            配置jpa实现方(hibernate)的配置信息--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.show_sql&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.format_sql&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.hbm2ddl.auto&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;update&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.dialect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.hibernate.dialect.MySQL5InnoDBDialect&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">persistence-unit</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">persistence</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-3-增加测试实体类"><a href="#1-3-增加测试实体类" class="headerlink" title="1.3 增加测试实体类"></a>1.3 增加测试实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> entity;<br><br><span class="hljs-keyword">import</span> javax.persistence.*;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;cst_customer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span></span>&#123;<br><br>    <span class="hljs-meta">@Id</span> <span class="hljs-comment">//声明主键的配置</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="hljs-comment">//:配置主键的生成策略: .IDENTITY ：自增，mysql</span><br>    <span class="hljs-meta">@Column(name = &quot;cust_id&quot;)</span> <span class="hljs-comment">// 配置属性和字段的映射关系  name：数据库表中字段的名称</span><br>    <span class="hljs-keyword">private</span> Long custId; <span class="hljs-comment">//客户的主键</span><br><br>    <span class="hljs-meta">@Column(name = &quot;cust_name&quot;)</span><br>    <span class="hljs-keyword">private</span> String custName;<span class="hljs-comment">//客户名称</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCustId</span><span class="hljs-params">(Long custId)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.custId = custId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCustName</span><span class="hljs-params">(String custName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.custName = custName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Customer&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;custId=&quot;</span> + custId +<br>                <span class="hljs-string">&quot;, custName=&#x27;&quot;</span> + custName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h2><p><strong>准备工作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    EntityManager entityManager;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(<span class="hljs-string">&quot;hibernateJPA&quot;</span>);<br>        entityManager = entityManagerFactory.createEntityManager();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Save"><a href="#Save" class="headerlink" title="Save"></a>Save</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSave</span><span class="hljs-params">()</span> </span>&#123;<br>       EntityTransaction transaction = entityManager.getTransaction();<br>       transaction.begin();<br><br>       Customer customer = <span class="hljs-keyword">new</span> Customer();<br>       customer.setCustName(<span class="hljs-string">&quot;张三&quot;</span>);<br>       entityManager.persist(customer);<br><br>       transaction.commit();<br>       entityManager.close();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRemove</span><span class="hljs-params">()</span> </span>&#123;<br>        EntityTransaction transaction = entityManager.getTransaction();<br>        transaction.begin();<br><span class="hljs-comment">//        Customer customer =new Customer();</span><br><span class="hljs-comment">//        customer.setCustId(3L);</span><br>        Customer customer = entityManager.find(Customer.class, <span class="hljs-number">3L</span>);<br>        entityManager.remove(customer);<br>        transaction.commit();<br>        entityManager.close();<br>    &#125;<br></code></pre></td></tr></table></figure><p>⚠️：这里要删除的对象需要是数据库里查询到的，和entityManager发生过关联的对象，即持久状态。或者使用HQL。new出来的对象无法完成删除逻辑。</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>    EntityTransaction transaction = entityManager.getTransaction();<br>    transaction.begin();<br><br>    Customer customer = <span class="hljs-keyword">new</span> Customer();<br>    customer.setCustName(<span class="hljs-string">&quot;张三123&quot;</span>);<br>    customer.setCustId(<span class="hljs-number">3L</span>);<br>    <span class="hljs-comment">// 指定id即更新，没有id就新增</span><br>    Customer rs = entityManager.merge(customer);<br>    System.out.println(rs);<br>    transaction.commit();<br>    entityManager.close();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>HQLUpdate</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHQLUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>    EntityTransaction transaction = entityManager.getTransaction();<br>    transaction.begin();<br><br>    String sqlQuery = <span class="hljs-string">&quot;update Customer set custName=:name where custId=:id&quot;</span>;<br>    entityManager.createQuery(sqlQuery)<br>            .setParameter(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;徐庶143&quot;</span>)<br>            .setParameter(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">2L</span>)<br>            .executeUpdate();<br><br>    transaction.commit();<br>    entityManager.close();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Sql查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSQLUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>    EntityTransaction transaction = entityManager.getTransaction();<br>    transaction.begin();<br><br>    String sqlQuery = <span class="hljs-string">&quot;update cst_customer set cust_id=:name where cust_name=:id&quot;</span>;<br>    entityManager.createNativeQuery(sqlQuery)<br>            .setParameter(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;徐庶123&quot;</span>)<br>            .setParameter(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">2L</span>)<br>            .executeUpdate();<br><br>    transaction.commit();<br>    entityManager.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>⚠️：这里使用createNativeQuery，表明和字段名都换成小写</p><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><ul><li>立即查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFind</span><span class="hljs-params">()</span> </span>&#123;<br>    EntityTransaction transaction = entityManager.getTransaction();<br>    transaction.begin();<br><br>    Customer rs = entityManager.find(Customer.class, <span class="hljs-number">3L</span>);<br>    System.out.println(<span class="hljs-string">&quot;========================&quot;</span>);<br>    System.out.println(rs);<br>    transaction.commit();<br>    entityManager.close();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>懒加载查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLazyFind</span><span class="hljs-params">()</span> </span>&#123;<br>    EntityTransaction transaction = entityManager.getTransaction();<br>    transaction.begin();<br><br>    Customer rs = entityManager.getReference(Customer.class, <span class="hljs-number">3L</span>);<br>    System.out.println(<span class="hljs-string">&quot;========================&quot;</span>);<br>    System.out.println(rs);<br>    transaction.commit();<br>    entityManager.close();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>HQL查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.<span class="hljs-function">Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHQLSelect</span><span class="hljs-params">()</span> </span>&#123;<br>    EntityTransaction transaction = entityManager.getTransaction();<br>    transaction.begin();<br><br>    String sqlQuery = <span class="hljs-string">&quot;select c from Customer c&quot;</span>;<br>    Query query = entityManager.createQuery(sqlQuery);<br>    List&lt;Customer&gt; resultList = query.getResultList();<br>    resultList.forEach(System.out::println);<br><br>    transaction.commit();<br>    entityManager.close();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JPA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Hibernate数据库操作</title>
    <link href="/%E5%9F%BA%E4%BA%8EHibernate%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <url>/%E5%9F%BA%E4%BA%8EHibernate%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基于Hibernate数据库操作"><a href="#1-基于Hibernate数据库操作" class="headerlink" title="1 基于Hibernate数据库操作"></a>1 基于Hibernate数据库操作</h1><h2 id="1-1-操作步骤"><a href="#1-1-操作步骤" class="headerlink" title="1.1 操作步骤"></a>1.1 操作步骤</h2><h3 id="1-1-1-导入依赖"><a href="#1-1-1-导入依赖" class="headerlink" title="1.1.1 导入依赖"></a>1.1.1 导入依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;mysql&lt;/groupId&gt;<br>    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">8.0</span><span class="hljs-number">.29</span>&lt;/version&gt;<br>    &lt;scope&gt;test&lt;/scope&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">5.6</span><span class="hljs-number">.8</span>.Final&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="1-1-2-增加实体类"><a href="#1-1-2-增加实体类" class="headerlink" title="1.1.2 增加实体类"></a>1.1.2 增加实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> tt.pyr.entity;<br><br><span class="hljs-keyword">import</span> javax.persistence.*;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;cst_customer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Id</span> <span class="hljs-comment">//声明主键的配置</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="hljs-comment">//:配置主键的生成策略: .IDENTITY ：自增，mysql</span><br>    <span class="hljs-meta">@Column(name = &quot;cust_id&quot;)</span> <span class="hljs-comment">// 配置属性和字段的映射关系  name：数据库表中字段的名称</span><br>    <span class="hljs-keyword">private</span> Long custId; <span class="hljs-comment">//客户的主键</span><br><br>    <span class="hljs-meta">@Column(name = &quot;cust_name&quot;)</span><br>    <span class="hljs-keyword">private</span> String custName;<span class="hljs-comment">//客户名称</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCustId</span><span class="hljs-params">(Long custId)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.custId = custId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCustName</span><span class="hljs-params">(String custName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.custName = custName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-3-配置hibernate-cfg-xml"><a href="#1-1-3-配置hibernate-cfg-xml" class="headerlink" title="1.1.3 配置hibernate.cfg.xml"></a>1.1.3 配置<strong>hibernate.cfg.xml</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version = <span class="hljs-string">&quot;1.0&quot;</span> encoding = <span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>        <span class="hljs-string">&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span><br>        <span class="hljs-string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;<br>&lt;hibernate-configuration&gt;<br>    &lt;session-factory&gt;<br>        &lt;property name=<span class="hljs-string">&quot;hibernate.connection.url&quot;</span>&gt;jdbc:mysql:<span class="hljs-comment">//localhost:3306/springdata_jpa&lt;/property&gt;</span><br>        &lt;property name=<span class="hljs-string">&quot;hibernate.connection.username&quot;</span>&gt;root&lt;/property&gt;<br>        &lt;property name=<span class="hljs-string">&quot;hibernate.connection.password&quot;</span>&gt;19980617pyr&lt;/property&gt;<br>        &lt;property name=<span class="hljs-string">&quot;hibernate.connection.driver_class&quot;</span>&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;<br>        &lt;property name=<span class="hljs-string">&quot;hibernate.show_sql&quot;</span>&gt;<span class="hljs-keyword">true</span>&lt;/property&gt;<br>        &lt;property name=<span class="hljs-string">&quot;format_sql&quot;</span>&gt;<span class="hljs-keyword">true</span>&lt;/property&gt;<br>        &lt;property name=<span class="hljs-string">&quot;hbm2ddl.auto&quot;</span>&gt;update&lt;/property&gt;<br>        &lt;mapping <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;tt.pyr.entity.Customer&quot;</span>&gt;&lt;/mapping&gt;<br>    &lt;/session-factory&gt;<br>&lt;/hibernate-configuration&gt;<br><br></code></pre></td></tr></table></figure><h3 id="1-1-4-编写测试用例"><a href="#1-1-4-编写测试用例" class="headerlink" title="1.1.4 编写测试用例"></a>1.1.4 编写测试用例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<br><br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.Transaction;<br><span class="hljs-keyword">import</span> org.hibernate.boot.MetadataSources;<br><span class="hljs-keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistry;<br><span class="hljs-keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistryBuilder;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> tt.pyr.entity.Customer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HibernateTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> SessionFactory sf;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        StandardServiceRegistry registry = <span class="hljs-keyword">new</span> StandardServiceRegistryBuilder().configure(<span class="hljs-string">&quot;/hibernate.cfg.xml&quot;</span>).build();<br>        <span class="hljs-comment">//2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂</span><br>        sf = <span class="hljs-keyword">new</span> MetadataSources(registry).buildMetadata().buildSessionFactory();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;<br>        Session sess = sf.openSession();<br>        Transaction tx = sess.beginTransaction();<br>        Customer customer = <span class="hljs-keyword">new</span> Customer();<br>        customer.setCustName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        sess.save(customer);<br>        tx.commit();<br>        sess.close();<br>        sf.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSaveOrUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>        Session sess = sf.openSession();<br>        Transaction tx = sess.beginTransaction();<br>        Customer customer = <span class="hljs-keyword">new</span> Customer();<br>        customer.setCustName(<span class="hljs-string">&quot;里斯&quot;</span>);<br>        sess.saveOrUpdate(customer);<br>        tx.commit();<br>        sess.close();<br>        sf.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRemove</span><span class="hljs-params">()</span> </span>&#123;<br>        Session sess = sf.openSession();<br>        Transaction tx = sess.beginTransaction();<br>        Customer customer = <span class="hljs-keyword">new</span> Customer();<br>        customer.setCustId(<span class="hljs-number">1L</span>);<br>        sess.remove(customer);<br>        tx.commit();<br>        sess.close();<br>        sf.close();<br>    &#125;<br>  <br>      <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHQL</span><span class="hljs-params">()</span> </span>&#123;<br>        Session sess = sf.openSession();<br>        Transaction tx = sess.beginTransaction();<br><br>        String sql = <span class="hljs-string">&quot;Update Customer set custName=:custName where custId=:id&quot;</span>;<br>        sess.createQuery(sql).setParameter(<span class="hljs-string">&quot;custName&quot;</span>, <span class="hljs-string">&quot;徐庶&quot;</span>).setParameter(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">2L</span>).executeUpdate();<br>        tx.commit();<br>        sess.close();<br>        sf.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-HQL"><a href="#1-2-HQL" class="headerlink" title="1.2 HQL"></a>1.2 HQL</h2><h3 id="1-2-1-是什么？"><a href="#1-2-1-是什么？" class="headerlink" title="1.2.1 是什么？"></a>1.2.1 是什么？</h3><ul><li>HQL是Hibernate Query Language（Hibernate 查询语言）的缩写，提供更加丰富灵活、更为强大的查询能力；HQL更接近SQL语句查询语法。</li><li>Hibernate查询语言(HQL)与SQL(结构化查询语言)相同，但不依赖于数据库表。 我们在HQL中使用类名，而不是表名,它是数据库独立的查询语言。</li></ul><h3 id="1-1-2-HQL查询的步骤"><a href="#1-1-2-HQL查询的步骤" class="headerlink" title="1.1.2 HQL查询的步骤"></a>1.1.2 HQL查询的步骤</h3><ul><li>获得Hibernate Session对象</li><li>编写HQL语句</li><li>调用Session的createQuery方法创建查询对象</li><li>如果HQL语句包含参数，则调用Query的setXxx方法为参数赋值</li><li>调用Query对象的list等方法返回查询结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<br><br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.Transaction;<br><span class="hljs-keyword">import</span> org.hibernate.boot.MetadataSources;<br><span class="hljs-keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistry;<br><span class="hljs-keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistryBuilder;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> tt.pyr.entity.Customer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HibernateTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> SessionFactory sf;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        StandardServiceRegistry registry = <span class="hljs-keyword">new</span> StandardServiceRegistryBuilder().configure(<span class="hljs-string">&quot;/hibernate.cfg.xml&quot;</span>).build();<br>        sf = <span class="hljs-keyword">new</span> MetadataSources(registry).buildMetadata().buildSessionFactory();<br>    &#125;<br>  <br>      <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHQL</span><span class="hljs-params">()</span> </span>&#123;<br>        Session sess = sf.openSession();<br>        Transaction tx = sess.beginTransaction();<br><br>        String sql = <span class="hljs-string">&quot;Update Customer set custName=:custName where custId=:id&quot;</span>;<br>        sess.createQuery(sql).setParameter(<span class="hljs-string">&quot;custName&quot;</span>, <span class="hljs-string">&quot;徐庶&quot;</span>).setParameter(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">2L</span>).executeUpdate();<br>        tx.commit();<br>        sess.close();<br>        sf.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JPA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Hibernate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JPA和hibernate和SpringDataJpa</title>
    <link href="/JPA%E5%92%8Chibernate%E5%92%8CSpringDataJpa/"/>
    <url>/JPA%E5%92%8Chibernate%E5%92%8CSpringDataJpa/</url>
    
    <content type="html"><![CDATA[<p>Java访问持久层的两种方式</p><ul><li>以Sql为核心，封装一定程度的JDBC操作，比如mybatis</li><li>以Java实体类为核心，将实体类和数据表之间建立连接，也就是我们说的ORM框架，比如：Hibernate,SpringData jpa</li></ul><h1 id="1-JPA"><a href="#1-JPA" class="headerlink" title="1. JPA"></a>1. JPA</h1><p>JPA顾名思义就是Java Persistence API的意思</p><ul><li>使用注解或XML描述对象－关系表的映射关系</li><li>将运行期的实体对象持久化到数据库中</li><li>定义了一些接口。</li></ul><h1 id="2-hibernate"><a href="#2-hibernate" class="headerlink" title="2. hibernate"></a>2. hibernate</h1><p>Hibernate就是实现了JPA接口的ORM框架。</p><h1 id="3-Spring-Data-JPA"><a href="#3-Spring-Data-JPA" class="headerlink" title="3 Spring Data JPA"></a>3 <strong>Spring Data JPA</strong></h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h2><ul><li><p>Spring Data JPA是spring提供的一套 <strong>JPA 应用框架</strong>。</p></li><li><p>SpringDataJpa可以理解为JPA规范的再次封装抽象，底层还是使用了Hibernate的Jpa技术实现。</p></li><li><p>Spring Data JPA旨在通过将统一ORM框架的访问持久层的操作，来提高开发人的效率。</p></li><li><p>虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换仍然需要编写不同的代码，而使用<strong>Spring Data JPA能够方便大家在不同的ORM框架之间进行切换而不需要更改代码</strong>。</p></li><li><p>按照约定好的规则进行【方法命名】去写dao层接口，就可以在不写接口实现的情况下，实现对数据库的访问和操作。同时提供了很多除了CRUD之外的功能，如分页、排序、复杂查询等等</p></li><li><p>Spring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现,</p></li></ul><h2 id="3-2-Spring-Data-JPA给我们提供的主要的类和接口"><a href="#3-2-Spring-Data-JPA给我们提供的主要的类和接口" class="headerlink" title="3.2  Spring Data JPA给我们提供的主要的类和接口"></a>3.2  <strong>Spring Data JPA给我们提供的主要的类和接口</strong></h2><ul><li><p>Repository 接口：</p><ul><li><p>Repository</p></li><li><p>CrudRepository</p></li><li><p>JpaRepository &#x3D; 基本<code>CRUD</code>功能+分页+按“实例”查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagingAndSortingRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt;, <span class="hljs-title">QueryByExampleExecutor</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>Repository 实现类：</p><ul><li><p>SimpleJpaRepository</p></li><li><p>QueryDslJpaRepository</p></li></ul></li></ul><h1 id="4-JPA、hibernate、Spring-Data-Jpa关系"><a href="#4-JPA、hibernate、Spring-Data-Jpa关系" class="headerlink" title="4 JPA、hibernate、Spring Data Jpa关系"></a>4 JPA、hibernate、Spring Data Jpa关系</h1><ul><li><p>JPA是一个规范，也就是说它仅仅定义了一些接口</p></li><li><p>Hibernate就是实现了JPA接口的ORM框架</p></li><li><p>SpringDataJpa是Spring提供的一套简化JPA开发的框架。可以理解为JPA规范的再次封装抽象，底层还是使用了Hibernate的Jpa技术实现。</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230320175230013.png" alt="image-20230320175230013"></p><h1 id="5-Spring-Data-JPA和Hibernate的关系"><a href="#5-Spring-Data-JPA和Hibernate的关系" class="headerlink" title="5 Spring Data JPA和Hibernate的关系"></a>5 <strong>Spring Data JPA和Hibernate的关系</strong></h1><ul><li>Hibernate其实是JPA的一种实现，而Spring Data JPA是一个JPA数据访问抽象。</li><li>pring Data JPA不是一个实现或JPA提供的程序，它只是一个抽象层，主要用于减少为各种持久层存储实现数据访问层所需的样板代码量。但是它还是需要JPA提供实现程序。</li><li>Spring Data JPA是一种JPA的抽象层，底层依赖Hibernate</li></ul><h1 id="6-mybatis-和hibernate的对比？"><a href="#6-mybatis-和hibernate的对比？" class="headerlink" title="6 mybatis 和hibernate的对比？"></a>6 mybatis 和hibernate的对比？</h1><p>（1）hibernate是全自动，而mybatis是半自动。</p><p>hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p><p>（2）hibernate数据库移植性远大于mybatis</p><p>hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</p><p>（3）hibernate拥有完整的日志系统，mybatis则欠缺一些</p><p>hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。</p><p>（4）sql直接优化上，mybatis要比hibernate方便很多</p><p>由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；</p>]]></content>
    
    
    <categories>
      
      <category>JPA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue入门</title>
    <link href="/Vue%E5%85%A5%E9%97%A8/"/>
    <url>/Vue%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Vue是什么？"><a href="#1-Vue是什么？" class="headerlink" title="1 Vue是什么？"></a>1 Vue是什么？</h1><ul><li>vue是一套JavaScript框架</li><li>Vue可以简化Dom操作</li><li>响应式数据驱动</li></ul><h1 id="2-hello-world"><a href="#2-hello-world" class="headerlink" title="2 hello world"></a>2 hello world</h1><ol><li>导入Vue</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建Vue实例对象，设置el属性和data属性</li><li>使用简洁的模板语法把数据渲染到页面上</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;body&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &#123;&#123;message&#125;&#125;<br>  &lt;/div&gt;<br>  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;<br>  &lt;script&gt;<br>   var app = new Vue(&#123;<br>     el:&quot;#app&quot;,<br>     data:&#123;<br>       message: &quot;hello world!&quot;<br>     &#125;<br>   &#125;)<br>  &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h1 id="3-el挂载点"><a href="#3-el挂载点" class="headerlink" title="3 el挂载点"></a>3 el挂载点</h1><ul><li><p>el是用来设置<strong>vue实例挂载</strong>的元素</p></li><li><p>Vue会管理el选项<strong>命中的元素</strong>以及其内部的<strong>后代元素</strong></p></li><li><p>可以使用其他的选择器，但是<strong>建议使用id选择器</strong></p></li><li><p>可以使用其他的双标签，不能使用HTML或者body</p></li></ul><h1 id="4-data数据对象"><a href="#4-data数据对象" class="headerlink" title="4 data数据对象"></a>4 data数据对象</h1><ul><li>vue中用到的对象定义在data中</li><li>Data中可以写复杂类型的数据，比如对象，数组</li><li>渲染复杂类型的数据，遵循js的语法即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;body&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &#123;&#123;message&#125;&#125;<br>    &#123;&#123;school.name&#125;&#125;<br>    &#123;&#123;school.age&#125;&#125;<br>    &lt;ul&gt;<br>      &lt;li&gt;&#123;&#123;hoobies[0]&#125;&#125;&lt;/li&gt;<br>      &lt;li&gt;&#123;&#123;hoobies[2]&#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>  &lt;/div&gt;<br>  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;<br>  &lt;script&gt;<br>    var app = new Vue(&#123;<br>      el: &quot;#app&quot;,<br>      data: &#123;<br>        message: &quot;hello world!&quot;,<br>        school: &#123;<br>          name: &quot;张三&quot;,<br>          age: 14<br>        &#125;,<br>        hoobies: [&quot;唱歌&quot;, &quot;跳舞&quot;, &quot;弹琴&quot;]<br>      &#125;<br>    &#125;)<br>  &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h2 id="5-模版语法"><a href="#5-模版语法" class="headerlink" title="5 模版语法"></a>5 模版语法</h2><ul><li><code> &#123;&#123; message &#125;&#125;</code> 展示字符串文本</li><li><code>v-bind:class=&quot;&#39;btnb tn-sm&#39;&quot;</code> 绑定属性</li></ul><img src="/Users/panyurou/Library/Application Support/typora-user-images/image-20221023232100807.png" alt="image-20221023232100807" style="zoom:50%;" /><ul><li><p><code>v-html</code>: 翻译成html标签</p></li><li><p><code>&#123;&#123; ok ? 'YES':'No' &#125;&#125;</code> 三元运算</p></li><li><p><code>&#123;&#123; message.spilt('').join(',') &#125;&#125;</code>:  vue支持js表达式</p></li><li><p>V-if 控制元素是否切换</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div id=&quot;app-3&quot;&gt;<br>  &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app3 = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app-3&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">seen</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>@click 绑定事件</li></ul><img src="/Users/panyurou/Library/Application Support/typora-user-images/image-20221023231840513.png" alt="image-20221023231840513" style="zoom:50%;" /> <p>![image-20221023232442286](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221023232442286.png)</p><ul><li>可以定义请求返回的数据的格式</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span>: function () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        isEdit: <span class="hljs-literal">false</span>,<br>        businessDataFromApi: <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br> getBusinessDataByQueryApi() &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.queryApi !== undefined) &#123;<br>                let url = `$&#123;<span class="hljs-keyword">this</span>.$store.state[<span class="hljs-keyword">this</span>.entity].baseModuleUrl&#125;/$&#123;<span class="hljs-keyword">this</span>.entity&#125;/` + <span class="hljs-keyword">this</span>.queryApi;<br>                <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">&#x27;api/post&#x27;</span>, &#123;<br>                    url: url,<br>                    <span class="hljs-keyword">data</span>: &#123;<br>                        idFilter: <span class="hljs-keyword">this</span>.businessData.id === undefined ? <span class="hljs-keyword">this</span>.$route.query.id : <span class="hljs-keyword">this</span>.businessData.id<br>                    &#125;<br>                &#125;).then(response =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (response.<span class="hljs-keyword">data</span>.list.length === <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">this</span>.businessDataFromApi = response.<span class="hljs-keyword">data</span>.list[<span class="hljs-number">0</span>];<br>                    &#125;<br>                &#125;)<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><ul><li>![image-20221024231200647](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221024231200647.png)</li></ul><p>![image-20221024231215526](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221024231215526.png)</p><p>- </p><ul><li><pre><code class="hljs">handleClick(col, $event) </code></pre></li><li><p>@click&#x3D;”handleClick()” 和@click&#x3D;”handleClick”的区别在于：第一个拿不到event事件，如果要拿到事件，需要写成@click&#x3D;”handleClick($event)”</p></li><li><p>阻止默认行为@click.prevent</p></li><li><p>@click.once 只执行一次事件触发</p></li><li><p>@click.self 只有e.target &#x3D; e.currentTarget的时候才会执行</p><img src="/Users/panyurou/Library/Application Support/typora-user-images/image-20221108210854373.png" alt="image-20221108210854373" style="zoom: 33%;" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mongodb集群</title>
    <link href="/Mongodb%E9%9B%86%E7%BE%A4/"/>
    <url>/Mongodb%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-主从模式"><a href="#1-主从模式" class="headerlink" title="1. 主从模式"></a>1. 主从模式</h1><p>主从最大的问题就是无法自动故障转移，对于简单的主从复制无法自动故障转移的缺陷，各个数据库都在改进，MySQL推出的Fabric ，Redis的哨兵，Mongodb的复制集。</p><h1 id="2-复制集模式"><a href="#2-复制集模式" class="headerlink" title="2. 复制集模式"></a>2. 复制集模式</h1><ul><li>Mongodb复制集（Replication Set）由一组Mongod实例（进程）组成，包含一个 Primary节点和多个Secondary节点</li><li>Mongodb Driver（客户端）的所有数据都写入 ，Primary，Secondary从Primary同步写入的数据，以保持复制集内所有成员存储相同的数据集，提供数据的高可用</li><li>从节点会从oplog拉数据，类似mysql的binlog</li><li>在实现高可用的同时，复制集实现了其他几个附加作用: <ul><li>数据分发: 将数据从一个区域复制到另一个区域，减少另一个区域的读延迟 </li><li>读写分离: 不同类型的压力分别在不同的节点上执行 </li><li>异地容灾: 在数据中心故障时候快速切换到异地</li></ul></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224723229.png" alt="image-20230228224723229"></p><h2 id="2-1-三节点复制集模式"><a href="#2-1-三节点复制集模式" class="headerlink" title="2.1 三节点复制集模式"></a>2.1 <strong>三节点复制集模式</strong></h2><p>常见的复制集架构由3个成员节点组成，其中存在几种不同的模式</p><h3 id="2-1-1-PSS模式（官方推荐模式）"><a href="#2-1-1-PSS模式（官方推荐模式）" class="headerlink" title="2.1.1 PSS模式（官方推荐模式）"></a>2.1.1 <strong>PSS模式（官方推荐模式）</strong></h3><ul><li><p>PSS模式由一个主节点和两个备节点所组成，即Primary+Secondary+Secondary</p></li><li><p>此模式始终提供数据集的两个完整副本，如果主节点不可用，则复制集选择备节点作为主节 点并继续正常操作。</p></li><li><p>旧的主节点在可用时重新加入复制集。</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224732217.png" alt="image-20230228224732217"></p><h3 id="2-1-2-PSA模式（官方推荐模式）"><a href="#2-1-2-PSA模式（官方推荐模式）" class="headerlink" title="2.1.2 *PSA模式（官方推荐模式）*"></a>2.1.2 *<em><strong>PSA</strong>模式（官方推荐模式）</em>*</h3><ul><li>PSA模式由一个主节点、一个备节点和一个仲裁者节点组成，即 Primary+Secondary+Arbiter </li><li>此模式仅提供数据的一个完整副本，如果主节点不可用，则复制 集将选择备节点作为主节点。</li><li>Arbiter节点不存储数据副本，也不提供业务的读写操作。Arbiter节点发生故障不影 响业务，仅影响选举投票。因为需要半数选举，但机器成本不够再申请一台</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224740040.png" alt="image-20230228224740040"></p><h1 id="3-分片集群架构"><a href="#3-分片集群架构" class="headerlink" title="3 分片集群架构"></a>3 <strong>分片集群架构</strong></h1><p>MongoDB 分片集群（Sharded Cluster）是对数据进行水平扩展的一种方式</p><h2 id="3-1-使用场景"><a href="#3-1-使用场景" class="headerlink" title="3.1 使用场景"></a>3.1 使用场景</h2><ul><li>写IOPS超出单个MongoDB节点的写服务能力</li><li>存储容量需求超出单机的磁盘容量。 </li><li>活跃的数据集超出单机内存容量，导致很多请求都要从磁盘读取数据，影响性 能</li></ul>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集群</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch集群架构</title>
    <link href="/ElasticSearch%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/"/>
    <url>/ElasticSearch%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-ES集群架构"><a href="#1-ES集群架构" class="headerlink" title="1 ES集群架构"></a>1 <strong>ES集群架构</strong></h1><ul><li><p>一个集群可以有一个或者多个节点 </p></li><li><p>不同的集群通过不同的名字来区分，默认名字“elasticsearch“ </p></li><li><p>通过配置文件修改，或者在命令行中 -E cluster.name&#x3D;es-cluster进行设定</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221740498.png" alt="image-20230228221740498"></p><h1 id="2-集群节点类型"><a href="#2-集群节点类型" class="headerlink" title="2  集群节点类型"></a>2  集群节点类型</h1><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221752056.png" alt="image-20230228221752056"></p><ul><li><p>Master Node：主节点 </p><ul><li><p>处理创建，删除索引等请求，负责索引的创建与删除</p></li><li><p>决定分片被分配到哪个节点</p></li><li><p>管理集群节点状态</p></li></ul></li><li><p>Master eligible nodes：</p><ul><li>可以参与选举的合格节点 </li><li>每个节点启动后，默认就是一个Master eligible节点</li></ul></li><li><p>Data Node：数据节点 </p><ul><li>可以保存数据的节点，负责数据写入与搜索</li><li>节点启动后，默认就是数据节点。可以设置node.data: false 禁止</li></ul></li><li><p>Coordinating Node：协调节点</p><ul><li>负责接受Client的请求， 将请求分发到合适的节点，最终把结果汇集到一起 </li><li>每个节点默认都起到了Coordinating Node的职责</li></ul></li></ul><h1 id="3-分片和副本"><a href="#3-分片和副本" class="headerlink" title="3 分片和副本"></a>3 分片和副本</h1><h2 id="3-1-分片"><a href="#3-1-分片" class="headerlink" title="3.1 分片"></a>3.1 分片</h2><ul><li><p>ES 通过水平拆分的方式将一个索引上的数据拆分出来分配到不同的数据块上，分布在多台服务器上存储，拆分出来的数据库块称之为一个分片。</p></li><li><p>一个索引（index）由多个shard（分片）组成，而分片是分布在不同的服务器上的</p></li><li><p>主分片数在索引创建时指定，后续不允许修改，除非Reindex</p></li></ul><h2 id="3-2-副本"><a href="#3-2-副本" class="headerlink" title="3.2 副本"></a>3.2 副本</h2><ul><li>用以解决数据高可用的问题。 副本分片是主分片的拷贝 </li><li>副本分片数，可以动态调整 </li><li>增加副本数，还可以在一定程度上提高服务的可用性(读取的吞 吐)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> # 指定索引的主分片和副本分片数 <br>  PUT /blogs  &#123;<br> <span class="hljs-string">&quot;settings&quot;</span>: &#123;<br>   <span class="hljs-string">&quot;number_of_shards&quot;</span>: <span class="hljs-number">3</span>,<br>   <span class="hljs-string">&quot;number_of_replicas&quot;</span>: <span class="hljs-number">1</span> <br> &#125; &#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221807970.png" alt="image-20230228221807970"></p><h2 id="3-2-1-设置副本分片数"><a href="#3-2-1-设置副本分片数" class="headerlink" title="3.2.1 设置副本分片数"></a>3.2.1 <strong>设置副本分片数</strong></h2><p>副本是主分片的拷贝： </p><ul><li><p>提高系统可用性︰响应查询请求，防止数据丢失 </p></li><li><p>需要占用和主分片一样的资源</p></li></ul><p>对性能的影响：</p><ul><li><p>分片间的数据同步会占用一定的网络带宽，影响效率</p></li><li><p>会减缓对主分片的查询压力，但是会消耗同样的内存资源。如果机器资源充分， 提高副本数，可以提高整体的查询QPS</p></li></ul><h1 id="4-Elasticsearch文档写入原理"><a href="#4-Elasticsearch文档写入原理" class="headerlink" title="4 Elasticsearch文档写入原理"></a>4 Elasticsearch文档写入原理</h1><ol><li>客户端选择一个node发送请求过去，这个node就是coordinating node (协调节 点)</li><li>coordinating node计算得到文档要写入的分片。默认是 <code>hash(文档的id) % 主分片数</code></li><li>coordinating node，对document进行路由，将请求转发给对应的node </li><li>node上的primary shard处理请求，然后将数据同步到replica node </li><li>coordinating node如果发现primary node和所有的replica node都保存好了文档， 就会返回请求到客户端</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221821340.png" alt="image-20230228221821340"></p><h1 id="5-ES读取数据的过程"><a href="#5-ES读取数据的过程" class="headerlink" title="5 ES读取数据的过程"></a>5 <strong>ES读取数据的过程</strong></h1><h2 id="5-1-根据id查询数据的过程"><a href="#5-1-根据id查询数据的过程" class="headerlink" title="5. 1 根据id查询数据的过程"></a>5. 1 <strong>根据id查询数据的过程</strong></h2><ol><li>客户端发送请求到任意一个 node，成为 coordinate node</li><li>coordinate node 对 doc id 进行哈希路由，将请求转发到对应的 node，此时会 使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给 coordinate node</li><li>coordinate node 返回 document 给客户端。</li></ol><blockquote><p>根据 doc id 进行 hash，判断出来当时把 doc id 分配到了哪个 shard 上面去，从那个 shard 去查询。</p></blockquote><h2 id="5-2-根据关键词查询数据的过程"><a href="#5-2-根据关键词查询数据的过程" class="headerlink" title="5.2 根据关键词查询数据的过程"></a>5.2 <strong>根据关键词查询数据的过程</strong></h2><ol><li>客户端发送请求到一个 coordinate node 。</li><li>协调节点将查询请求广播到每一个数据节点，这些数据节点的分片会处理该查询请求 </li><li><strong>query phase</strong>：每个 shard 将自己的搜索结果（包括：文档ID、节点信息、分片信息）返回给协调节点，由协调节点进行 数据的合并、排序、分页等操作，产出最终结果</li><li><strong>fetch phase：</strong>接着由协调节点根据 doc id 去各个节点上拉取实际的 document 数据，最终返回给客户端。</li></ol>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集群</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch知识点总结</title>
    <link href="/ElasticSearch%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/ElasticSearch%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Es是什么？"><a href="#1-Es是什么？" class="headerlink" title="1 Es是什么？"></a>1 Es是什么？</h1><ul><li>Elasticsearch是用Java开发并且是当前最流行的开源的<strong>企业级搜索引擎</strong>。</li><li>能够达到实时搜索，稳定，可靠，快速，安装使用方便。</li><li>客户端支持Java、.NET（C#）、PHP、Python、Ruby等多种语言。</li></ul><h1 id="2-为什么要使用ES"><a href="#2-为什么要使用ES" class="headerlink" title="2 为什么要使用ES?"></a>2 为什么要使用ES?</h1><ul><li>数据量在几万或者几十万时候，所以采用以往的模糊查询，实时与数据库交互，会导致效率特别低下</li><li>不能将搜索词拆分开来，如果采用以往的模糊查询，比如 <code>name</code> &#x3D;’手机%’， 只能搜索名字是“手机”开头的手机商品，如果想搜出“华为手机”或者”手机壳“那是搜索不出来的。</li></ul><h1 id="3-Es和传统关系性数据库比较"><a href="#3-Es和传统关系性数据库比较" class="headerlink" title="3 Es和传统关系性数据库比较"></a>3 Es和传统关系性数据库比较</h1><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224035138.png" alt="image-20230228224035138"></p><h1 id="4-什么是全文检索"><a href="#4-什么是全文检索" class="headerlink" title="4 什么是全文检索"></a>4 什么是全文检索</h1><ul><li>全文检索是指：通过一个程序扫描文本中的每一个单词，针对单词建立索引，并保存该单词在文本中的位置、以及出现的次数。</li><li>用户查询时，通过之前建立好的索引来查询，将索引中单词对应的文本位置、出现的次数返回给用户，因为有了具体文本的位置，所以就可以将具体内容读取出来了</li></ul><h1 id="5-什么是倒排索引？"><a href="#5-什么是倒排索引？" class="headerlink" title="5 什么是倒排索引？"></a>5 什么是倒排索引？</h1><p>对于关系型数据库mysql来说，<strong>普通的索引结构就是“id-&gt;题目-&gt;内容”，</strong>在我们搜索的时候，如果我们知道id或者题目<strong>，那么检索效率是很高效的，因为“id”、“题目”是很方便创建索引的。</strong></p><p>那么<strong>倒排序索引</strong>的结构是怎样的呢？简单来讲<strong>就是“以内容的关键词”建立索引，</strong>映射关系为<strong>“内容的关键词-&gt;ID”。</strong>这样的话，我们只需要在“关键词”中进行检索</p><h1 id="6-Elasticsearch中的核心概念"><a href="#6-Elasticsearch中的核心概念" class="headerlink" title="6 Elasticsearch中的核心概念"></a>6 Elasticsearch中的核心概念</h1><h2 id="6-1-索引index"><a href="#6-1-索引index" class="headerlink" title="6.1 索引index"></a>6.1 索引index</h2><p>类似于数据库中的<strong>库</strong>，存放拥有某些共同特征的文档的集合。</p><h2 id="6-2-字段类型Type"><a href="#6-2-字段类型Type" class="headerlink" title="6.2 字段类型Type"></a>6.2 字段类型Type</h2><p>类似于数据库中的<strong>表</strong>， 在7.0开始，一个索引只能建一个Type为<code>_doc</code></p><h2 id="6-4-字段Field"><a href="#6-4-字段Field" class="headerlink" title="6.4 字段Field"></a>6.4 字段Field</h2><p>相当于是数据表的字段|列</p><h2 id="6-5-文档document"><a href="#6-5-文档document" class="headerlink" title="6.5 文档document"></a>6.5 文档document</h2><p>一个文档是一个可被索引的基础信息单元，类似一条记录。文档以JSON（JavascriptObjectNotation）格式来表示；</p><h2 id="6-6-映射mapping"><a href="#6-6-映射mapping" class="headerlink" title="6.6 映射mapping"></a>6.6 映射mapping</h2><p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分词器、是否被索引等等，这些都是映射里面可以设置的</p>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql分库分表</title>
    <link href="/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <url>/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-分库分表是什么"><a href="#1-分库分表是什么" class="headerlink" title="1 分库分表是什么"></a>1 分库分表是什么</h1><ul><li>分库：从单个数据库拆分成多个数据库的过程，将数据散落在多个数据库中。</li><li>分表：从单张表拆分成多张表的过程，将数据散落在多张表内。</li></ul><h1 id="2-分库分表有什么用"><a href="#2-分库分表有什么用" class="headerlink" title="2 分库分表有什么用"></a>2 <strong>分库分表有什么用</strong></h1><p>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题</p><h1 id="3-分库分表的方式"><a href="#3-分库分表的方式" class="headerlink" title="3 分库分表的方式"></a>3 <strong>分库分表的方式</strong></h1><ul><li>分库分表包含分库和分表 两个部分，而这两个部分可以统称为数据分片，其目的都是将数据拆分成不同的存储单元。</li><li>从分拆的角度上，可以分为垂直分片和水平分片</li></ul><h2 id="3-1-垂直分片"><a href="#3-1-垂直分片" class="headerlink" title="3.1 垂直分片"></a>3.1 垂直分片</h2><ul><li>按照业务来对数据进行分片，按照业务将表进行归类，分布到不同的数据库或表中，从而将压力分散至不同的数据库或表。</li><li>如果垂直分片之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理。</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221440881.png" alt="image-20230228221440881"></p><h2 id="3-2-水平分片"><a href="#3-2-水平分片" class="headerlink" title="3.2 水平分片"></a>3.2 水平分片</h2><ul><li>又称横向分片。通过某个字段(或某几个字段)，根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221453079.png" alt="image-20230228221453079"></p><h3 id="3-2-1-水平分片常用的分片策略"><a href="#3-2-1-水平分片常用的分片策略" class="headerlink" title="3.2.1 水平分片常用的分片策略"></a>3.2.1 水平分片常用的分片策略</h3><ul><li>精准分片，比如：取余\取模 。 优点均匀存放数据，缺点 扩容非常麻烦，如果新加一台服务器，之前的老数据就得做迁移</li><li>按照范围分片 ： 当我们 SQL中的分片健字段用到 <code>BETWEEN AND</code>操作符会使用到此算法，比如订单id在1至100存放到一张表，200到300在另一张。</li></ul><h1 id="4-分库分表要解决哪些问题"><a href="#4-分库分表要解决哪些问题" class="headerlink" title="4 分库分表要解决哪些问题"></a>4 分库分表要解决哪些问题</h1><ul><li>事务一致性问题</li></ul><p>原本单机数据库有很好的事务机制能够帮我们保证数据一致性。但是分库分表后，由于数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题。</p><ul><li>跨节点关联查询问题</li></ul><p>在没有分库时，我们可以进行很容易的进行跨表的关联查询。但是在分库后，表被分散到了不同的数据库，就无法进行关联查询了。这时就需要将关联查询拆分成多次查询，然后将获得的结果进行拼装。</p><ul><li>跨节点分页、排序函数</li></ul><p>跨节点多库进行查询时，limit分页、order by排序等问题，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序。这时非常容易出现内存崩溃的问题。</p><ul><li>主键避重问题</li></ul><p>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题。</p><ul><li>公共表处理</li></ul><p>实际的应用场景中，参数表、数据字典表等都是数据量较小，变动少，而且属于高频联合查询的依赖表。这一类表一般就需要在每个数据库中都保存一份，并且所有对公共表的操作都要分发到所有的分库去执行。</p><ul><li>运维工作量</li></ul><p>面对散乱的分库分表之后的数据，应用开发工程师和数据库管理员对数据库的操作都变得非常繁重。对于每一次数据读写操作，他们都需要知道要往哪个具体的数据库的分表去操作，这也是其中重要的挑战之一。</p><h1 id="5-什么时候需要分库分表？"><a href="#5-什么时候需要分库分表？" class="headerlink" title="5 什么时候需要分库分表？"></a>5 <strong>什么时候需要分库分表？</strong></h1><p>在阿里巴巴公布的开发手册中，建议MySQL单表记录如果达到500W这个级别，或者单表容量达到2GB，一般就建议进行分库分表。</p><h1 id="6-常见的分库分表组件"><a href="#6-常见的分库分表组件" class="headerlink" title="6 常见的分库分表组件"></a>6 <strong>常见的分库分表组件</strong></h1><p>ShardingSphere，mycat， DBLE</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分库分表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitMq集群</title>
    <link href="/rabbitMq%E9%9B%86%E7%BE%A4/"/>
    <url>/rabbitMq%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h1><ul><li><p><strong>queue的消息</strong>，只会放在<strong>一个rabbtimq实例</strong>上。<strong>每个实例都同步queue的结构和queue消息的真正位置</strong>。</p></li><li><p>消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。</p></li></ul><p>这种集群模式的消息可靠性不是很高。因为如果其中有个节点服务宕机了，那这个节点上的数据就无法消费了，需要等到这个节点服务恢复后才能消费。</p><h1 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h1><ul><li><p>这种模式是在普通集群模式基础上的一种增强方案，这也就是RabbitMQ的官方HA高可用方案。</p></li><li><p>这种模式会在镜像节点中间主动进行消息同步，而不是在客户端拉取消息时临时同步。这种模式的消息可靠性更高，因为每个节点上都存着全量的消息。</p></li><li><p>他的弊端也是明显的，集群内部的网络带宽会被这种同步通讯大量的消耗，进而降低整个集群的性能。这种模式下，队列数量最好不要过多。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集群</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql集群</title>
    <link href="/Mysql%E9%9B%86%E7%BE%A4/"/>
    <url>/Mysql%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-主从模式"><a href="#1-主从模式" class="headerlink" title="1 主从模式"></a>1 主从模式</h1><ul><li>一个master可以拥有多个slave，一个slave只对应一个master</li><li><strong>一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读</strong>。</li><li>所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑<strong>读高并发</strong>。</li><li>一主多从的结构，主要目的是实现数据的多点备份（没有故障自动转移和负载均衡）</li></ul><p>缺点：</p><ul><li>从库要从binlog获取数据并重放，这肯定与主库写入数据存在时间延迟，因此从库的数据总是要滞后主库。</li><li>对主库与从库之间的网络延迟要求较高，若网络延迟太高，将加重上述的滞后，造成最终数据的不一致。</li><li>单一的主节点挂了，将不能对外提供写服务。</li></ul><h2 id="1-1-Mysql主从复制工作原理"><a href="#1-1-Mysql主从复制工作原理" class="headerlink" title="1.1 Mysql主从复制工作原理"></a>1.1 Mysql主从复制工作原理</h2><p>数据库的主从同步，就是为了要保证多个数据库之间的数据保持一致。</p><ul><li><p>最简单的方式就是使用数据库的导入导出工具，定时将主库的数据导出，再导入到从库当中。这是一种很常见，也很简单易行的数据库集群方式。但是这种方式进行数据同步的实时性比较差。</p></li><li><p>如果要保证数据能够实时同步，对于MySQL，通常就要用到他自身提供的一套通过Binlog日志在多个MySQL服务之间进行同步的集群方案。</p></li></ul><p><strong>Binlog复制流程详解：</strong></p><ul><li>主库上打开Binlog日志，记录对数据的每一步操作</li><li>当主库有数据更新的时候，会通知从库</li><li>从库会向主库请求binlog日志，但为了保证日志接收的稳定性，并不会立即重演Binlog数据操作，而是先将接收到的Binlog日志写入到自己的RelayLog日志当中</li><li>从库检测到RelayLog中的操作日志有更新，就会在自己数据库中进行异步重演。</li></ul><blockquote><p>MySQL的BinLog日志能够比较实时的记录主库上的所有日志操作，因此他也被很多其他工具用来实时监控MySQL的数据变化。如：</p><ul><li>转发到Redis实现缓存一致</li><li>ClickHouse也支持将自己模拟成一个MySQL的从节点，接收MySQL的Binlog日志，实时同步MySQL的数据。这个功能目前还在实验阶段。</li></ul></blockquote><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224830814.png" alt="image-20230228224830814"></p><h2 id="1-2-主从复制的策略"><a href="#1-2-主从复制的策略" class="headerlink" title="1.2 主从复制的策略"></a>1.2 主从复制的策略</h2><ol><li><strong>「同步策略」</strong>：Master会等待所有的Slave都回应后才会提交，这个主从的同步的性能会严重的影响。</li><li><strong>「半同步策略」</strong>：Master至少会等待一个Slave回应并写入relay log后提交。</li><li><strong>「异步策略」</strong>：Master不用等待Slave回应就可以提交。</li></ol><h2 id="1-3-日志记录上position方式和GTID方式区别"><a href="#1-3-日志记录上position方式和GTID方式区别" class="headerlink" title="1.3 日志记录上position方式和GTID方式区别"></a>1.3 <strong>日志记录上position方式和GTID方式区别</strong></h2><ul><li>主从复制,默认是通过pos复制(postion)方式,将用户进行的每一项操作都进行编号(pos)，在配置从服务时，就需要通过这个Position通知从服务从哪个地方开始记录binLog。</li><li>GTID (Global Transaction ID全局事务ID)就是类似于pos的一个作用,全局通用并且日志文件里事件的GTID值是一致的。不用以前那样在需要找log_file和log_Pos。</li><li>从架构设计的角度，GTID是一种很好的分布式ID实践方式</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224842796.png" alt="image-20230228224842796"></p><h1 id="2-MySQL-Fabric-模式"><a href="#2-MySQL-Fabric-模式" class="headerlink" title="2 MySQL Fabric 模式"></a>2 MySQL Fabric 模式</h1><ul><li>MySQL Fabric能“组织”多个MySQL数据库，是应用系统将大于几TB的表分散到多个数据库，即数据分片(Data Shard)。</li><li>在同一个分片内又可以含有多个数据库，并且由Fabric<strong>自动</strong>挑选一个适合的作为主数据库，其他的数据库配置成从数据库，来做主从复制。</li><li>在主数据库挂掉时，从各个从数据库中挑选一个提升为主数据库。</li></ul><h1 id="3-MySQL-Cluster-模式"><a href="#3-MySQL-Cluster-模式" class="headerlink" title="3 MySQL Cluster 模式"></a>3 MySQL Cluster 模式</h1><ul><li>MySQL Cluster是多主多从结构的</li></ul><p>可参考redis cluster</p><h1 id="4-第三方优化"><a href="#4-第三方优化" class="headerlink" title="4 第三方优化"></a>4 第三方优化</h1><h2 id="4-1-MMM-模式"><a href="#4-1-MMM-模式" class="headerlink" title="4.1 MMM 模式"></a>4.1 MMM 模式</h2><ul><li><p>MMM（Master Replication Manager for MySQL）是<strong>双主多从</strong>结构。</p></li><li><p>这是Google的开源项目，使用Perl语言来对MySQL 主从做扩展，提供一套支持双主故障切换和双主日常管理的脚本程序，主要用来监控mysql主主复制并做失败转移。</p></li><li><p>他需要两个Master，同一时间只有一个Master对外提供服务，可以说是主备模式。</p></li><li><p>他是通过一个VIP(虚拟IP)的机制来保证集群的高可用。整个集群中，在主节点上会通过一个VIP地址来提供数据读写服务，而当出现故障时，VIP就会从原来的主节点漂移到其他节点，由其他节点提供服务。</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224851424.png" alt="image-20230228224851424"></p><h3 id="4-1-1优点："><a href="#4-1-1优点：" class="headerlink" title="4.1.1优点："></a>4.1.1优点：</h3><ul><li><p>提供了读写VIP的配置，使读写请求都可以达到高可用</p></li><li><p>工具包相对比较完善，不需要额外的开发脚本</p></li><li><p>完成故障转移之后可以对MySQL集群进行高可用监控</p></li></ul><h3 id="4-1-2-缺点："><a href="#4-1-2-缺点：" class="headerlink" title="4.1.2 缺点："></a><em>4.1.2 缺点：</em></h3><ul><li><p>故障简单粗暴，容易丢失事务，建议采用半同步复制方式，减少失败的概率</p></li><li><p>目前MMM社区已经缺少维护，不支持基于GTID的复制</p></li></ul><h3 id="4-1-3-适用场景："><a href="#4-1-3-适用场景：" class="headerlink" title="4.1.3 适用场景："></a>4.1.3 <strong>适用场景：</strong></h3><ul><li><p>读写都需要高可用的</p></li><li><p>基于日志点的复制方式</p></li></ul><h2 id="4-2-MHA-模式"><a href="#4-2-MHA-模式" class="headerlink" title="4.2 MHA 模式"></a>4.2 <strong>MHA</strong> 模式</h2><ul><li>MHA（Master High Availability）是<strong>多主多从</strong>结构，</li><li>是由日本人开发的一个基于Perl脚本写的工具。这个工具专门用于监控主库的状态，当发现master节点故障时，会提升其中拥有新数据的slave节点成为新的master节点，在此期间，MHA会通过其他从节点获取额外的信息来避免数据一致性方面的问题。</li><li>MHA还提供了mater节点的在线切换功能，即按需切换master-slave节点。MHA能够在30秒内实现故障切换，并能在故障切换过程中，最大程度的保证数据一致性。</li></ul><h3 id="4-2-1-优点："><a href="#4-2-1-优点：" class="headerlink" title="4.2.1 优点："></a>4.2.1 优点：</h3><ul><li><p>MHA除了支持日志点的复制还支持GTID的方式</p></li><li><p>同MMM相比，MHA会尝试从旧的Master中恢复旧的二进制日志，只是未必每次都能成功。如果希望更少的数据丢失场景，建议使用MHA架构。</p></li></ul><h3 id="4-2-2-缺点："><a href="#4-2-2-缺点：" class="headerlink" title="4.2.2 缺点："></a>4.2.2 缺点：</h3><ul><li><p>MHA需要自行开发VIP转移脚本。</p></li><li><p>MHA只监控Master的状态，未监控Slave的状态</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集群</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper的使用场景</title>
    <link href="/zookeeper%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/zookeeper%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-ZooKeeper-实现分布式-ID"><a href="#1-ZooKeeper-实现分布式-ID" class="headerlink" title="1 ZooKeeper 实现分布式 ID"></a>1 ZooKeeper 实现分布式 ID</h1><h2 id="1-1-为什么需要分布式ID"><a href="#1-1-为什么需要分布式ID" class="headerlink" title="1.1 为什么需要分布式ID"></a>1.1 为什么需要分布式ID</h2><p>在单体结构的应用中，我们可以使用 MySQL 数据库的主键自增来为我们的数据设置唯一标识 ID，但是在分布式环境中，单个数据库的吞吐量成为整个应用的性能瓶颈，我们就可以搭建数据库集群来提升数据库的性能，此时如果还使用 MySQL 的主键自增来设置数据 ID 的话，就会出现重复的 ID，这样就会出现主键冲突的情况。</p><p>如果使用分布式的全局唯一 ID 就不用担心会出现这个问题了</p><h2 id="1-2-实现方式"><a href="#1-2-实现方式" class="headerlink" title="1.2 实现方式"></a>1.2 实现方式</h2><h3 id="1-2-1-UUID实现分布式-ID"><a href="#1-2-1-UUID实现分布式-ID" class="headerlink" title="1.2.1 UUID实现分布式 ID"></a>1.2.1 <strong>UUID实现分布式 ID</strong></h3><ul><li>在 Java 中可以使用 java.util.UUID 的 randomUUID() 方法来获得：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.UUID.randomUUID().toString();<br></code></pre></td></tr></table></figure><p>UUID 可以在本地生成，生成速度快，不依赖网络和其它服务，但是 UUID 没有可以识别的特点，也没有顺序性。</p><h3 id="1-2-2-Redis实现分布式-ID"><a href="#1-2-2-Redis实现分布式-ID" class="headerlink" title="1.2.2 Redis实现分布式 ID"></a>1.2.2 <strong>Redis实现分布式 ID</strong></h3><p>使用 Redis 的 Incr 命令来把 &lt;key,value&gt; 中 key 的数值加 1 并返回，如果这个 key 不存在，则 key 值会被初始化为 0，再执行 Incr 命令来进行加 1 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 incr(key) 来让 key 加 1</span><br><span class="hljs-keyword">long</span> id = jedis.incr(<span class="hljs-string">&quot;id&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 Redis 的方式生成分布式 ID 需要依赖 Redis 服务，还要保证 Redis 的高可用，否则 Redis 服务宕机会影响整个应用。</p><h3 id="1-2-3-Zookeeper-实现分布式-ID"><a href="#1-2-3-Zookeeper-实现分布式-ID" class="headerlink" title="1.2.3 Zookeeper 实现分布式 ID"></a>1.2.3 Zookeeper 实现分布式 ID</h3><p>在 Zookeeper 中，我们可以使用 Zookeeper 的 顺序节点来完成分布式 ID 的生成</p><p>顺序节点，在 Zookeeper 客户端创建顺序节点时，Zookeeper 会根据创建的时间顺序，在节点名称后添加 10 位的顺序编号。</p><h1 id="2-Zookeeper-实现负载均衡"><a href="#2-Zookeeper-实现负载均衡" class="headerlink" title="2  Zookeeper 实现负载均衡"></a>2  Zookeeper 实现负载均衡</h1><h2 id="2-1-为什么需要做负载均衡"><a href="#2-1-为什么需要做负载均衡" class="headerlink" title="2.1 为什么需要做负载均衡"></a>2.1 为什么需要做负载均衡</h2><p>在分布式的环境中，我们常常使用集群部署的方式来提高某个服务的可用性，为了让高并发的请求能够平均的分配到集群中的每一个服务，避免有些服务压力过大，而有些服务处于空闲状态这样的情况，我们需要制定一些规则来把请求进行路由，这种分配请求的做法就叫做负载均衡，路由请求的规则就是负载均衡的策略。</p><h2 id="2-2-负载均衡的策略"><a href="#2-2-负载均衡的策略" class="headerlink" title="2.2 负载均衡的策略"></a>2.2 负载均衡的策略</h2><h3 id="3-2-1-轮询策略"><a href="#3-2-1-轮询策略" class="headerlink" title="3.2.1 轮询策略"></a>3.2.1 <strong>轮询策略</strong></h3><ul><li>轮询策略就是按照集群的服务列表的顺序，依次进行请求的分配，直到列表中所有的服务都分配了一次请求，就完成了一轮的请求分配，然后再从第一个服务开始分配请求。</li><li>轮询策略是很多负载均衡技术的默认策略，这样的方式保证了的每个服务所承受的请求压力是平均的，我们可以把服务列表按照顺序放到一个数组来循环分配请求。</li></ul><h3 id="3-2-2-随机策略"><a href="#3-2-2-随机策略" class="headerlink" title="3.2.2 随机策略"></a>3.2.2 <strong>随机策略</strong></h3><ul><li>随机策略就是根据随机算法把请求随机的分配给服务列表中的任意一个服务。</li><li>随机策略的实现方式：我们可以把服务列表放到一个数组，然后根据数组的长度来获取随机数，取到的随机数就是服务在数组中的索引，根据这个索引，我们就可以拿到服务地址来发送请求了</li></ul><h3 id="3-2-3-一致性哈希策略"><a href="#3-2-3-一致性哈希策略" class="headerlink" title="3.2.3 一致性哈希策略"></a>3.2.3 <strong>一致性哈希策略</strong></h3><ul><li>一致性哈希策略的实现方式：我们先把服务列表中的地址进行哈希计算，把计算后的值放到哈希环上，接收到请求后，根据请求的固定属性值来进行哈希计算，然后根据请求的哈希值在哈希环上顺时针寻找服务地址的哈希值，寻找到哪个服务地址的哈希值，就把请求分配给哪个服务。</li></ul><h3 id="3-2-4-加权轮询策略"><a href="#3-2-4-加权轮询策略" class="headerlink" title="3.2.4 加权轮询策略"></a>3.2.4 <strong>加权轮询策略</strong></h3><p>加权轮询策略就是在轮询策略的基础上，对 Server 地址进行加权处理，除了按照服务地址列表的顺序来分配请求外，还要按照权重大小来决定请求的分配次数。加权的目的是为了让性能和网络较好的服务多承担请求分配的压力。</p><p>比如 Server_1 的权重是 3，Server_2 的权重是 2，Server_3 的权重是 1，那么在进行请求分配时，Server_1 会被分配 3 次请求，Server_2 会被分配 2 次请求，Server_3 会被分配 1 次请求，就这样完成一轮请求的分配，然后再从 Server_1 开始进行分配。</p><h3 id="3-2-5-加权随机策略"><a href="#3-2-5-加权随机策略" class="headerlink" title="3.2.5 加权随机策略"></a>3.2.5 <strong>加权随机策略</strong></h3><p>加权随机策略就是在随机策略的基础上，对 Server 地址进行加权处理，Server 地址的加权有多少，那么 Server 地址的数组中的地址就会有几个，然后再从这个数组中进行随机选址。</p><h3 id="3-2-6-最小连接数策略"><a href="#3-2-6-最小连接数策略" class="headerlink" title="3.2.6 最小连接数策略"></a>3.2.6 <strong>最小连接数策略</strong></h3><p>最小连接数策略，就是根据客户端与服务端会话数量来决定请求的分配情况，它会把请求分配到会话数量小的服务，会话的数量越少，也能说明服务的性能和网络较好。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>把ZooKeeper作为一个服务的<a href="https://cloud.tencent.com/product/tse?from=10680">注册中心</a>，在其中登记每个服务，每台服务器知道自己是属于哪个服务，在服务器启动时，自己向所属服务进行登记，这样，一个树形的服务结构就呈现出来了</p><p>服务的调用者到注册中心里面查找：能提供所需服务的服务器列表，然后自己根据负载均衡算法，从中选取一台服务器进行连接</p><h1 id="3-Zookeeper-实现配置中心"><a href="#3-Zookeeper-实现配置中心" class="headerlink" title="3 Zookeeper 实现配置中心"></a>3 Zookeeper 实现配置中心</h1><p>配置中心来更新配置的方式有两种，一种是由配置中心的配置更新后向服务推送更新的配置，另一种是服务定时轮询的方式的去配置中心拉取配置，发现配置中心的配置被更新就更新自己的配置。</p><p>Zookeeper 实现配置中心的方式：服务把自己的配置信息存储到 Zookeeper 节点的 data 上，并且对这个节点开启 Watch 监听，只要这个节点的数据发生变化，Zookeeper 就会把这个消息推送给服务，服务在回调事件中去获取该节点的数据，然后使用新的数据更新自己的配置。那么根据这个思路，我们就开始使用 Zookeeper 来实现配置中心。</p><h1 id="4-Zookeeper-实现分布式锁"><a href="#4-Zookeeper-实现分布式锁" class="headerlink" title="4 Zookeeper 实现分布式锁"></a>4 Zookeeper 实现分布式锁</h1><p><a href="https://pyr9.github.io/Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">Zookeeper实现分布式锁 - 楼上有只喵 (pyr9.github.io)</a></p><h1 id="5-Zookeeper-实现注册中心"><a href="#5-Zookeeper-实现注册中心" class="headerlink" title="5 Zookeeper 实现注册中心"></a>5 Zookeeper 实现注册中心</h1><p><a href="https://pyr9.github.io/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/">注册中心 - 楼上有只喵 (pyr9.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper节点介绍</title>
    <link href="/zookeeper%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/"/>
    <url>/zookeeper%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Zookeeper-数据模型"><a href="#1-Zookeeper-数据模型" class="headerlink" title="1 Zookeeper 数据模型"></a>1 Zookeeper 数据模型</h1><ul><li>Zookeeper 数据模型的结构是基于节点的，我们把这种节点叫做 <strong>Znode</strong> 。</li><li>节点之下可以包含子节点，这种结构和数据结构中的树类似，也和文件系统的目录类似。</li></ul><ul><li>每个节点拥有唯一的路径path.</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycegg0aihj30u00v0wgk.jpg" style="zoom: 33%;" /><h1 id="2-节点的结构"><a href="#2-节点的结构" class="headerlink" title="2 节点的结构"></a>2 节点的结构</h1><ul><li><strong>path</strong>:唯一路径 </li><li><strong>childNode</strong>：子节点</li><li><strong>stat</strong>:状态属性:即path对应的值</li><li><strong>type</strong>:节点类型</li></ul><h1 id="3-节点类型"><a href="#3-节点类型" class="headerlink" title="3 节点类型"></a>3 节点类型</h1><table><thead><tr><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">PERSISTENT</td><td align="left">持久节点</td></tr><tr><td align="left">PERSISTENT_SEQUENTIAL</td><td align="left">持久序号节点</td></tr><tr><td align="left">EPHEMERAL</td><td align="left">临时节点(不可在拥有子节点)</td></tr><tr><td align="left">EPHEMERAL_SEQUENTIAL</td><td align="left">临时序号节点(不可在拥有子节点)</td></tr></tbody></table><h2 id="3-1-PERSISTENT（持久节点）"><a href="#3-1-PERSISTENT（持久节点）" class="headerlink" title="3.1 PERSISTENT（持久节点）"></a>3.1 PERSISTENT（持久节点）</h2><ul><li>持久化保存的节点，也是默认创建的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>test<br></code></pre></td></tr></table></figure><h2 id="3-2-PERSISTENT-SEQUENTIAL-持久序号节点"><a href="#3-2-PERSISTENT-SEQUENTIAL-持久序号节点" class="headerlink" title="3.2 PERSISTENT_SEQUENTIAL(持久序号节点)"></a>3.2 PERSISTENT_SEQUENTIAL(持久序号节点)</h2><p>创建时zookeeper 会在路径上加上序号作为后缀。非常适合用于分布式锁、分布式选举等场景。创建时添加 -s 参数即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s  <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>seq<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">13</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<br>Created <span class="hljs-operator">/</span>temp0000000004<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">14</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<br>Created <span class="hljs-operator">/</span>temp0000000005<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">15</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<br>Created <span class="hljs-operator">/</span>temp0000000006<br></code></pre></td></tr></table></figure><h2 id="3-3-EPHEMERAL（临时节点）"><a href="#3-3-EPHEMERAL（临时节点）" class="headerlink" title="3.3 EPHEMERAL（临时节点）"></a>3.3 EPHEMERAL（临时节点）</h2><ul><li>只存在于当前会话，当对话断开后会被删除。创建的时候增加 -e</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>seq<br></code></pre></td></tr></table></figure><ul><li>适用于心跳，服务发现等场景。如下图当node1挂掉了，它zookeeper1中创建的临时节点和其存储的数据就会就会被删除，zookeeper1就知道node1挂掉了。</li></ul><img src="/Users/panyurou/Library/Application Support/typora-user-images/image-20220116230200083.png" alt="image-20220116230200083" style="zoom: 33%;" /><h2 id="3-4-EPHEMERAL-SEQUENTIAL（临时序号节点）"><a href="#3-4-EPHEMERAL-SEQUENTIAL（临时序号节点）" class="headerlink" title="3.4 EPHEMERAL_SEQUENTIAL（临时序号节点）"></a>3.4 EPHEMERAL_SEQUENTIAL（临时序号节点）</h2><p>与持久序号节点类似，不同之处在于EPHEMERAL_SEQUENTIAL是临时的会在会话断开后删除。创建时添加 -e -s </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>seq<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">2</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br>Created <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c10000000000<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">3</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br>Created <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c10000000001<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">4</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br>Created <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c10000000002<br></code></pre></td></tr></table></figure><h1 id="4-节点属性"><a href="#4-节点属性" class="headerlink" title="4 节点属性"></a>4 节点属性</h1><ul><li>查看节点属性</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">stat <span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure><ul><li>属性说明</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">cZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x2</span>   #创建节点的事务ID<br>ctime <span class="hljs-operator">=</span> Mon Jan <span class="hljs-number">17</span> <span class="hljs-number">21</span>:<span class="hljs-number">09</span>:<span class="hljs-number">16</span> CST <span class="hljs-number">2022</span> #创建节点的时间<br>mZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x2</span> #修改当前节点数据的事务ID<br>mtime <span class="hljs-operator">=</span> Mon Jan <span class="hljs-number">17</span> <span class="hljs-number">21</span>:<span class="hljs-number">09</span>:<span class="hljs-number">16</span> CST <span class="hljs-number">2022</span> #最后修改时间<br>pZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x5</span> #子节点变更（包括自节点的删除和增加，不包括修改）的事务ID<br>cversion <span class="hljs-operator">=</span> <span class="hljs-number">3</span>  #这表示对此znode的子节点进行的更改次数，只包括自节点的删除和增加<br>dataVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span> #数据版本，当前节点数据变更次数<br>aclVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span> #权限版本，变更次数<br>ephemeralOwner <span class="hljs-operator">=</span> <span class="hljs-number">0x0</span> #临时节点所属会话ID，永久节点值为<span class="hljs-number">0x0</span><br>dataLength <span class="hljs-operator">=</span> <span class="hljs-number">0</span> #数据长度<br>numChildren <span class="hljs-operator">=</span> <span class="hljs-number">3</span> #子节点数(不包括子子节点)<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="5-Znode-节点的操作"><a href="#5-Znode-节点的操作" class="headerlink" title="5 Znode 节点的操作"></a>5 Znode 节点的操作</h1><h2 id="5-1-创建节点：-create"><a href="#5-1-创建节点：-create" class="headerlink" title="5.1 创建节点： create"></a>5.1 <strong>创建节点：</strong> <code>create</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个持久节点</span><br>create /persistent_node<br><span class="hljs-comment"># 创建一个持久的顺序节点</span><br>create -s /persistent_sequential_node<br><span class="hljs-comment"># 创建一个临时节点</span><br>create -e /ephemeral_node<br><span class="hljs-comment"># 创建一个临时的顺序节点</span><br>create -s -e /ephemeral_sequential_node<br><br><br>代码块12345678<br></code></pre></td></tr></table></figure><p>- </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"># 创建一个持久节点<br>create /persistent_node<br># 创建一个持久的顺序节点<br>create -s /persistent_sequential_node<br># 创建一个临时节点<br>create -e /ephemeral_node<br># 创建一个临时的顺序节点<br>create -s -e /ephemeral_sequential_node<br></code></pre></td></tr></table></figure><h2 id="5-2-删除节点：-delete"><a href="#5-2-删除节点：-delete" class="headerlink" title="5.2 删除节点： delete"></a>5.2 <strong>删除节点：</strong> <code>delete</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">delete /config/topics/test<br></code></pre></td></tr></table></figure><h2 id="5-3-获得一个节点的数据：-get"><a href="#5-3-获得一个节点的数据：-get" class="headerlink" title="5.3 获得一个节点的数据： get"></a>5.3 <strong>获得一个节点的数据：</strong> <code>get</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">get /persistent_node<br></code></pre></td></tr></table></figure><h2 id="5-4-设置一个节点的数据："><a href="#5-4-设置一个节点的数据：" class="headerlink" title="5.4 设置一个节点的数据："></a>5.4 <strong>设置一个节点的数据：</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">set /brokers myNewData<br></code></pre></td></tr></table></figure><h2 id="5-5-获取子节点："><a href="#5-5-获取子节点：" class="headerlink" title="5.5 获取子节点："></a>5.5 <strong>获取子节点：</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># 获取根节点下的子节点<br>ls /<br># 根节点下的子节点有 zk-watcher-<span class="hljs-number">2</span>，zookeeper<br>[zk-watcher-<span class="hljs-number">2</span>, zookeeper]<br></code></pre></td></tr></table></figure><h1 id="6-节点的监听"><a href="#6-节点的监听" class="headerlink" title="6 节点的监听"></a>6 节点的监听</h1><p>客户添加 -w 参数可实时监听节点与子节点的变化，并且实时收到通知。非常适用保障分布式情况下的数据一致性。其使用方式如下：</p><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ls -w path</td><td align="left">监听子节点的变化（增，删）</td></tr><tr><td align="left">get -w path</td><td align="left">监听节点数据的变化</td></tr><tr><td align="left">stat -w path</td><td align="left">监听节点属性的变化</td></tr><tr><td align="left">printwatches on|off</td><td align="left">触发监听后，是否打印监听事件(默认on)</td></tr></tbody></table><h2 id="6-1-监听节点数据的变化"><a href="#6-1-监听节点数据的变化" class="headerlink" title="6.1 监听节点数据的变化"></a>6.1 监听节点数据的变化</h2><ul><li><p>step1：打开客户端A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">get</span> <span class="hljs-operator">-</span>w  <span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure></li><li><p>Step2：打开客户端B:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>temp &quot;aaa&quot;<br></code></pre></td></tr></table></figure></li><li><p>此时客户端A，出现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">8</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">-</span>w  <span class="hljs-operator">/</span>temp<br><span class="hljs-keyword">null</span><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">9</span>]<br>WATCHER::<br><br>WatchedEvent state:SyncConnected type:NodeDataChanged path:<span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure></li><li><p>再次在客户端B输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>temp &quot;ddd&quot;<br></code></pre></td></tr></table></figure><p>此时可以发现，客户端A没有收到任何通知，故这里的watch是一次性的，第二次触发不再生效。</p></li></ul><h2 id="6-2-监听子节点的变化"><a href="#6-2-监听子节点的变化" class="headerlink" title="6.2 监听子节点的变化"></a>6.2 监听子节点的变化</h2><ul><li><p>step1：打开客户端A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ls <span class="hljs-operator">-</span>w  <span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure></li><li><p>Step2：打开客户端B:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br></code></pre></td></tr></table></figure></li><li><p>此时客户端A，出现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">9</span>] ls <span class="hljs-operator">-</span>w <span class="hljs-operator">/</span>temp<br>[c10000000000, c10000000001, c10000000002]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">10</span>]<br>WATCHER::<br><br>WatchedEvent state:SyncConnected type:NodeChildrenChanged path:<span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure></li></ul><h1 id="7-Zookeeper权限控制"><a href="#7-Zookeeper权限控制" class="headerlink" title="7 Zookeeper权限控制"></a>7 Zookeeper权限控制</h1><ul><li>ACL全称为Access Control List（访问控制列表），用于控制资源的访问权限。   </li><li>ZooKeeper使用ACL来控制对其znode的防问。</li><li>基于<code>scheme:id:permission</code>的方式进行权限控制。scheme表示授权模式、id模式对应值、permission即具体的增删改权限位。</li></ul><h2 id="7-1-scheme-授权模型"><a href="#7-1-scheme-授权模型" class="headerlink" title="7.1 scheme:授权模型"></a>7.1 scheme:授权模型</h2><table><thead><tr><th align="left">方案</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">world</td><td align="left">开放模式，world表示全世界都可以访问（这是默认设置）</td></tr><tr><td align="left">ip</td><td align="left">ip模式，限定客户端IP防问</td></tr><tr><td align="left">auth</td><td align="left">用户密码认证模式，只有在会话中添加了认证才可以防问</td></tr><tr><td align="left">digest</td><td align="left">与auth类似，区别在于auth用明文密码，而digest 用sha-1+base64加密后的密码。在实际使用中digest 更常见。</td></tr></tbody></table><h2 id="7-2-permission权限位"><a href="#7-2-permission权限位" class="headerlink" title="7.2 permission权限位"></a>7.2 <strong>permission权限位</strong></h2><table><thead><tr><th align="left">权限位</th><th align="left">权限</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">c</td><td align="left">CREATE</td><td align="left">可以创建子节点</td></tr><tr><td align="left">d</td><td align="left">DELETE</td><td align="left">可以删除子节点（仅下一级节点）</td></tr><tr><td align="left">r</td><td align="left">READ</td><td align="left">可以读取节点数据及显示子节点列表</td></tr><tr><td align="left">w</td><td align="left">WRITE</td><td align="left">可以设置节点数据</td></tr><tr><td align="left">a</td><td align="left">ADMIN</td><td align="left">可以设置节点访问控制列表权限</td></tr></tbody></table><h2 id="7-3-acl-相关命令"><a href="#7-3-acl-相关命令" class="headerlink" title="7.3 acl 相关命令"></a>7.3 acl 相关命令</h2><table><thead><tr><th align="left">命令</th><th align="left">使用方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getAcl</td><td align="left">getAcl <path></td><td align="left">读取ACL权限</td></tr><tr><td align="left">setAcl</td><td align="left">setAcl <path> <acl></td><td align="left">设置ACL权限</td></tr><tr><td align="left">addauth</td><td align="left">addauth <scheme> <auth></td><td align="left">添加认证用户</td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>world</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">11</span>] getAcl <span class="hljs-operator">/</span>temp<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: cdrwa<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">12</span>] setAcl <span class="hljs-operator">/</span>temp world:anyone:rwa<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">13</span>] getAcl <span class="hljs-operator">/</span>temp<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: rwa<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">14</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>temp<br>ddd<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">15</span>] <span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>temp &quot;bbb&quot;<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">16</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>t<br>Insufficient permission : <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>t<br></code></pre></td></tr></table></figure><ul><li><p>IP</p><p>语法： setAcl <path> ip:&lt;ip地址|地址段&gt;:&lt;权限位&gt;</p></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[zk: localhost<span class="hljs-function">:2181</span><span class="hljs-params">(CONNECTED)</span> 18] <span class="hljs-keyword">set</span>Acl <span class="hljs-string">/temp</span> ip<span class="hljs-function">:192.168.2.103</span><span class="hljs-function">:ra</span><br>[zk: localhost<span class="hljs-function">:2181</span><span class="hljs-params">(CONNECTED)</span> 19] getAcl <span class="hljs-string">/temp</span><br>Insufficient permission : <span class="hljs-string">/temp</span><br></code></pre></td></tr></table></figure><ul><li><p>auth</p><p>语法： </p><ol><li>setAcl <path> auth:&lt;用户名&gt;:&lt;密码&gt;:&lt;权限位&gt;</li><li>addauth digest &lt;用户名&gt;:&lt;密码&gt;</li></ol></li><li><p>digest</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> echo <span class="hljs-operator">-</span>n pyr:<span class="hljs-number">123456</span> <span class="hljs-operator">|</span> openssl dgst <span class="hljs-operator">-</span><span class="hljs-type">binary</span> <span class="hljs-operator">-</span>sha1 <span class="hljs-operator">|</span> openssl base64<br>zj9LbzdoKijw<span class="hljs-operator">/</span>kCo1pQJnXBFiq4<span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 28</span>] create /temp2<br>Created /temp2<br>[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 30</span>] getAcl /temp2<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: cdrwa<br>[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 31</span>] setAcl /temp2 digest:pyr:zj9LbzdoKijw/kCo1pQJnXBFiq4=:rwa<br>[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 32</span>] getAcl /temp2<br>Insufficient permission : /temp2<br>[<span class="hljs-meta">zk: 127.0.0.1:2181(CONNECTED) 45</span>] addauth digest pyr:<span class="hljs-number">123456</span><br>[<span class="hljs-meta">zk: 127.0.0.1:2181(CONNECTED) 46</span>] <span class="hljs-keyword">get</span> /temp2<br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper实现分布式锁</title>
    <link href="/Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1基于ZooKeeper的分布式锁。"><a href="#1基于ZooKeeper的分布式锁。" class="headerlink" title="1基于ZooKeeper的分布式锁。"></a>1基于ZooKeeper的分布式锁。</h1><p>适用于高可靠（高可用），而并发量不是太高的场景</p><p>优点：不存在锁失效的问题，不需要续命。</p><p>缺点：<strong>因为需要频繁的创建和删除节点，性能上不如Redis。</strong> </p><p>在高性能、高并发的应用场景下，不建议使用ZooKeeper的分布式锁。而由于ZooKeeper 的高可用性，因此在并发量不是太高的应用场景中，还是推荐使用ZooKeeper的分布式锁</p><p><strong>Zookeeper第三方客户端curator中已经实现了基于Zookeeper的分布式锁。</strong></p><h2 id="1-1-基于Zookeeper设计思路一"><a href="#1-1-基于Zookeeper设计思路一" class="headerlink" title="1.1 基于Zookeeper设计思路一"></a>1.1 <strong>基于Zookeeper设计思路一</strong></h2><p>利用Zookeeper创建临时节点来实现分布式锁，同一路径下的节点名称不能重复，来行防重</p><ul><li>同一时刻只能允许一个竞争者获取锁。加锁时我们创建一个临时节点。</li><li>当竞争者A加锁成功后，第竞争者B再来加锁就会抛出节点名称不能重复错误，如果抛出这个异常，我们就判定竞争者B加锁失败</li><li>竞争者B加锁失败后，会阻塞等待，监听节点状态，当节点数据删除后，也就是竞争者A释放锁，再去获取锁</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221910782.png" alt="image-20230228221910782"></p><h2 id="1-1-1-代码示例"><a href="#1-1-1-代码示例" class="headerlink" title="1.1.1 代码示例"></a>1.1.1 代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkDistributedLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IZkDataListener</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> ZkClient zkClient ;<br>    <span class="hljs-keyword">private</span> String path = <span class="hljs-string">&quot;/lock&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch ;<br>    <span class="hljs-keyword">private</span> String config;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(zkClient ==<span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">//建立连接</span><br>                zkClient = <span class="hljs-keyword">new</span> ZkClient(config);<br>            &#125;<br>            <span class="hljs-comment">// 创建临时节点</span><br>            zkClient.createEphemeral(path);<br><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <span class="hljs-comment">//存在节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//注册监听</span><br>        zkClient.subscribeDataChanges(path,<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span>(zkClient.exists(path))&#123;<br>            countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                countDownLatch.await();  <span class="hljs-comment">//计数器变为0之前，都会阻塞</span><br>                <span class="hljs-comment">// 解除监听</span><br>                zkClient.unsubscribeDataChanges(path,<span class="hljs-keyword">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(zkClient !=<span class="hljs-keyword">null</span>)&#123;<br>            zkClient.delete(path);<br>            System.out.println(<span class="hljs-string">&quot;-----释放锁资源----&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        countDownLatch.countDown();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-基于Zookeeper设计思路二"><a href="#2-基于Zookeeper设计思路二" class="headerlink" title="2 基于Zookeeper设计思路二"></a>2 基于Zookeeper设计思路二</h2><ul><li><p>利用Zookeeper创建临时有序节点来实现分布式锁，谁创建的节点序号最小，谁就获得了锁，</p></li><li><p>其他节点就会监听序号比自己小的节点，一旦序号比自己小的节点被删除了，其他节点就会得到相应的事件，然后查看自己是否为序号最小的节点，如果是，则获取锁</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221920388.png" alt="image-20230228221920388"></p><h2 id="2-1-代码示例"><a href="#2-1-代码示例" class="headerlink" title="2.1 代码示例"></a>2.1 代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkDistributedLock2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IZkDataListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> String path;<br>    <span class="hljs-keyword">private</span> String config;<br><br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch ;<br>    <span class="hljs-keyword">private</span> String beforePath; <span class="hljs-comment">// 当前节点前一个节点</span><br>    <span class="hljs-keyword">private</span> String currentPath; <span class="hljs-comment">// 当前节点</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZkDistributedLock2</span><span class="hljs-params">(String config, String path)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.path = path;<br>        <span class="hljs-keyword">this</span>.config = config;<br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(config);<br>        <span class="hljs-keyword">if</span> (!zkClient.exists(path)) &#123;<br>            <span class="hljs-comment">// 如果根节点不存在，则创建根节点</span><br>            zkClient.createPersistent(path);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//尝试获取锁</span><br>        <span class="hljs-keyword">boolean</span> locked = tryLock();<br>        <span class="hljs-keyword">if</span>(locked)&#123;<br>            System.out.println(<span class="hljs-string">&quot;---------获取锁---------&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!locked)&#123;<br>            <span class="hljs-comment">//等待锁 阻塞</span><br>            waitLock();<br>            <span class="hljs-comment">//重试</span><br>            <span class="hljs-comment">//获取等待的子节点列表</span><br>            List&lt;String&gt; childrens = zkClient.getChildren(path);<br>            <span class="hljs-comment">//判断，是否加锁成功</span><br>            <span class="hljs-keyword">if</span> (checkLocked(childrens)) &#123;<br>                locked = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建临时有序的节点  -e -s</span><br>            currentPath = zkClient.createEphemeralSequential(path+<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-keyword">null</span>);<br>            <span class="hljs-comment">//获取到所有子节点</span><br>            List&lt;String&gt; childrens = zkClient.getChildren(path);<br>            <span class="hljs-comment">//获取等待的子节点列表，判断自己是否第一个</span><br>            <span class="hljs-keyword">if</span> (checkLocked(childrens)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 若不是第一个，则找到自己的前一个节点</span><br>            <span class="hljs-keyword">int</span> index =  Collections.binarySearch(childrens,<br>                    currentPath.substring(currentPath.lastIndexOf(<span class="hljs-string">&quot;/&quot;</span>) + <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(currentPath+<span class="hljs-string">&quot;节点没有找到&quot;</span> );<br>            &#125;<br>            <span class="hljs-comment">//如果自己没有获得锁，则要监听前一个节点</span><br>            beforePath = path + <span class="hljs-string">&quot;/&quot;</span> + childrens.get(index-<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkLocked</span><span class="hljs-params">(List&lt;String&gt; childrens)</span> </span>&#123;<br><br>        <span class="hljs-comment">//节点按照编号，升序排列</span><br>        Collections.sort(childrens);<br><br>        <span class="hljs-comment">// 如果是第一个，代表自己已经获得了锁</span><br>        <span class="hljs-keyword">if</span> (currentPath.equals(path + <span class="hljs-string">&quot;/&quot;</span> +childrens.get(<span class="hljs-number">0</span>))) &#123;<br>            System.out.println(<span class="hljs-string">&quot;成功的获取分布式锁,节点为&quot;</span>+ currentPath);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(zkClient.exists(beforePath)) &#123;<br>                <span class="hljs-comment">//订阅比自己次小顺序节点的删除事件   index-1</span><br>                zkClient.subscribeDataChanges(beforePath, <span class="hljs-keyword">this</span>);<br>                countDownLatch.await();<br>                zkClient.unsubscribeDataChanges(beforePath, <span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(zkClient !=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//删除临时节点</span><br>            zkClient.delete(currentPath,-<span class="hljs-number">1</span>);<br>            System.out.println(currentPath+<span class="hljs-string">&quot; 节点释放锁资源&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        countDownLatch.countDown(); <span class="hljs-comment">//减1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基于Redis实现分布式锁"><a href="#1-基于Redis实现分布式锁" class="headerlink" title="1 基于Redis实现分布式锁"></a>1 <strong>基于Redis实现分布式锁</strong></h2><p>效率最高，加锁速度最快，因为Redis几乎都是纯内存操作</p><p>适用于并发量很大、性能要求很高而可靠性问题可以通过其 他方案去弥补的场景。 </p><h2 id="1-1-设计原理"><a href="#1-1-设计原理" class="headerlink" title="1.1 设计原理"></a>1.1 设计原理</h2><ul><li><p>利用利用Redis的<code>SETNX key value</code>这个命令获取锁，并设置过期时间，保存线程标示</p></li><li><p>释放锁时先判断线程标示是否与自己一致，一致则删除锁 (Lua 脚本保证原子性)</p></li></ul><blockquote><p> SETNX key value: 只有当key不存在时才会执行成功，如果key已经存在则命令执行失败。</p></blockquote><h2 id="1-2-2-实现注意事项"><a href="#1-2-2-实现注意事项" class="headerlink" title="1.2.2 实现注意事项"></a>1.2.2 实现注意事项</h2><ul><li><p>Redis 的 increment 并不能满足安全性，如果使用它需要特殊处理增加复杂性，如：</p><ul><li>ID的组成部分：<ul><li><strong>符号位</strong>：1bit，永远为0</li><li><strong>时间戳</strong>：31bit，以秒为单位，可以使用69年</li><li><strong>序列号</strong>：32bit，秒内的计数器，支持每秒产生2^32个不同ID</li></ul></li></ul></li><li><p>需要设置一个超时时间，因为有可能宕机或者被运维重启了，无法释放锁，但是这个超时时间的长短却不好确定：</p><ul><li>设置过短，会导致其他线程提前获得锁，引发线程安全问题</li><li>设置过长，线程需要额外等待</li></ul></li><li><p>如果业务执行时间&gt; 过期时间，就需要<strong>锁续命</strong>：搞一个定时任务，设一个间隔时间，小于失效时间，过一段时间去监控业务是否执行完了，执行没结束，也就是锁还没释放，我就再把锁的过期时间重新设置成初始值</p></li></ul><h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222015374.png" alt="image-20230228222015374"></p><ul><li>多个线程，只有一个线程会执行成功</li><li>必须使用try catch 在finally中释放锁，否则有异常，锁便没法释放，其他线程进来就会一直执行失败</li><li>分布式锁需要设置一个超时时间，因为有可能宕机或者被运维重启了，需要保证原子性，写成一个命令</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222025578.png" alt="image-20230228222025578"></p><p>存在问题：现在有两个线程A，B，加锁时长设置的是10秒</p><ul><li>线程A先去加锁，执行完所有的逻辑需要 15秒，他加锁成功后，正在执行下面的逻辑，第10秒的时候，锁被释放了</li><li>线程B加锁成功，执行完所有的逻辑需要 8，执行完逻辑后，删除这把锁</li><li>线程A逻辑执行完了，去释放锁，但锁已经被线程B释放掉了</li></ul><p>避免线程A释放线程B的锁，需要在释放锁时多加一个判断，每个线程只释放自己的锁，不能释放别人的锁！可以给每个线程分配一个唯一的UUID</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222036009.png" alt="image-20230228222036009"></p><p>存在问题：</p><p><strong>获取client id 和删除redis必须是原子性操作</strong>，因为可能存在线程A执行到删除锁之前刚好到失效时间了，然后又卡顿了，这时候线程B就又可以获得锁，释放锁，导致线程A又没法释放锁</p><p>解决方式：</p><p>锁续命：搞一个定时任务，设一个间隔时间，小于失效时间，过一段时间去监控业务是否执行完了，执行没结束，也就是锁还没释放，我就再把锁的过期时间重新设置成初始值</p><p><strong>目前还有待完善的点：</strong></p><ul><li><strong>不可重入</strong>，同一个线程无法多次获取同一把锁</li><li><strong>不可重试</strong>，获取锁只尝试一次就返回false，没有重试机制</li><li><strong>主从一致性</strong>，如果Redis提供了主从集群，主从同步存在延迟，当主宕机时，在主节点中的锁数据并没有及时同步到从节点中，则会导致其他线程也能获得锁，引发线程安全问题（延迟时间是在毫秒以下的，所以这种情况概率极低）</li></ul><p>redison</p><p>使用：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222056848.png" alt="image-20230228222056848"></p><p>原理：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222105112.png" alt="image-20230228222105112"></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注册中心</title>
    <link href="/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是注册中心"><a href="#1-什么是注册中心" class="headerlink" title="1 什么是注册中心"></a>1 什么是注册中心</h1><p>在微服务架构中，注册中心是核心的基础服务之一。</p><p>注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。</p><h1 id="2-为什么要有注册中心"><a href="#2-为什么要有注册中心" class="headerlink" title="2 为什么要有注册中心"></a>2 为什么要有注册中心</h1><p>通常，在微服务系统中，如果我们现在的会员服务要调订单服务，就只能把ip写死，一旦Ip变更，或者扩容（再增加机器），会员服务就感受不到</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221602827.png" alt="image-20230228221602827"></p><p>所以需要手动维护一个注册表，增加订单服务的时候，去注册表里注册（<strong>服务注册</strong>），需要调用的时候，先去注册表里查（<strong>服务发现</strong>），再调用。但是当某个节点宕机的时候，我们再去调用就有问题，所以需要借助某些手段可以自动感知到服务下线。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221614178.png" alt="image-20230228221614178"></p><h2 id="3-注册中心实现"><a href="#3-注册中心实现" class="headerlink" title="3 注册中心实现"></a>3 注册中心实现</h2><p>注册中心去实现的时候得支持服务注册和服务发现</p><ul><li>服务注册：就是需要维护一个注册表，存储服务和服务地址的映射关系。<strong>所以需要可以存储数据</strong></li><li>服务发现：当服务要调用的时候，通过读取服务注册表获取可用的服务信息，客户端可以通过此信息连接服务器</li></ul><h2 id="3-1-基于mysql-实现注册中心"><a href="#3-1-基于mysql-实现注册中心" class="headerlink" title="3.1 基于mysql 实现注册中心"></a>3.1 基于mysql 实现注册中心</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221628038.png" alt="image-20230228221628038"></p><ul><li>订单服务启动时，调用注册接口，也就是insert，将服务名，ip，端口以及状态进行存储，对应生成注册表</li><li>每次调用订单服务前，都先去注册表里查询服务列表，执行select</li><li>维护 一个心跳，定期去感应下节点状态是否正常，比如ping一下端口，如果不正常，修改此时节点状态</li></ul><h2 id="3-2-基于zookeeper实现注册中心"><a href="#3-2-基于zookeeper实现注册中心" class="headerlink" title="3.2 基于zookeeper实现注册中心"></a>3.2 基于zookeeper实现注册中心</h2><ul><li>创建父节点，用于管理服务节点</li><li>订单服务启动时，在这个父节点上创建临时子节点，用来存储服务和服务地址的映射关系，对应生成注册表</li><li>每次调用订单服务前，都先去注册表里查询服务列表</li><li>zookeeper有监听通知机制，可以天然感受到服务是否在线，如果对某个节点进行监听，当这个节点被删除，或者被修改时，监听方会感知到修改消息。所以这里，我们只需要监听父节点</li></ul><blockquote><p>创建该节点的 Zookeeper 客户端与 Zookeeper 服务端断开连接时，该节点会被 Zookeeper 服务端移除。使用临时节点来维护 Server 的地址列表就保证了请求不会被分配到已经停机的服务上。</p></blockquote><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228221650614.png" alt="image-20230228221650614"></p>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注册中心</tag>
      
      <tag>mysql实现注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM调优</title>
    <link href="/JVM%E8%B0%83%E4%BC%98/"/>
    <url>/JVM%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-调优原则"><a href="#1-调优原则" class="headerlink" title="1 调优原则"></a>1 调优原则</h1><ul><li><p><strong>多数导致GC问题的Java应⽤，都不是因为我们参数设置错误，⽽是代码问题</strong>；</p></li><li><p>实际使用中，分析GC优化代码，比优化JVM参数效果要好，JVM 参数的默认（推荐）值都是经过 JVM 团队的反复测试和前人的充分验证得出的比较合理的值，因此通常来说是比较靠谱和通用的，一般不会出大问题。</p></li><li><p>如果满足下面的指标，则一般不需要进行GC：</p><ul><li>Minor GC执行时间不到50ms，不低于10秒一次；</li><li>Full GC执行时间不到1s，不低于一小时1次；</li></ul></li></ul><h1 id="2-调优步骤"><a href="#2-调优步骤" class="headerlink" title="2 调优步骤"></a>2 调优步骤</h1><h2 id="2-1-内存分析"><a href="#2-1-内存分析" class="headerlink" title="2.1 内存分析"></a>2.1 内存分析</h2><ul><li>方式： 检查是否有OutOfMemory 等内存异常， 检查哪些对象在系统中数量最大，避免频繁生成新对象，类似天气预报系统里有一个分页展示，每次批量去操作5000个对象，会频繁触发Minor GC 和 Full GC，后面调成500个，基本上就没有Full GC了。</li><li>工具：jmap ‐dump，生成Java虚拟机的堆转储快照dump文件，用jvisualvm命令工具导入该dump文件分析，最多的类是哪些</li><li>参考地址：<a href="https://pyr9.github.io/java%E5%91%BD%E4%BB%A4--jmap%E5%B7%A5%E5%85%B7/">java命令–jmap工具 - 楼上有只喵 (pyr9.github.io)</a></li></ul><h2 id="2-2-死锁检查"><a href="#2-2-死锁检查" class="headerlink" title="2.2 死锁检查"></a>2.2 死锁检查</h2><ul><li><p>方式一：jps+jstack</p><ul><li>运行<code>jps</code>，查看当前所有java进程的pid</li><li><code>jstack pid</code> 查看当前进程的堆栈状态，如果有死锁会打印出来found 1 deadLock</li></ul></li><li><p>方式二：jvisualvm</p><p> 代码运行起来后，启动jvisualvm，在线程页面会直接有一个红色的显示：监测到死锁</p></li><li><p>参考地址：<a href="https://pyr9.github.io/java%E5%91%BD%E4%BB%A4-jstack-%E5%B7%A5%E5%85%B7/">java命令–jstack的使用 - 楼上有只喵 (pyr9.github.io)</a></p></li></ul><h2 id="2-3-CPU分析，哪些方法占用的大量CPU时间"><a href="#2-3-CPU分析，哪些方法占用的大量CPU时间" class="headerlink" title="2.3 CPU分析，哪些方法占用的大量CPU时间"></a>2.3 CPU分析，哪些方法占用的大量CPU时间</h2><ul><li>方式：<ul><li>命令top -p ，显示你的java进程的内存情况，找到当前进程的PID</li><li>top -Hp，获取每个线程的内存情况，获取CPU比较高的线程id，并专成16进制</li><li>执行 <code>jstack PID|grep -A 10 4cd0</code>得到线程堆栈信息，找出可能存在问题的代码，比如大量计算，或者循环new 对象</li></ul></li></ul><h2 id="2-4-垃圾回收器选择"><a href="#2-4-垃圾回收器选择" class="headerlink" title="2.4  垃圾回收器选择"></a>2.4  垃圾回收器选择</h2><ul><li><strong>JDK 1.8默认使用 Parallel</strong>，<strong>JDK 1.9默之后认使用 G1</strong></li><li>100M以下用Serial，简单+高效</li><li>4G以下可以用parallel，并发收集 + 高吞吐量。（标记整理，STW）</li><li>4-8G可以用ParNew+CMS，并发收集 + 低停顿(注重用户体验）</li><li>8G以上可以用G1，避免长时间的停顿+可预期的GC停顿周期 + 高吞吐量(筛选回收时需要STW)</li><li>几百G以上用ZGC，支持TB量级的堆+ 最大GC停顿时间不超10ms</li></ul><h2 id="2-5-Full-GC-次数频繁"><a href="#2-5-Full-GC-次数频繁" class="headerlink" title="2.5 Full GC 次数频繁"></a>2.5 Full GC 次数频繁</h2><p>可以通过<code>jstat -gc pid interval count</code>，每隔interval秒，打印count次，pid进程下GC压力整体情况。观察是否出现频繁Full GC</p><h3 id="2-5-1-调用System-gc-方法的调用"><a href="#2-5-1-调用System-gc-方法的调用" class="headerlink" title="2.5.1 调用System.gc()方法的调用"></a>2.5.1 调用System.gc()方法的调用</h3><ul><li>此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率</li><li><strong>调优建议</strong>：能不使用此方法就别使用，让虚拟机自己去管理它的内存</li></ul><h3 id="2-5-2-方法区空间不足"><a href="#2-5-2-方法区空间不足" class="headerlink" title="2.5.2 方法区空间不足"></a>2.5.2 方法区空间不足</h3><ul><li>方法区存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，方法区可能会被占满，从而执行Full GC。</li><li>元空间的初始阈值设置太小，垃圾收集器调整元空间的大小需要Full GC。比如初始值是21M，full gc后，释放了20M，只剩1M，那么垃圾收集器就会将该值调成2M；相反，如果释放了1M，还剩20M，下次就会调整到40M，这个过程会多次触发full GC.</li><li>一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大。</li><li><strong>调优建议：</strong>对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。常见的问题：项目jar包只有1G，但是启动了好久，就可能是因为由于元空间设置的太小，一直在触发full GC。</li></ul><h3 id="2-5-3-老年代空间不足"><a href="#2-5-3-老年代空间不足" class="headerlink" title="2.5.3 老年代空间不足"></a>2.5.3 老年代空间不足</h3><p><strong>对象转入老年代的场景有：</strong></p><ul><li><p>大对象直接进入老年代：为了避免为大对象GC时，多次在survivor上来回复制而降低效率。</p><ul><li><strong>调优建议：</strong><ul><li>尽量避免写大对象，</li><li>结合你自己系统看下有没有什么大对象 生成，预估下大对象的大小，设置XX:PretenureSizeThreshold的值，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始 化分配的缓存对象，比如大的缓存List，Map之类的对象。</li></ul></li></ul></li><li><p>长期存活的对象进入老年代：默认是经历了15次minor GC ，CMS是6次。</p><ul><li><strong>调优建议：</strong><ul><li>调整Eden和survivor的比例，默认时8:1:1，避免Eden区域过小，导致频繁minor GC，增大系统消耗</li><li>如果我们可以确定大多数对象都是很快会被回收的，可以将该值调小，比如大多数对象都是3次左右就可以被回收，我们可以设置成5，如果超过了5，就说明剩下的应该是一些类似java bean 这种，会长期存活的对象，我们就没必要，让他再待在survivor占用空间了，提前让他们进入老年代。</li></ul></li></ul></li><li><p><strong>对象动态年龄判断</strong>：survivor区域里，对象年龄从小到大排序，当累加到某个年龄时，占用 survivor区域 的50%，就会把这个年龄大的对象都晋升到老年代。 如果系统中朝生夕死的对象比较多，</p><ul><li><strong>调优建议：</strong><ul><li>如果系统中朝生夕死的对象比较多，可以考虑将年轻代参数调大一些，这样对应survivor区域就会对应变大，减少对象因为触发了这个机制，进入到老年代，从而触发Full GC。一般情况，新生代默认是堆大小的1&#x2F;3</li><li>避免Survivor设置过小，导致对象从 eden 直接到达老年代，从而触发Full GC</li></ul></li></ul></li><li><p>老年代空间分配担保机制。 </p><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。</p><ul><li>大于 -&gt; minor GC</li><li>小于 -&gt;查看是否开启了空间担保机制<ul><li>没开启就直接触发full GC，</li><li>开启了，就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，会触发full gc。</li></ul></li></ul></li></ul><h1 id="3-调优案例"><a href="#3-调优案例" class="headerlink" title="3.调优案例"></a>3.调优案例</h1><h2 id="3-1-场景"><a href="#3-1-场景" class="headerlink" title="3.1 场景"></a>3.1 场景</h2><p>天气预报系统，有一个展示所有城市天气预报的页面，由于城市比较多，需要分页去展示，于是先设置了一次查询5000条，由于每一条城市都需要再去给他设置对应的天气信息，所以搞了一个foreach每一条记录都需要new City()，然后再去set天气信息</p><p>初始参数是：</p><p>堆的最大和最小容量都设置了1536M, 年轻代是512M，使用的ParNew+CMS垃圾收集器，元空间256M</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-Xms1536M -Xmx1536M -Xmn512M -Xss256K -XX:<span class="hljs-attribute">SurvivorRatio</span>=6 -XX:<span class="hljs-attribute">MetaspaceSize</span>=256M -XX:<span class="hljs-attribute">MaxMetaspaceSize</span>=512M  -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:<span class="hljs-attribute">CMSInitiatingOccupancyFraction</span>=75 -XX:+UseCMSInitiatingOccupancyOnly<br></code></pre></td></tr></table></figure><h2 id="3-2-观察GC整体情况"><a href="#3-2-观察GC整体情况" class="headerlink" title="3.2 观察GC整体情况"></a>3.2 观察GC整体情况</h2><ul><li><p>step1 : 运行<code> jps</code>看下, 查看当前java进程PID</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222821739.png" alt="image-20230228222821739"></p></li><li><p>step2: 运行 <code>jstat -gc 2593 3000 10000</code>，每隔3秒，打印下GC压力整体情况。观察可发现，程序突然开始频繁Young Gc 和Full GC。</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222903395.png" alt="image-20230228222903395"></p><h2 id="3-2-思考频繁Full-Gc-触发条件"><a href="#3-2-思考频繁Full-Gc-触发条件" class="headerlink" title="3.2 思考频繁Full Gc 触发条件"></a>3.2 思考频繁Full Gc 触发条件</h2><ul><li><p>调用System.gc()方法的调用。   <strong>-&gt; 不可能，系统中没这样调用</strong></p></li><li><p>云空间，方法区空间不足  <strong>-&gt; 不可能，观察MU并没有很大变化，说明元空间没有一直扩容，所以空间是够的</strong></p></li><li><p>老年代空间不足，对象转入老年代的场景有：</p><ul><li>大对象直接进入老年代：为了避免为大对象GC时，多次在survivor上来回复制而降低效率。   <strong>-&gt; 不可能，系统中没很多大对象</strong></li><li>长期存活的对象进入老年代：默认是经历了15次minor GC ，CMS是6次 <strong>-&gt; 可能，代码在频繁生成对象，且占用周期比较长。有可能是代码有问题，其实我们可以频繁生成对象，但是应该让他朝生夕死。</strong></li><li><strong>对象动态年龄判断</strong>：survivor区域里，对象年龄从小到大排序，当累加到某个年龄时，占用 survivor区域 的50%，就会把这个年龄大的对象都晋升到老年代。  <strong>-&gt; 可能，因为现在是频繁生成了对象，可以考虑年轻代调大一些。</strong></li></ul></li><li><p>老年代空间分配担保机制。 <strong>-&gt; 可能性不大，因为老年代挺大的</strong></p></li></ul><h2 id="3-3-调优步骤"><a href="#3-3-调优步骤" class="headerlink" title="3.3 调优步骤"></a>3.3 调优步骤</h2><p>如果是对于对象动态年龄判断机制导致的full gc较为频繁可以先试着优化下JVM参数，把年轻代适当调大点： -Xmn1024M</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xms1536M -Xmx1536M -Xmn1024M -Xss256K -XX:SurvivorRatio=<span class="hljs-number">6</span> -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=512M  -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=<span class="hljs-number">75</span> -XX:+UseCMSInitiatingOccupancyOnly<br></code></pre></td></tr></table></figure><p>我们发现young gc和full gc依然很频繁了，而且看到有大量的对象频繁的被挪动到老年代</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222923471.png" alt="image-20230228222923471"></p><p>这种情况我们可以借助jmap或者jvisualvm命令大概看下是什么对象</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222946533.png" alt="image-20230228222946533"></p><p>查到了有大量User对象产生，这个可能是问题所在，但不确定，还必须找到对应的代码确认，如何去找对应的代码了？ </p><p>1、代码里全文搜索生成User对象的地方(适合只有少数几处地方的情况) </p><p>2、如果生成User对象的地方太多，无法定位具体代码，我们可以同时分析下占用cpu较高的线程，一般有大量对象不断产生，对应的方法 代码肯定会被频繁调用，占用的cpu必然较高 </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222956571.png" alt="image-20230228222956571"></p><p>可以用上面讲过的jstack或jvisualvm来定位cpu使用较高的代码，最终定位到的代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/report&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeatherReportController</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 模拟批量查询城市天气预报场景</span><br><span class="hljs-comment">   */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ArrayList&lt;City&gt; <span class="hljs-title">queryCities</span><span class="hljs-params">()</span> </span>&#123;<br>    ArrayList&lt;City&gt; cities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>      cities.add(<span class="hljs-keyword">new</span> City(String.valueOf(i),<span class="hljs-string">&quot;深圳&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> cities;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">City</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String id;<br><br>  <span class="hljs-keyword">private</span> String name;<br><br>  <span class="hljs-keyword">private</span> String code;<br><br>  <span class="hljs-keyword">byte</span>[] info = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">100</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，java的代码也是需要优化的，一次查询出500M的对象出来，明显不合适，要根据之前说的各种原则尽量优化到合适的值，尽量消除这种朝生夕死的对象导致的full gc</p><p>改成批量查询500后，Full GC 基本不再发生</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223006680.png" alt="image-20230228223006680"></p><h1 id="4-内存泄露到底是怎么回事"><a href="#4-内存泄露到底是怎么回事" class="headerlink" title="4 内存泄露到底是怎么回事"></a>4 <strong>内存泄露到底是怎么回事</strong></h1><p>一般电商架构可能会使用多级缓存架构，就是redis加上JVM级缓存，大多数同学可能为了图方便对于JVM级缓存就简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏，对于一些老旧数据没有及时清理导致一直占用着宝贵的内存资源，时间长了除了导致full gc，还有可能导致OOM。 </p><p>这种情况完全可以考虑采用一些成熟的JVM级缓存框架来解决，比如ehcache等自带一些LRU数据淘汰算法的框架来作为JVM级的缓存。</p>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能调优</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾收集器之ZGC收集器</title>
    <link href="/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B9%8BZGC%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B9%8BZGC%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ZGC收集器-XX-UseZGC"><a href="#ZGC收集器-XX-UseZGC" class="headerlink" title="ZGC收集器(-XX:+UseZGC)"></a><strong>ZGC收集器</strong>(-XX:+UseZGC)</h1><p>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器。JDK 11只支持linux系统，JDK 14才支持了macOs和Windows系统</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225702509.png" alt="image-20230228225702509"></p><h2 id="一-特点"><a href="#一-特点" class="headerlink" title="一 特点"></a>一 特点</h2><h3 id="1-支持TB量级的堆。"><a href="#1-支持TB量级的堆。" class="headerlink" title="1. 支持TB量级的堆。"></a>1. <strong>支持TB量级的堆</strong>。</h3><p>这应该可以满足未来十年内，所有JAVA应用的需求了 吧。</p><h3 id="2-最大GC停顿时间不超10ms。"><a href="#2-最大GC停顿时间不超10ms。" class="headerlink" title="2. 最大GC停顿时间不超10ms。"></a>2. <strong>最大GC停顿时间不超10ms</strong>。</h3><ul><li>目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右， Major GC一般都需要100ms以上</li><li>G1可以调节停顿时间，但是如果调的过低的话，反而会适得其反</li></ul><h3 id="3-最糟糕的情况下吞吐量会降低15-。"><a href="#3-最糟糕的情况下吞吐量会降低15-。" class="headerlink" title="3. 最糟糕的情况下吞吐量会降低15%。"></a>3. 最糟糕的情况下吞吐量会降低15%。</h3><p>它的停顿时间不会随着堆的增大而增长！也就是说，几十G堆的停顿时间是 10ms以下，几百G甚至上T堆的停顿时间也是10ms以下</p><h3 id="4-不分代-暂时"><a href="#4-不分代-暂时" class="headerlink" title="4. 不分代(暂时)"></a>4. <strong>不分代(暂时)</strong></h3><p>分代的原因是因为每个对象的生命周期不同，我们需要回收的时间也不同。ZGC不分代是因为暂时还没有实现这个功能，实现起来比较麻烦。</p><h3 id="5-ZGC的Region可以具有大、-中、-小三类容量"><a href="#5-ZGC的Region可以具有大、-中、-小三类容量" class="headerlink" title="5. ZGC的Region可以具有大、 中、 小三类容量"></a>5. ZGC的Region可以具有大、 中、 小三类容量</h3><p>小型Region（Small Region） ： 容量固定为2MB， 用于放置小于256KB的小对象。 </p><p>中型Region（Medium Region） ： 容量固定为32MB， 用于放置大于等于256KB但小于4MB的对象。 </p><p>大型Region（Large Region） ： 容量不固定， 可以动态变化， 但必须为2MB的整数倍， 用于放置4MB或 以上的大对象。 每个大型Region中 ，只会存放一个大对象</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225713386.png" alt="image-20230228225713386"></p><h2 id="二-ZGC存在的问题"><a href="#二-ZGC存在的问题" class="headerlink" title="二 ZGC存在的问题"></a>二 <strong>ZGC存</strong>在的问题</h2><ul><li>ZGC最大的问题是<strong>浮动垃圾</strong>。1 ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。 所以就不存在Young GC、Old GC，所有的GC行为都是Full GC</li><li>ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。</li></ul><p><strong>解决方案</strong> </p><p>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根 本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。 </p><h2 id="三-ZGC运作过程"><a href="#三-ZGC运作过程" class="headerlink" title="三 ZGC运作过程"></a>三 <strong>ZGC运作过程</strong></h2><h3 id="1-并发标记（Concurrent-Mark）"><a href="#1-并发标记（Concurrent-Mark）" class="headerlink" title="1. 并发标记（Concurrent Mark）"></a>1. 并发标记（Concurrent Mark）</h3><ul><li>相当于SMS收集器的初始标记+并发标记+重新标记。</li><li>初始标记 (<strong>Mark Start</strong>)和最终标记(<strong>Mark End</strong>)也会出现短暂的停顿</li><li>G1不同的是， ZGC的标记是在指针上而不是在对象上进行的， 标记阶段会更新染色指针中的Marked 0、 Marked 1标志位。</li></ul><h3 id="2-并发预备重分配（Concurrent-Prepare-for-Relocate）"><a href="#2-并发预备重分配（Concurrent-Prepare-for-Relocate）" class="headerlink" title="2. 并发预备重分配（Concurrent Prepare for Relocate）"></a>2. 并发预备重分配（Concurrent Prepare for Relocate）</h3><ul><li>这个阶段需要根据特定的查询条件统计得出本次收 集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。</li><li>ZGC每次回收都会扫描所有的 Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</li></ul><h3 id="3-并发重分配（Concurrent-Relocate）"><a href="#3-并发重分配（Concurrent-Relocate）" class="headerlink" title="3. 并发重分配（Concurrent Relocate）"></a>3. 并发重分配（Concurrent Relocate）</h3><ul><li>重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<strong>转发表（Forward Table）</strong>，记录从旧对象到新对象的转向关系。</li><li>如果用户线程此时并 发访问了位于重分配集中的对象，这次访问将会根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指 针的“自愈”（Self-Healing）能力。 </li><li>ZGC的颜色指针因为“自愈”（Self‐Healing）能力，所以只有第一次访问旧对象会变慢， <strong>一旦重分配集中某个Region的存活对象都复制完毕 后， 这个Region就可以立即释放用于新对象的分配</strong>，但是转发表还得留着不能释放掉， 因为可能还有访问在使用这个转发表。</li></ul><h3 id="4-并发重映射（Concurrent-Remap）"><a href="#4-并发重映射（Concurrent-Remap）" class="headerlink" title="4. 并发重映射（Concurrent Remap）"></a>4. <strong>并发重映射（Concurrent Remap）</strong></h3><ul><li>重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，</li><li>但 是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。</li><li>ZGC很巧妙地把并发重映射阶段要做的 工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节 省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。</li></ul><blockquote><p>2，3，4 步相当于是实现了CSM的并发清除，但是是使用的复制算法，</p></blockquote><blockquote><p>G1 在这一步是STW的，直接复制完需要存活的对象，修正对象的引用到新引用上就可以。ZGC需要再保留一份旧对象到新对象的转向关系，而且还需要再做一次旧数据的重映射。</p></blockquote><h2 id="四-ZGC触发时机"><a href="#四-ZGC触发时机" class="headerlink" title="四 ZGC触发时机"></a>四 <strong>ZGC触发时机</strong></h2><p>ZGC目前有4中机制触发GC： </p><ul><li><p>定时触发，默认为不使用，可通过ZCollectionInterval参数配置。 </p></li><li><p>预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要时统计GC时间，为其他GC机制使用。 </p></li><li><p>分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点， 在耗尽之前触发GC（耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间）。 </p></li><li><p>主动触发，（默认开启，可通过ZProactive参数配置） 距上次GC堆内存增长10%，或超过5分钟时，对比距上 次GC的间隔时间跟（49 * 一次GC的最大持续时间），超过则触发。</p></li></ul><h2 id="五-如何选择垃圾收集器"><a href="#五-如何选择垃圾收集器" class="headerlink" title="五 如何选择垃圾收集器"></a>五 <strong>如何选择垃圾收集器</strong></h2><ol><li><p>优先调整堆的大小让服务器自己来选择 </p></li><li><p>如果内存小于100M，使用串行收集器 </p></li><li><p>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 </p></li><li><p>如果允许停顿时间超过1秒，选择并行或者JVM自己选 </p></li><li><p>如果响应时间最重要，并且不能超过1秒，使用并发收集器 </p></li><li><p>4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC</p></li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225722421.png" alt="image-20230228225722421"></p><blockquote><p><strong>JDK 1.8默认使用 Parallel(年轻代和老年代都是)</strong> </p></blockquote><blockquote><p><strong>JDK 1.9默认使用 G1</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能调优</tag>
      
      <tag>垃圾收集器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾收集器之G1收集器</title>
    <link href="/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B9%8BG1%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B9%8BG1%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="G1收集器-XX-UseG1GC"><a href="#G1收集器-XX-UseG1GC" class="headerlink" title="G1收集器(-XX:+UseG1GC)"></a><strong>G1收集器</strong>(<strong>-XX:+UseG1GC</strong>)</h1><p><strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多核处理器及大容量内存的机器</strong>. 满足<strong>可预测的停顿时间停顿时间的同时,还具备高吞吐量性能特征.</strong> </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232909465.png" alt="image-20230228232909465"></p><h2 id="一-特点"><a href="#一-特点" class="headerlink" title="一 特点"></a>一 特点</h2><h3 id="1-分代收集"><a href="#1-分代收集" class="headerlink" title="1. 分代收集"></a>1. 分代收集</h3><ul><li><p>虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念</p></li><li><p>G1将Java堆划分为多个大小相等的独立区域（<strong>Region</strong>），一般Region大小等于堆大小除以2048，JVM最多可以有2048个Region。 </p></li><li><p>这些Region中包含了逻辑上的年轻代和老年代，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</p></li><li><p>默认年轻代对堆内存的占比是5%，可以通过“-XX:G1NewSizePercent”设置年轻代初始占比。</p></li><li><p>在系统运行中，JVM会不停的给年轻代增加更多的Region，但最多新生代的占比不会超过60%，可以通过“</p><p>-XX:G1MaxNewSizePercent”调整。</p></li><li><p>年轻代中的Eden和 Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100 个，s1对应100个</p></li><li><p>一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。</p></li></ul><h3 id="2-并行与并发"><a href="#2-并行与并发" class="headerlink" title="2. 并行与并发"></a>2. <strong>并行与并发</strong></h3><ul><li>并行性: G1能充分利用CPU、多核环境下的硬件优势，通过多个GC线程同时工作，来缩短Stop-The-World停顿时间。</li><li>并发性: G1拥有与应用程序交替执行的能力,部分工作可以和应用程序同时执行,因此,一般来说,不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><blockquote><p><strong>并发和并行的区别</strong></p><p>并行，指的是多个事情，在<strong>同一时间点上</strong>同时发生了。并行的多个任务之间是不互相抢占资源的，系统要有多个CPU才会出现并行</p><p>并发，指的是多个事情，在<strong>同一时间段内</strong>同时发生了。  并发的多个任务之间是互相抢占资源的，整个过程中看似是多个任务同时完成的的，但其实是CPU在多次切换。</p></blockquote><h3 id="3-空间整合"><a href="#3-空间整合" class="headerlink" title="3. 空间整合"></a>3. 空间整合</h3><ul><li>G1将内存划分为一个个的region。 内存的回收是<strong>以region作为基本单位的</strong>。</li><li>Region之间是复制算法,但整体上实际可看作是<strong>标记- 整理算法</strong>,两种算法都可以避免内存碎片。</li></ul><h3 id="4-可预测的停顿"><a href="#4-可预测的停顿" class="headerlink" title="4. 可预测的停顿"></a>4. 可预测的停顿</h3><ul><li>降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立<strong>可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数”<strong>-</strong> <strong>XX:MaxGCPauseMillis</strong>“指定)内完成垃圾收集。</li><li>这里设置的“期望值”必须是符合实际的， 它默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 最终占满堆引发 Full GC反而降低性能。</li></ul><h2 id="二-GC的运作过程"><a href="#二-GC的运作过程" class="headerlink" title="二 GC的运作过程"></a>二 GC的运作过程</h2><h3 id="1-初始标记（initial-mark，STW）"><a href="#1-初始标记（initial-mark，STW）" class="headerlink" title="1.初始标记（initial mark，STW）"></a>1.<strong>初始标记</strong>（initial mark，STW）</h3><p>暂停所有的其他线程，并记录下gc roots直接能引用的对象，<strong>速度很快</strong> </p><h3 id="2-并发标记（Concurrent-Marking）"><a href="#2-并发标记（Concurrent-Marking）" class="headerlink" title="2. 并发标记（Concurrent Marking）"></a>2. 并发标记（Concurrent Marking）</h3><p>同CMS的并发标记 </p><h3 id="3-最终标记（Remark，STW）"><a href="#3-最终标记（Remark，STW）" class="headerlink" title="3. 最终标记（Remark，STW）"></a>3. <strong>最终标记</strong>（Remark，STW）</h3><p>同CMS的重新标记 </p><h3 id="4-筛选回收（Cleanup，STW）"><a href="#4-筛选回收（Cleanup，STW）" class="headerlink" title="4. 筛选回收（Cleanup，STW）"></a>4. <strong>筛选回收</strong>（Cleanup，STW）</h3><p>筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划。</p><ul><li><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region</strong>，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。</li><li>比如说老年代此时有1000个 Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(<strong>Collection Set</strong>，要回收的集 合)，尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li><li>CMS回收阶段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本</li></ul><h2 id="三-G1垃圾收集分类"><a href="#三-G1垃圾收集分类" class="headerlink" title="三 G1垃圾收集分类"></a>三 <strong>G1垃圾收集分类</strong></h2><h3 id="1-YoungGC"><a href="#1-YoungGC" class="headerlink" title="1. YoungGC"></a>1. <strong>YoungGC</strong></h3><ul><li>YoungGC并不是说现有的Eden区放满了就会马上触发，</li><li>G1会计算下现在Eden区回收大概要多久时间，如果回收时 间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC</li></ul><h3 id="2-MixedGC"><a href="#2-MixedGC" class="headerlink" title="2. MixedGC"></a>2. <strong>MixedGC</strong></h3><ul><li>不是FullGC，老年代的占用空间达到整堆的阈值(<strong>-XX:InitiatingHeapOccupancyPercent</strong>设定的值，默认45%)则触发，回收所有的 Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，</li><li>正常情况G1的垃圾收集是先做 MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现<strong>没有足够</strong> <strong>的空region</strong>能够承载拷贝对象就会触发一次Full GC</li></ul><h3 id="3-Full-GC"><a href="#3-Full-GC" class="headerlink" title="3. Full GC"></a><strong>3. Full GC</strong></h3><ul><li><p>停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用</p></li><li><p>这个过程是非常耗时的。(Shenandoah优化成多线程收集了) 。Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。</p></li></ul><h2 id="四-G1-大对象的处理"><a href="#四-G1-大对象的处理" class="headerlink" title="四 G1 大对象的处理"></a>四 G1 大对象的处理</h2><ul><li>G1有专门分配 大对象的Region叫<strong>Humongous区</strong>，而不是让大对象直接进入老年代的Region中。</li><li>在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放 入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。</li><li>Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开 销。</li></ul><h2 id="五-G1收集器参数设置"><a href="#五-G1收集器参数设置" class="headerlink" title="五 G1收集器参数设置"></a>五 <strong>G1收集器参数设置</strong></h2><ul><li><p>-XX:+UseG1GC:使用G1收集器</p></li><li><p>-XX:ParallelGCThreads:指定GC工作的线程数量</p></li><li><p>-XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区</p></li><li><p><strong>-XX:MaxGCPauseMillis</strong>:目标暂停时间(默认200ms)</p></li><li><p>-XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%，值配置整数，默认就是百分比)</p></li><li><p>-XX:G1MaxNewSizePercent:新生代内存最大空间</p></li><li><p>-XX:TargetSurvivorRatio:Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代</p></li><li><p>-XX:MaxTenuringThreshold:最大年龄阈值(默认15)</p></li><li><p>**-XX:InitiatingHeapOccupancyPercent:**老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(<strong>MixedGC</strong>)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能就要触发MixedGC了</p></li><li><p><strong>-XX:G1MixedGCLiveThresholdPercent(默认85%)</strong>  region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。</p></li><li><p><strong>-XX:G1MixedGCCountTarget</strong>:在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长。</p></li><li><p>-XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。</p></li></ul><blockquote><p>-XX 后面带的X越多，说明这个参数越不稳定，后面可能会被废弃掉，比如java –version，这种事最稳定的</p></blockquote><h2 id="六-G1垃圾收集器优化建议"><a href="#六-G1垃圾收集器优化建议" class="headerlink" title="六 G1垃圾收集器优化建议"></a>六 <strong>G1垃圾收集器优化建议</strong></h2><p>调节 -XX:MaxGCPauseMills 这个参数的值，避免 -XX:MaxGCPauseMills过大用户体验不好，-XX:MaxGCPauseMills过小，垃圾堆积至占满整个堆，触发full GC。</p><ul><li><p>假设参数 -XX:MaxGCPauseMills 设置的值很小， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 最终占满堆引发 Full GC反而降低性能</p></li><li><p>假设参数 -XX:MaxGCPauseMills 设置的值很大，导致系统停顿很久，用户体验不好。</p></li></ul><h2 id="七-G1的使用场景"><a href="#七-G1的使用场景" class="headerlink" title="七 G1的使用场景"></a>七 <strong>G1的使用场景</strong></h2><h3 id="1-希望消除长时间的GC停顿（超过0-5-1秒）"><a href="#1-希望消除长时间的GC停顿（超过0-5-1秒）" class="headerlink" title="1. 希望消除长时间的GC停顿（超过0.5-1秒）"></a>1. 希望消除长时间的GC停顿（超过0.5-1秒）</h3><p>对于类似Kafka的系统，因为他需要支持每秒处理百万级的消息，所以一般需要大内存机器来部署，比如三四十G，对于这么大的内存，minor GC 即使使用复制算法，也就不再快了，很可能会出现系统每运行一两分钟就会因为minor gc卡顿几秒钟没法处理新消息，这显然是不可以的。使用G1收集器就可以消除长时间的GC停顿，比如设置停顿时间是50ms，后50ms的卡顿其实完全能够接受，用户几乎无感知，那么整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边收集垃圾。</p><h3 id="2-想要更可控、可预期的GC停顿周期"><a href="#2-想要更可控、可预期的GC停顿周期" class="headerlink" title="2. 想要更可控、可预期的GC停顿周期"></a>2. 想要更可控、可预期的GC停顿周期</h3><h3 id="3-多核CPU，大内存"><a href="#3-多核CPU，大内存" class="headerlink" title="3. 多核CPU，大内存"></a>3. 多核CPU，大内存</h3><p>8GB以上的堆内存(建议值)，因为g1算法很复杂，内存不够大，就不要用了</p><h3 id="4-？？"><a href="#4-？？" class="headerlink" title="4. ？？"></a>4. ？？</h3><ul><li><p>对象分配或者晋升的速度变化大  ？？</p></li><li><p>实时数据占用超过一半的堆空间  ？？</p></li></ul><h2 id="八-CMS收集器和G1收集器的区别"><a href="#八-CMS收集器和G1收集器的区别" class="headerlink" title="八 CMS收集器和G1收集器的区别"></a>八 CMS收集器和G1收集器的区别</h2><h3 id="1-使用范围不一样"><a href="#1-使用范围不一样" class="headerlink" title="1. 使用范围不一样"></a>1. 使用范围不一样</h3><ul><li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用</li><li>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</li></ul><h3 id="2-STW的时间"><a href="#2-STW的时间" class="headerlink" title="2. STW的时间"></a>2. STW的时间</h3><ul><li>CMS收集器以最小的停顿时间为目标的收集器。只有初始标记和重新标记需要STW</li><li>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）。除了初始标记和重新标记需要STW，筛选回收时也需要STW，不过停顿时间可预测</li></ul><h3 id="3-垃圾碎片"><a href="#3-垃圾碎片" class="headerlink" title="3. 垃圾碎片"></a>3. 垃圾碎片</h3><ul><li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片</li><li>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</li></ul><h3 id="4-垃圾回收的过程不一样"><a href="#4-垃圾回收的过程不一样" class="headerlink" title="4. 垃圾回收的过程不一样"></a>4. 垃圾回收的过程不一样</h3><ul><li>CMS: 初始标记 + 并发标记 + 重新标记 + 并发清除</li><li>G1: 初始标记 + 并发标记 + 最终标记 + 筛选回收</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能调优</tag>
      
      <tag>垃圾收集器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾收集器</title>
    <link href="/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-垃圾收集算法"><a href="#1-垃圾收集算法" class="headerlink" title="1 垃圾收集算法"></a>1 <strong>垃圾收集算法</strong></h1><h2 id="1-1-标记-清除算法"><a href="#1-1-标记-清除算法" class="headerlink" title="1.1 标记 - 清除算法"></a>1.1 <strong>标记 - 清除算法</strong></h2><p>算法分为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>缺点:<br>（1）效率问题， 标记和清除两个过程的效率都不高；<br>（2）空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存面不得不提前触发另一次垃圾收集动作。</p><h2 id="1-2-标记-整理算法"><a href="#1-2-标记-整理算法" class="headerlink" title="1.2 标记 - 整理算法"></a>1.2 <strong>标记 - 整理算法</strong></h2><p> 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br>优点: 不会产生内存碎片<br>不足: 需要移动大量对象，处理效率比较低。</p><h2 id="1-3-复制算法"><a href="#1-3-复制算法" class="headerlink" title="1.3 复制算法"></a>1.3 <strong>复制算法</strong></h2><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>新生代的对象每次在每次垃圾收集时都会有大批对象死去，只有少量存活，因此我们不需要按照1:1划分内存空间而是 将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块Survivor。</p><p>在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor空间。（HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1:1）</p><h2 id="1-4-分代收集算法"><a href="#1-4-分代收集算法" class="headerlink" title="1.4 分代收集算法"></a>1.4 <strong>分代收集算法</strong></h2><p>当前虚拟机的垃圾收集都采用分代收集算法，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><ul><li><p>新生代使用：复制算法</p><p>新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</p></li><li><p>老年代使用：标记 - 清除 或者 标记 - 整理 算法</p><p>而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。<strong>“标记-清除”或“标记-整理”算法会比复制算法慢10倍以 上。</strong></p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232824370.png" alt="image-20230228232824370"></p><h1 id="2-垃圾收集器"><a href="#2-垃圾收集器" class="headerlink" title="2 垃圾收集器"></a>2 <strong>垃圾收集器</strong></h1><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong> </p><p>虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。</p><p>对于JDK8默认的垃圾回收器是-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)，如果内存较大(超过4个G，只是经验值)，系统对停顿时间比较敏感，我们可以使用<strong>ParNew+CMS(</strong>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC**)** </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232833764.png" alt="image-20230228232833764"></p><h2 id="2-1-Serial收集器"><a href="#2-1-Serial收集器" class="headerlink" title="2.1 Serial收集器"></a>2.1 Serial收集器</h2><ul><li><strong>-XX:+UseSerialGC -XX:+UseSerialOldGC</strong></li><li>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。</li><li>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。进行垃圾收集时必须暂停其他所有的工作线程(<strong>“Stop The World”</strong>) ，直到它收集结束。</li><li>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</li><li><strong>Serial Old收集器是Serial收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5 以及以前的版本中与Parallel Scavenge收集器搭配使用，<strong>另一种用途是作为CMS收集器的后备方案</strong>。</li></ul><blockquote><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> </p></blockquote><h2 id="2-2-Parallel-Scavenge收集器"><a href="#2-2-Parallel-Scavenge收集器" class="headerlink" title="2.2 Parallel Scavenge收集器"></a>2.2 <strong>Parallel Scavenge收集器</strong></h2><ul><li><strong>-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代)</strong></li><li><strong>Parallel</strong>收集器其实<strong>就是Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。</li><li>默认的收集线程数跟cpu核数相同，当然也可以用参数(- XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。 </li><li><strong>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU，获取最短的垃圾回收时间）</strong></li><li><strong>Parallel Old收集器是Parallel Scavenge收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(<strong>JDK8默认的新生代和老年代收集器</strong>)。</li></ul><blockquote><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p></blockquote><h2 id="2-3-ParNew收集器"><a href="#2-3-ParNew收集器" class="headerlink" title="2.3 ParNew收集器"></a>2.3 ParNew收集器</h2><ul><li><p><strong>-XX:+UseParNewGC</strong></p></li><li><p>ParNew收集器其实<strong>跟Parallel收集器很类似</strong>，区别主要在于它可以和CMS收集器配合使用。</p></li></ul><blockquote><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> </p></blockquote><h2 id="2-4-CMS收集器"><a href="#2-4-CMS收集器" class="headerlink" title="2.4 CMS收集器"></a>2.4 <strong>CMS收集器</strong></h2><ul><li><p><strong>-XX:+UseConcMarkSweepGC(old)</strong></p></li><li><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体</strong> <strong>验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程</strong> <strong>（基本上）同时工作</strong></p></li><li><p>整个过程分为四个步骤： </p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：用户可同时运行的，耗时较长。</li></ul></li><li><p>优缺点：</p><ul><li>优点：<strong>并发收集、低停顿</strong>。由于在整个过程和中最耗时的并发标记和 并发清除过程收集器程序都可以和用户线程一起工作，所以总体来说，Cms收集器的内存回收过程是与用户线程一起并发执行的。</li><li>缺点：<ul><li>对CPU敏感，并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢，总吞吐量会降低</li><li>CMS基于标记 - 清除算法，会导致空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。，当然通过参数- XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理 </li><li>无法处理浮动垃圾。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li></ul></li></ul></li><li><p><strong>CMS的相关核心参数</strong></p></li></ul><ol><li><p>-XX:+UseConcMarkSweepGC：启用cms </p></li><li><p>-XX:ConcGCThreads：并发的GC线程数 </p></li><li><p>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片） </p></li><li><p>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次</p></li><li><p><strong>-XX:CMSInitiatingOccupancyFraction</strong>: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比） </p></li><li><p>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整 </p></li><li><p>-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段 </p></li><li><p>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW </p></li><li><p>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</p></li></ol><blockquote><p><strong>只可以用在老年代，使用“标记-清除”算法</strong></p></blockquote><h2 id="2-5-G1收集器"><a href="#2-5-G1收集器" class="headerlink" title="2.5 G1收集器"></a>2.5 <strong>G1收集器</strong></h2><p><a href="https://pyr9.github.io/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B9%8BG1%E6%94%B6%E9%9B%86%E5%99%A8/">垃圾收集器之G1收集器 - 楼上有只喵 (pyr9.github.io)</a></p><h2 id="2-6-ZGC收集器"><a href="#2-6-ZGC收集器" class="headerlink" title="2.6 ZGC收集器"></a>2.6 ZGC收集器</h2><p><a href="https://pyr9.github.io/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B9%8BZGC%E6%94%B6%E9%9B%86%E5%99%A8/">垃圾收集器之ZGC收集器 - 楼上有只喵 (pyr9.github.io)</a></p><h1 id="3-什么情况下会触发Full-GC"><a href="#3-什么情况下会触发Full-GC" class="headerlink" title="3. 什么情况下会触发Full GC?"></a>3. 什么情况下会触发Full GC?</h1><p><a href="https://pyr9.github.io/JVM%E8%B0%83%E4%BC%98/#2-5-Full-GC-%E6%AC%A1%E6%95%B0%E9%A2%91%E7%B9%81">JVM调优 - 楼上有只喵 (pyr9.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能调优</tag>
      
      <tag>垃圾收集算法</tag>
      
      <tag>垃圾收集器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM调优案例(一)——日均百万级订单交易系统如何设置JVM参数</title>
    <link href="/JVM%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B-%E4%B8%80-%E2%80%94%E2%80%94%E6%97%A5%E5%9D%87%E7%99%BE%E4%B8%87%E7%BA%A7%E8%AE%A2%E5%8D%95%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEJVM%E5%8F%82%E6%95%B0/"/>
    <url>/JVM%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B-%E4%B8%80-%E2%80%94%E2%80%94%E6%97%A5%E5%9D%87%E7%99%BE%E4%B8%87%E7%BA%A7%E8%AE%A2%E5%8D%95%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEJVM%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><p>有一个订单系统，需要支持每秒支持下300个订单。假定每个订单对象是1kb，那么每秒将会有300kb对象生成。</p><p>下单可能还涉及创建其他对象创建，比如库存，优惠卷，积分，以及这个系统可能还支持订单的查询，我们放大20倍，那么就是300 * 20  &#x3D; 6000kb，约60MB，也就是这个系统每秒会产生60M的垃圾。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224236047.png" alt="image-20230228224236047"></p><p>假设机器是4核8G，那么一般可能会给我们虚拟机分配个四五G的内存，就会给堆分配个3G的内存，那么方法区分配256M，单个栈内存分配1M。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> ‐Xms3072M ‐Xmx3072M ‐Xss1M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:SurvivorRatio=<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>那么这么分配有什么问题呢？如果是一个并发量不大的系统，基本上也不会有什么问题，因为本身也没有多少对象在堆里生成。但是如果是我们上面说的亿级流量系统，就不能简简单单这么设置了，我们来分析一下：</p><p>堆分配的大小是3G，按照1:2分配年轻代和老年代的话，可以算出年轻代是1G，老年代是2G，年轻代再按照8:1:1细分eden和survivor，eden是800M，单个survivor是100M。如果每秒产生60M对象，优先在eden分配，也就是差不多13秒，eden就会被占满，发生minor GC，这是90%的对象已经被回收了，还存在一些正在使用的对象，假定是60M对象还不会被回收。</p><p>那么这60M对象会从Eden区移到S0区域，由于存在动态年龄判断，就是一批对象的总大小大于这块Survivor区域内存大小的，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以直接进入老年代了。这样的话，每13秒就会有60M的对象被移入老年代。</p><p>那么大概五六分钟老年代的2G就会被占满，那么老年代一满就要发生full gc</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224246219.png" alt="image-20230228224246219"></p><p><a href="https://blog.csdn.net/weixin_44704538/article/details/108222022">(129条消息) JVM的STW(stop the world)机制及调优案例_JavaRecord的博客-CSDN博客_stw机制</a></p><p>来分析一下：我们这个系统其实没有很多会长久存在的对象，也就是老不死的对象，我们放在老年代的那些60M的对象，在一两秒后其实都会变为垃圾对象，在下一次full gc时都会被回收掉，那么我们这种业务场景，完全没必要给老年代设置2G的内存，根本用不到。</p><p>我们完全可以把年轻代设置的大一些，我们现在来对jvm参数进行一些更改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> ‐Xms3072M ‐Xmx3072M ‐Xmn2048M ‐Xss1M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:SurvivorRatio=<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>此时需要25秒把伊甸园区放满，放满minor gc后有60M对象不被回收，要移到S0区，这时60M&lt;200M&#x2F;2，是可以移入S0区域的，下一次伊甸园区再放满做minor gc的时候，这时这60M对象所对应的订单已经生成了，已经变成了垃圾对象，是可以直接被回收的，所以没有什么对象是需要被移入老年代的。</p><p>那么这么一设置的话，这个系统是不是正常情况下基本不会再发生full gc了呢？就算发生，也是很久才会一次了。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224257622.png" alt="image-20230228224257622"></p>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象内存分配</title>
    <link href="/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a>对象内存分配策略</h1><ul><li>JVM通过<strong>逃逸分析</strong>确定该对象不会被外部访问。如果不会逃逸可以将该对象在<strong>栈上分配</strong>内存</li><li>大多数情况下，对象在新生代中 Eden 区分配。</li><li><strong>大对象直接进入老年代</strong></li><li><strong>长期存活的对象将进入老年代</strong> </li><li><strong>对象动态年龄判断</strong></li><li><strong>老年代空间分配担保机制</strong></li></ul><h2 id="对象栈上分配"><a href="#对象栈上分配" class="headerlink" title="对象栈上分配"></a><strong>对象栈上分配</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>我们通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。</p></li><li><p>为了减少临时对象在堆内分配的数量，JVM通过<strong>逃逸分析</strong>确定该对象不会被外部访问。如果不会逃逸可以将该对象在<strong>栈上分配</strong>内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p></li></ul><h3 id="对象逃逸分析"><a href="#对象逃逸分析" class="headerlink" title="对象逃逸分析"></a>对象逃逸分析</h3><p><strong>对象逃逸分析</strong>：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>  User user = <span class="hljs-keyword">new</span> User();<br>  user.setId(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> user;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>  User user = <span class="hljs-keyword">new</span> User();<br>  user.setId(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，test1方法中的user对象被返回了，这个对象的作用域范围不确定，test2方法中的user对象我们可以确定当方法结 束这个对象就可以认为是无效对象了，对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内 存一起被回收掉。</p><p>JVM对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过<strong>标量替换</strong>优先分配在栈上(<strong>栈上分配</strong>），JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis)</p><blockquote><p><strong>标量替换：</strong>通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<strong>JVM不会创建该对象</strong>，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启</p></blockquote><h3 id="栈上分配示例"><a href="#栈上分配示例" class="headerlink" title="栈上分配示例"></a><strong>栈上分配示例</strong></h3><p>代码调用了1亿次test()，如果是分配到堆上，大概需要1GB以上堆空间，如果堆空间小于该值，必然会触发GC。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoEscapeAnalysis</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>      test();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User();<br>    user.setId(<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用如下参数不会发生GC</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">‐Xmx15m ‐Xms15m ‐XX:+DoEscapeAnalysis ‐XX:+PrintGC ‐XX:+EliminateAllocations<br></code></pre></td></tr></table></figure><p>  <img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232619185.png" alt="image-20230228232619185"></p><ul><li>使用如下参数都会发生大量GC</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">‐Xmx15m ‐Xms15m ‐XX:‐DoEscapeAnalysis ‐XX:+PrintGC ‐XX:+EliminateAllocations<br>‐Xmx15m ‐Xms15m ‐XX:+DoEscapeAnalysis ‐XX:+PrintGC ‐XX:‐EliminateAllocations<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232628497.png" alt="image-20230228232628497"></p><h2 id="对象在Eden区分配"><a href="#对象在Eden区分配" class="headerlink" title="对象在Eden区分配"></a><strong>对象在Eden区分配</strong></h2><ul><li><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p></li><li><p><strong>Eden与Survivor区默认8:1:1</strong> </p></li><li><p>过程</p><ul><li>大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉</li><li>剩余存活的对象会被挪到为空的那块survivor区</li><li>下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区</li><li>因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，<strong>让eden区尽量的大，survivor区够用即可</strong></li><li>JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy</li></ul></li></ul><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a><strong>大对象直接进入老年代</strong></h2><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象GC时，多次在survivor上来回复制而降低效率。</p><h2 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h2><ul><li><p>为每个对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。（默认 15 岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同)</p></li><li><p>对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置</p></li></ul><h2 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a><strong>对象动态年龄判断</strong></h2><ul><li><p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的 50%(XX:TargetSurvivorRatio可以指定)，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以直接进入老年代了， </p></li><li><p>例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。</p></li><li><p><strong>对象动态年</strong> <strong>龄判断机制一般是在minor gc之后触发的。</strong></p></li></ul><p><strong>为什么要这样呢</strong>？</p><p>这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。</p><h2 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a><strong>老年代空间分配担保机制</strong></h2><ul><li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，</li><li>如果条件成立的话，那么 Minor GC 可以确认是安全的。</li><li>如果不成立的话虚拟机会查看 “-XX:-HandlePromotionFailure” 的参数是否设置了(jdk1.8默认就设置了)，也就是是否允许担保失败，<ul><li>如果允许，就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，会触发full gc。</li><li>不允许，会触发Full GC</li></ul></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232645030.png" alt="image-20230228232645030"></p>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存参数设置</title>
    <link href="/JVM%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"/>
    <url>/JVM%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a><strong>JVM内存参数设置</strong></h1><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224116710.png" alt="image-20230228224116710"></p><h2 id="JVM参数设置格式"><a href="#JVM参数设置格式" class="headerlink" title="JVM参数设置格式"></a>JVM参数设置格式</h2><p>Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐eureka‐server.jar <br></code></pre></td></tr></table></figure><h2 id="元空间的JVM参数"><a href="#元空间的JVM参数" class="headerlink" title="元空间的JVM参数"></a>元空间的JVM参数</h2><ul><li><p>关于元空间的JVM参数有两个：-XX:MetaspaceSize&#x3D;N和 -XX:MaxMetaspaceSize&#x3D;N</p><ul><li><p><strong>-XX：MaxMetaspaceSize</strong>： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。 </p></li><li><p><strong>-XX：MetaspaceSize</strong>： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发full gc， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。（比如初始值是21M，full gc后，释放了20M，只剩1M，那么垃圾收集器就会将该值调成2M；相反，如果释放了1M，还剩20M，下次就会调整到40M）</p></li></ul></li><li><p>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生 了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大。</p></li><li><p>对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。常见的问题：项目jar包只有1G，但是启动了好久，就可能是因为由于元空间设置的太小，一直在触发full GC。</p></li></ul><h2 id="栈的JVM参数"><a href="#栈的JVM参数" class="headerlink" title="栈的JVM参数"></a>栈的JVM参数</h2><p>Xss设置越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多 </p><p><strong>StackOverflowError</strong>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackOverflowTest</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">redo</span><span class="hljs-params">()</span> </span>&#123;<br>        count++;<br>        redo();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redo();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            t.printStackTrace();<br>            System.out.println(count);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224131501.png" alt="image-20230228224131501"></p><p>调整-Xss参数：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224141154.png" alt="image-20230228224141154"></p><p>打印结果：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224149027.png" alt="image-20230228224149027"></p>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存模型</title>
    <link href="/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p>JVM内存模型总体来说分为五大块。分别是：程序计数器，虚拟机栈，本地方法栈，方法区以及java堆。</p><p><img src="https://img-blog.csdnimg.cn/20190428171713239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTIyNjQ3,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>   虚拟机栈（Java Virtual Machine Stacks）描述的是java方法（也就是字节码）执行的内存模型：每个方法在执行的时候都有一个栈帧,用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行就对应了一个栈帧在虚拟机栈中入栈到出栈的过程。</p><ul><li>线程私有。生命周期与线程相同。</li><li>在java虚拟机规范中，这个区域规定了两种异常状况。一是 Stack Overflow Error 异常，表示当前线程请求的栈深度大于虚拟机所允许的深度</li><li>二是Out Of Memory Error 如果所在虚拟机可以扩展，当它扩展时无法得到足够的内存，则会抛出该异常。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>   本地方法栈（Native Method Stack）与虚拟机栈发挥的作用是相似的，不同点在于虚拟机栈执行的是java方法服务，而本地方法栈是为虚拟机使用到的Native方法服务。有的虚拟机直接把虚拟机栈和本地方法栈合二为一，与虚拟机栈一样，本地方法栈也会抛出Stack Overflow Error和Out Of Memory Error异常。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>   程序计数器（Program Counter Register）是一块较小的内存空间，可看做当前线程所执行的字节码行号指令器，字节码解释器工作时就是通过改变这个计数器的值来选择下一条需要执行的字节码指令。</p><ul><li>线程私有。每个线程都需要一个独立的程序计数器，个线程之间计数器互不影响，独立存储</li><li>如果线程正在执行的是一个java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，则这个计数器为空。</li><li>此内存区域是唯一一个在java虚拟机中没有规定 Out Of Memory Error情况的区域。</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>java堆是java虚拟机所管理的内存中最大的一块。它用来存放对象实例和数组。</p><ul><li><p>线程共享。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p></li><li><p>java堆是垃圾收集器管理的主要区域，因此很多时候也被称作 “GC堆”（Garbage Collection Heap）。</p></li><li><p>java堆可以处于物理不连续的内存空间中，只要逻辑上连续即可。</p></li><li><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，则会抛出Out Of Memory Error 。</p></li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与java堆一样，是线程共享的区域，它里面存储已被虚拟机加载的类信息、静态变量、常量等数据。当方法区无法满足内存分配需求时，会抛出Out Of Memory Error 。运行时常量池是方法区的一部分，用来存放编译器生成的各种字面量和符号的引用。</p><blockquote><ul><li>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java命令--jmap工具</title>
    <link href="/java%E5%91%BD%E4%BB%A4--jmap%E5%B7%A5%E5%85%B7/"/>
    <url>/java%E5%91%BD%E4%BB%A4--jmap%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="Jmap"><a href="#Jmap" class="headerlink" title="Jmap"></a><strong>Jmap</strong></h1><p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p><p><strong>系统中内存飙升了，怎么办？</strong></p><p>使用jmap看看是否有大量类生成</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231003015.png" alt="image-20230228231003015"></p><h3 id="histo"><a href="#histo" class="headerlink" title="- histo"></a>- histo</h3><p>查看堆内存信息，实例个数以及占用内存大小 </p><ul><li>命令： <code> ~ jmap -histo 91656 &gt; ./log.txt</code></li><li>结果分析<ul><li>num：序号 </li><li>instances：实例数量 </li><li>bytes：占用空间大小 </li><li>class name：类名称   [C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]</li></ul></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231003015.png"></p><h3 id="‐dump"><a href="#‐dump" class="headerlink" title="‐dump"></a>‐dump</h3><p>生成Java虚拟机的堆转储快照dump文件</p><ul><li><p>命令 <code>jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</code></p></li><li><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  ~ jmap -dump:live,format=b,file=eureka.hprof <span class="hljs-number">3548</span><br>Dumping heap to /Users/panyurou/eureka.hprof ...<br></code></pre></td></tr></table></figure></li><li><p>也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来) </p><ul><li>-XX:+HeapDumpOnOutOfMemoryError </li><li>-XX:HeapDumpPath&#x3D;.&#x2F; （路径）</li></ul></li><li><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;<br>  <span class="hljs-comment">// JVM设置 :‐Xms10M ‐Xmx10M ‐XX:+PrintGCDetails</span><br>  <span class="hljs-comment">// ‐XX:+HeapDumpOnOutOfMemoryError ‐XX:HeapDumpPath=/Users/panyurou/jvm.hprof</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      list.add(<span class="hljs-keyword">new</span> User(i++));<br>      <span class="hljs-keyword">new</span> User(j--);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行配置：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231024765.png" alt="image-20230228231024765"></p><p>运行结果：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231032270.png" alt="image-20230228231032270"></p></li><li><p>用jvisualvm命令工具导入该dump文件分析</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231039259.png" alt="image-20230228231039259"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能调优</tag>
      
      <tag>java命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka的消息零丢失方案</title>
    <link href="/kafka%E7%9A%84%E6%B6%88%E6%81%AF%E9%9B%B6%E4%B8%A2%E5%A4%B1%E6%96%B9%E6%A1%88/"/>
    <url>/kafka%E7%9A%84%E6%B6%88%E6%81%AF%E9%9B%B6%E4%B8%A2%E5%A4%B1%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka如何保证消息的可靠性？"><a href="#Kafka如何保证消息的可靠性？" class="headerlink" title="Kafka如何保证消息的可靠性？"></a>Kafka如何保证消息的可靠性？</h1><h2 id="哪些环节会有丢消息的可能？"><a href="#哪些环节会有丢消息的可能？" class="headerlink" title="哪些环节会有丢消息的可能？"></a>哪些环节会有丢消息的可能？</h2><p><a href="https://pyr9.github.io/RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E9%9B%B6%E4%B8%A2%E5%A4%B1%E6%96%B9%E6%A1%88/#%E5%93%AA%E4%BA%9B%E7%8E%AF%E8%8A%82%E4%BC%9A%E6%9C%89%E4%B8%A2%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E8%83%BD%EF%BC%9F">RabbitMQ的消息零丢失方案 - 楼上有只喵 (pyr9.github.io)</a></p><h2 id="Kafka怎么保证消息可靠性"><a href="#Kafka怎么保证消息可靠性" class="headerlink" title="Kafka怎么保证消息可靠性?"></a>Kafka怎么保证消息可靠性?</h2><h3 id="1-生产者保证消息正确发送到Kafka"><a href="#1-生产者保证消息正确发送到Kafka" class="headerlink" title="1. 生产者保证消息正确发送到Kafka?"></a>1. 生产者保证消息正确发送到Kafka?</h3><p>Kafka通过配置request.required.acks属性来确认消息的生产：</p><ul><li>0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的，存在丢消息：数据还没写入leader，leader就挂了</li><li>1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。</li><li>-1或all producer需要等待ISR中的所有副本都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有副本都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。这种性能不高，一般是金融级别或者和钱打交道的时候采用。</li></ul><p><strong>避免消息丢失就可以将ack设置成-1或all</strong></p><blockquote><p>ISR**(InSyncRepli)** ：与leader保持一定同步程度的副本们（包括leader）。是replicas的一个子集</p></blockquote><h3 id="2-Kafka消息备份和同步"><a href="#2-Kafka消息备份和同步" class="headerlink" title="2. Kafka消息备份和同步"></a>2. Kafka消息备份和同步</h3><ul><li>afka通过分区的多副本策略来解决消息的备份问题。在kafka中，实现副本的目的就是冗余备份，且仅仅是冗余备份，所有的读写请求都是由leader副本进行处理的。follower副本仅有一个功能，那就是从leader副本拉取消息，尽量让自己跟leader副本的内容一致。</li><li>给包含重要消息的队列建立一个远端备份。</li></ul><h3 id="3-Kafka消息存盘不丢消息"><a href="#3-Kafka消息存盘不丢消息" class="headerlink" title="3. Kafka消息存盘不丢消息?"></a>3. Kafka消息存盘不丢消息?</h3><p>Kafka提供消息持久化，所有数据都会立即被写入文件系统的持久化日志中。kafka一般不会删除消息，不管这些消息有没有被消费。只会根据配置的日志保留时间(log.retention.hours)确认消息多久被删除，默认保留最近一周的日志消息。</p><h3 id="4-Kafka消费者不丢失消息"><a href="#4-Kafka消费者不丢失消息" class="headerlink" title="4. Kafka消费者不丢失消息?"></a>4. <strong>Kafka消费者不丢失消息</strong>?</h3><ul><li>RabbitMQ在消费消息时可以指定是自动应答，还是手动应答。将Kafka的应答模式设定为手动应答可以提高消息消费的可靠性。</li><li>设置了手动确认，则需要在业务处理成成功后，手动调用<code>consumer.commitSync()</code></li></ul><p><strong>最后，任何用户态的应用程序都无法保证绝对的数据安全，所以，备份与恢复的方案也需要考虑到。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
      <tag>消息可靠性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的消息零丢失方案</title>
    <link href="/RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <url>/RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ如何保证消息的可靠性？"><a href="#RabbitMQ如何保证消息的可靠性？" class="headerlink" title="RabbitMQ如何保证消息的可靠性？"></a>RabbitMQ如何保证消息的可靠性？</h1><h2 id="哪些环节会有丢消息的可能？"><a href="#哪些环节会有丢消息的可能？" class="headerlink" title="哪些环节会有丢消息的可能？"></a>哪些环节会有丢消息的可能？</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228233457541.png" alt="image-20230228233457541"></p><h3 id="普通消息处理流程"><a href="#普通消息处理流程" class="headerlink" title="普通消息处理流程"></a>普通消息处理流程</h3><ol><li>消息生成者发送消息</li><li>MQ收到消息，将消息进行存储（持久化到硬盘）。</li><li>返回ACK给生产者</li><li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li><li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤</li><li>MQ删除消息</li></ol><h3 id="丢消息的场景"><a href="#丢消息的场景" class="headerlink" title="丢消息的场景"></a>丢消息的场景</h3><ul><li>1，2，4三个场景，都是跨网络的，而跨网络就肯定会有丢消息的可能。</li><li>关于3这个环节，通常MQ存盘时都会先写入操作系统的缓存page cache中，然后再由操作系统异步的将消息写入硬盘。这个中间有个时间差，就可能会造成消息丢失。如果服务挂了，缓存中还没有来得及写入硬盘的消息就会丢失。这也是任何用户态的应用程序无法避免的。</li><li>对于任何MQ产品，都应该从这四个方面来考虑数据的安全性。那我们看看用RabbitMQ时要如何解决这个问题。</li></ul><h2 id="RabbitMQ消息零丢失方案"><a href="#RabbitMQ消息零丢失方案" class="headerlink" title="RabbitMQ消息零丢失方案?"></a>RabbitMQ消息零丢失方案?</h2><h3 id="1-生产者保证消息正确发送到RibbitMQ"><a href="#1-生产者保证消息正确发送到RibbitMQ" class="headerlink" title="1. 生产者保证消息正确发送到RibbitMQ?"></a>1. 生产者保证消息正确发送到RibbitMQ?</h3><ul><li><p><strong>方案一：</strong>可以使用生产者确认机制。</p><p>通过多次确认的方式，保证生产者的消息能够正确的发送到RabbitMQ中。RabbitMQ的生产者确认机制分为同步确认和异步确认。</p><ul><li><p>同步确认主要是通过在生产者端使用Channel.waitForConfirmsOrDie()指定一个等待确认的完成时间。</p></li><li><p>异步确认机制则是通过在生产者端注入两个回调确认函数。第一个函数是在生产者发送消息时调用，第二个函数则是生产者收到Broker的消息确认请求时调用。两个函数需要通过sequenceNumber自行完成消息的前后对应。sequenceNumber的生成方式需要通过channel的序列获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.addConfirmListener(ConfirmCallback var1,ConfirmCallback var2)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>方案二：</strong>手动事务</p><ul><li><p>手动事务机制主要有几个关键的方法： channel.txSelect() 开启事务；channel.txCommit() 提交事务； channel.txRollback() 回滚事务。用这几个方法来进行事务管理。比如在创建订单后开启事务，减库存成功后提交事务，失败时回滚。</p></li><li><p>这种方式需要手动控制事务逻辑，并且手动事务会对channel产生阻塞，造成吞吐量下降</p></li></ul></li></ul><h3 id="2-RabbitMQ-主从消息同步时不丢消息"><a href="#2-RabbitMQ-主从消息同步时不丢消息" class="headerlink" title="2. RabbitMQ 主从消息同步时不丢消息?"></a>2. <strong>RabbitMQ 主从消息同步时不丢消息</strong>?</h3><ul><li>不使用普通集群模式， 使用镜像集群模式</li><li>给包含重要消息的队列建立一个远端备份。</li></ul><blockquote><ul><li><p>普通集群模式</p><ul><li><strong>queue的消息</strong>，只会放在<strong>一个rabbtimq实例</strong>上。<strong>每个实例都同步queue的结构和queue消息的真正位置</strong>。</li><li>消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。</li><li>这种集群模式的消息可靠性不是很高。因为如果其中有个节点服务宕机了，那这个节点上的数据就无法消费了，需要等到这个节点服务恢复后才能消费。</li></ul></li><li><p>镜像集群模式</p><ul><li><p>这种模式是在普通集群模式基础上的一种增强方案，这也就是RabbitMQ的官方HA高可用方案。</p></li><li><p>这种模式会在镜像节点中间主动进行消息同步，而不是在客户端拉取消息时临时同步。这种模式的消息可靠性更高，因为每个节点上都存着全量的消息。</p></li><li><p>他的弊端也是明显的，集群内部的网络带宽会被这种同步通讯大量的消耗，进而降低整个集群的性能。这种模式下，队列数量最好不要过多。</p></li></ul></li></ul></blockquote><h3 id="3-RabbitMQ消息存盘不丢消息"><a href="#3-RabbitMQ消息存盘不丢消息" class="headerlink" title="3. RabbitMQ消息存盘不丢消息?"></a>3. RabbitMQ消息存盘不丢消息?</h3><p>对于Classic经典队列，直接将队列声明成为持久化队列即可。</p><p>而新增的Quorum（[ˈkwɔrəm] 仲裁）队列和Stream队列，都是明显的持久化队列，能更好的保证服务端消息不会丢失。</p><blockquote><p>Quorum队列实现了持久化，多备份的FIFO队列，主要就是针对RabbitMQ的镜像模式设计的。大部分功能都是在Classic队列基础上做减法，比如不支持是非持久化的内存队列。某些功能（例如有害消息处理）是特定于仲裁队列的。</p><p>Stream队列是RabbitMQ自3.9.0版本开始引入的一种新的数据队列类型，更适合于消费者多，读消息非常频繁的场景。</p></blockquote><blockquote><p>毒消息是指消息一直不能被消费者正常消费(可能是由于消费者失败或者消费逻辑有问题等)，就会导致消息不断的重新入队，这样这些消息就成为了毒消息。这些读消息应该有保障机制进行标记并及时删除。Quorum队列会持续跟踪消息的失败投递尝试次数，并记录在”x-delivery-count”这样一个头部参数中。然后，就可以通过设置 Delivery limit参数来定制一个毒消息的删除策略。当消息的重复投递次数超过了Delivery limit参数阈值时，RabbitMQ就会删除这些毒消息。当然，如果配置了死信队列的话，就会进入对应的死信队列。</p></blockquote><h3 id="4-RabbitMQ消费者不丢失消息"><a href="#4-RabbitMQ消费者不丢失消息" class="headerlink" title="4. RabbitMQ消费者不丢失消息?"></a>4. <strong>RabbitMQ消费者不丢失消息</strong>?</h3><ul><li><p>RabbitMQ在消费消息时可以指定是自动应答，还是手动应答。将RabbitMQ的应答模式设定为手动应答可以提高消息消费的可靠性。</p></li><li><p>设置了手动确认，则需要在业务处理成成功后，手动调用<code>channer.basicAck()</code>,如果出现异常则调用<code>channer.basicNAck()</code>,设置消息是重新返回队列，还是直接丢掉。</p></li></ul><p><strong>最后，任何用户态的应用程序都无法保证绝对的数据安全，所以，备份与恢复的方案也需要考虑到。</strong></p><h2 id="Consumer-Ack-消费端收到消息后的确认方式"><a href="#Consumer-Ack-消费端收到消息后的确认方式" class="headerlink" title="Consumer Ack 消费端收到消息后的确认方式"></a>Consumer Ack 消费端收到消息后的确认方式</h2><ol><li><p>有三种确认方式</p><ul><li>自动确认 acknowledge &#x3D; “none”。 消息一旦到达consumer就会被确认，并将对应的message 从消息缓存中移除，实际场景中，很可能消息被收到，但是处理业务时异常，这种确认机制下，消息就会丢失。</li><li>手动确认acknowledge &#x3D; “manual”。设置了手动确认，则需要在业务处理成成功后，手动调用<code>channer.basicAck()</code>,如果出现异常则调用<code>channer.basicNAck()</code>,设置消息是重新返回队列，还是直接丢掉。</li><li>根据异常情况确认 acknowledge &#x3D; “auto”</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
      <tag>消息可靠性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的高级特性</title>
    <link href="/RabbitMQ%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <url>/RabbitMQ%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ的高级特性"><a href="#RabbitMQ的高级特性" class="headerlink" title="RabbitMQ的高级特性"></a>RabbitMQ的高级特性</h1><h2 id="如何保证消息的顺序？"><a href="#如何保证消息的顺序？" class="headerlink" title="如何保证消息的顺序？"></a><strong>如何保证消息的顺序？</strong></h2><p>消息的顺序是指的是，一个组内消息的顺序，而不是整个mq里的消息顺序。比如一个下单过程需要完成扣款，减库存，通知快递发货，这一组消息的顺序不能乱。</p><ul><li><p>发送端：一组有序消息，只发到一个队列中，利用队列的FIFO特性保证消息在发送时顺序不会乱。</p><p>如果发送端配置了重试机制，就可能出现发送方发送时是1，2，3，但1发送失败，重试发送1，这样收到的消息就是2，3，1。这种情况下，需要同步的去发消息，只有第一个消息发送成功了，再去发送2，3。</p></li><li><p>消费者端：进行消费时，保证只有一个消费者，同时指定prefetch属性为1，即每次RabbitMQ都只往消费端推送一个消息。这样可以保证消费时的有序。</p></li></ul><p><strong>显然，这是以极度消耗性能作为代价的，在实际适应过程中，应该尽量避免这种场景。</strong></p><h2 id="消息积压和解决"><a href="#消息积压和解决" class="headerlink" title="消息积压和解决"></a>消息积压和解决</h2><h3 id="1-发送方发送流量太大"><a href="#1-发送方发送流量太大" class="headerlink" title="1.发送方发送流量太大"></a>1.发送方发送流量太大</h3><ul><li>降低消息生产的速度。生产者端产生消息的速度通常是跟业务息息相关的，一般情况下不太好直接优化。但是可以采用批量发送消息的方式，降低IO频率。</li></ul><h3 id="2-消费者能力不足"><a href="#2-消费者能力不足" class="headerlink" title="2. 消费者能力不足"></a>2. 消费者能力不足</h3><ul><li><p>修改消费端程序，写一个临时的分发数据的 consumer 程序，将收到的消息快速转发给临时建立好原先 10 倍的 queue， 接着临时征用 10 倍的机器来部署 consumer，每一个 consumer 消费一个临时 queue 的数据。</p></li><li><p>上线专门的消费者组。专门用来将消息快速转录。保存到数据库或者Redis，然后再慢慢进行处理。</p></li><li><p>对于单个消费者端，可以通过配置提升消费者端的吞吐量。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># 单次推送消息数量<br>spring.rabbitmq.listener.simple.prefetch=<span class="hljs-number">1</span><br># 消费者的消费线程数量<br>spring.rabbitmq.listener.simple.concurrency<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-消费者有bug或者宕机了"><a href="#3-消费者有bug或者宕机了" class="headerlink" title="3.消费者有bug或者宕机了"></a>3.消费者有bug或者宕机了</h3><ul><li>将消费不成功的消息转发到其他队列里，类似死信队列，后面再慢慢分析。kafka没有死信队列需要自己实现。</li></ul><h4 id="其他解决方式"><a href="#其他解决方式" class="headerlink" title="其他解决方式"></a>其他解决方式</h4><ul><li>RabbitMQ服务端：尝试使用新推出的Quorum以及Stream队列，也能很好的提高服务端的消息堆积能力。但是这两种队列的稳定性和周边生态都还不够完善。</li><li>RabbitMQ一直以来，就是对于消息堆积问题的处理不好。当RabbitMQ中有大量消息堆积时，整体性能会严重下降。不行就换kafka</li></ul><h2 id="MQ中消息失效"><a href="#MQ中消息失效" class="headerlink" title="MQ中消息失效"></a>MQ中消息失效</h2><p>RabbtiMQ 是可以设置过期时间 的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。</p><p>解决：批量重导。就是大量积压的时候，我们当时就 直接丢弃数据了，然后等过了高峰期以后。将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去</p><h2 id="消息的幂等性"><a href="#消息的幂等性" class="headerlink" title="消息的幂等性"></a>消息的幂等性</h2><p>造成消息重复的根本原因是：网络不可达。 </p><p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收 到两条一样的消息，应该怎样处理？ </p><p>方案一： 利用一张日志表来记录已经处理成功的消息的 ID，如 果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。 </p><p>方案二：消息生成唯一的id，存储在redis中。</p><p>方案二：</p><ul><li><p>第一次 执行更新语句的是一样，version &#x3D;1 </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">update account <span class="hljs-keyword">set</span> price = price <span class="hljs-number">-100</span>, <span class="hljs-built_in">version</span> = <span class="hljs-built_in">version</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">version</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>第二次, 执行更新语句的是一样，version 已经变成了2，此时找<code>where version = 1 </code> 就无法找到</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">update account <span class="hljs-keyword">set</span> price = price <span class="hljs-number">-100</span>, <span class="hljs-built_in">version</span> = <span class="hljs-built_in">version</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">version</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><ul><li>在<a href="rabbit:listener-container">rabbit:listener-container</a> 中配置<code>prefetch</code>属性设置消费端一次拉取多少消息</li><li>消费端的确认模式需要是手动确认</li></ul><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><ol><li>TTL全称：time to live 消息存活时间或消息过期时间</li><li>消息达到了存活时间后，如果还没被消费，会被自动移除</li><li>RabbitMQ可以对消息设置过期时间，也可以对整个队列设置过期时间。</li></ol><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><ul><li><p>当消息成为死信后，可以被重新发送到一个交换机，这个交换机就是死信交换机，它绑定的队列就是死信队列</p></li><li><p>成为死信的条件：</p><ul><li>消息达到了存活时间，还没有被消费。</li><li>消费者拒收消息，并且不重回队列。  </li><li>队列到达了指定的长度限制</li></ul></li><li><p>代码</p><ul><li><p>producer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"># 指定了消息的过期时间为10s <br>AMQP.BasicProperties properties = <span class="hljs-keyword">new</span> AMQP.BasicProperties.Builder()<br>                .deliveryMode(<span class="hljs-number">2</span>)<br>                .contentEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>)<br>                .expiration(<span class="hljs-string">&quot;10000&quot;</span>)<br>                .build();<br>  channel.basicPublish(exchange, routingKey, <span class="hljs-keyword">true</span>, properties, msg.getBytes());<br></code></pre></td></tr></table></figure></li><li><p>consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String exchangeName = <span class="hljs-string">&quot;test_dlx_exchange&quot;</span>;<br>channel.exchangeDeclare(exchangeName, <span class="hljs-string">&quot;topic&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br># 在队列加上一个参数，指定死信队列<br>Map&lt;String, Object&gt; agruments = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br>agruments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, <span class="hljs-string">&quot;dlx.exchange&quot;</span>);<br>channel.queueDeclare(queueName, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, agruments);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列，消息进入队列后，不会立即被消费，而是等到一定的时间，才会被消费。</p><p>使用场景：</p><ol><li>用户下单后，30分钟未支付，取消订单，回滚库存</li><li>新用户注册7天后，发送短信问候</li></ol><blockquote><p>当然上面的场景也可以用定时器实现</p></blockquote><p>rabbitmq现在不支持延迟队列，延迟队列的实现需要借助TTL和死信队列。具体实现流程：</p><ul><li>用户下单，把消息发送到Queue1中，不设置Consumer1，设置Queue1队列里的消息存活时间为30分钟，等待30分钟后，消息成为死信。</li><li>死信的消息发送到Queue2，添加Consumer2监听Queue2</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228233554129.png" alt="image-20230228233554129"></p><h4 id="死信队列和延时队列的区别"><a href="#死信队列和延时队列的区别" class="headerlink" title="死信队列和延时队列的区别"></a>死信队列和延时队列的区别</h4><ul><li>死信队列，监听的是Queue1,成为死信的消息会被丢到DLX中，或者不处理自己清理掉</li><li>延迟队列，监听的是死信队列</li></ul>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitMQ入门</title>
    <link href="/rabbitMQ%E5%85%A5%E9%97%A8/"/>
    <url>/rabbitMQ%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MQ介绍"><a href="#MQ介绍" class="headerlink" title="MQ介绍"></a>MQ介绍</h1><h2 id="什么是MQ？"><a href="#什么是MQ？" class="headerlink" title="什么是MQ？"></a>什么是MQ？</h2><ul><li>MQ：MessageQueue，消息队列。 队列，是一种FIFO 先进先出的数据结构。</li><li>消息由生产者发送到MQ进行排队，然后按原来的顺序交由消息的消费者进行处理。</li><li>QQ和微信就是典型的MQ。</li></ul><h2 id="MQ的的优点："><a href="#MQ的的优点：" class="headerlink" title="MQ的的优点："></a>MQ的的优点：</h2><ul><li><p><strong>异步</strong>：相比于传统的串行、并行执行，可以提高吞吐量。 比如：发快递的时候，我们不需要等待用户接收到快递，而是把快递放进菜鸟驿站，发消息后，离开，用户闲暇时去取快递。</p></li><li><p><strong>解偶</strong>：服务之间进行解耦，才可以减少服务之间的影响。提高系统整体的稳定性以及可扩展性。比如用户下单的场景，用户下单后，订单系统需要通知库存系统减库存，传统的模式，当库存系统无法访问时，用户调用接口失败，从而导致下单失败。但引入MQ后，用户下单后，将下单消息写入消息队列，然后返回用户下单成功，库存系统去订阅下单的消息，去拉取下单信息，从而进行减库存，这时即使库存系统不可用，依旧可以下单成功，实现了订单系统和库存系统的解耦。</p></li><li><p><strong>削峰</strong>：可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请 求。 比如双十一，请求量比较大的时候，我们可以把请求放到MQ里，下游服务再慢慢消费。</p></li></ul><h2 id="MQ的缺点"><a href="#MQ的缺点" class="headerlink" title="MQ的缺点"></a><strong>MQ的缺点</strong></h2><ul><li>系统可用性降低。系统引入的外部依赖增多，系统的稳定性就会变差。一旦MQ宕机，对业务会产生影响。这就需要考虑如何保证MQ的高可用</li><li>系统复杂度提高。引入MQ后系统的复杂度会大大提高。以前服务之间可以进行同步的服务调用，引入MQ后，会变为异步调用，数据的链路就会变得更复杂。并且还会带来其他一些问题。比如：如何保证消费不会丢失？不会被重复调用？怎么保证消息的顺序性等问题</li><li>消息一致性问题。A系统处理完业务，通过MQ发送消息给B、C系统进行后续的业务处理。如果B系统处理成功，C系统处理失败怎么办？这就需要考虑如何保证消息数据处理的一致性。</li></ul><h1 id="什么是RabbitMQ？"><a href="#什么是RabbitMQ？" class="headerlink" title="什么是RabbitMQ？"></a><strong>什么是RabbitMQ？</strong></h1><p>RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件</p><h1 id="为什么选择rabbitmq？"><a href="#为什么选择rabbitmq？" class="headerlink" title="为什么选择rabbitmq？"></a>为什么选择rabbitmq？</h1><ul><li>支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。 </li><li>支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。</li><li>开 源的，比较稳定的支持，活跃度也高</li></ul><blockquote><p>缺点： 确实 erlang 语言阻止了大量的 Java 工程师 去深入研究和掌控它，对公司而言，几乎处于不可控的状态，</p></blockquote><h1 id="RabbitMQ的基本概念"><a href="#RabbitMQ的基本概念" class="headerlink" title="RabbitMQ的基本概念"></a>RabbitMQ的基本概念</h1><ul><li>connection： 客户端与RabbitMQ进行交互，首先就需要建立一个TPC连接，这个连接就是Connection</li></ul><ul><li><p>Broker： 简单来说就是消息队列服务器实体 </p></li><li><p>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 </p></li><li><p>Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 </p></li><li><p>Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 </p></li><li><p>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 </p></li><li><p>VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部 均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的 权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，类似mysql中的database创建一个table 需要指明用哪个数据库。</p></li></ul><h1 id="channel信道"><a href="#channel信道" class="headerlink" title="channel信道"></a>channel信道</h1><ul><li>信道是生产者&#x2F;消费者与rbabitmq通信的渠道。生产者publish或者消费者consume一个队列都是通过信道完成的。</li><li>多线程时，rabbitMQ在一条tcp上建立多个信道来处理多线程。</li><li>每个信道在rabbitmq上有唯一的id,保证一个信道对应一个线程使用。</li></ul><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><ul><li><p>交换机就类似是路由器，他会根据路由键（在rabbitMQ就是routing key），将消息分发到相应的队列上去。</p></li><li><p>交换机的四种类型</p><ul><li>fanout: 把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。(1:N)</li><li>Direct :   把消息路由到BindingKey和RoutingKey完全匹配的队列中。(1:1)</li><li>topic: 可以根据模糊匹配，可以将多个消息路由到同一个队列，比如一个队列的routing_key是’’.test”那么凡是到达路由器的消息的后缀为“.test”，都会进到这个队列。<ul><li>“* ”只能是一个单词，如“”aa.test“</li><li>“#”可以是&gt;&#x3D; 0的单词，如“”test“,”aa.bb.test”</li></ul></li><li><code>headers</code>:不依赖路由键匹配规则路由消息。是根据发送消息内容中的<code>headers</code>属性进行匹配。性能差，基本用不到。</li></ul></li></ul><h1 id="交换机-1"><a href="#交换机-1" class="headerlink" title="交换机"></a>交换机</h1><ul><li><p>交换机就类似是路由器，他会根据路由键（在rabbitMQ就是routing key），将消息分发到相应的队列上去。</p></li><li><p>交换机的四种类型</p><ul><li>fanout: 把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。(1:N)</li><li>Direct :   把消息路由到BindingKey和RoutingKey完全匹配的队列中。(1:1)</li><li>topic: 可以根据模糊匹配，可以将多个消息路由到同一个队列，比如一个队列的routing_key是’’.test”那么凡是到达路由器的消息的后缀为“.test”，都会进到这个队列。<ul><li>“* ”只能是一个单词，如“”aa.test“</li><li>“#”可以是&gt;&#x3D; 0的单词，如“”test“,”aa.bb.test”</li></ul></li><li><code>headers</code>:不依赖路由键匹配规则路由消息。是根据发送消息内容中的<code>headers</code>属性进行匹配。性能差，基本用不到。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制的深度解析</title>
    <link href="/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <url>/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="类加载运行全过程"><a href="#类加载运行全过程" class="headerlink" title="类加载运行全过程"></a>类加载运行全过程</h2><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过<strong>类加载器</strong>把主类加载到 JVM。</p><p>有如下几步： <strong>加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt;</strong> 使用 &gt;&gt; 卸载 </p><ul><li>加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个<strong>代表这个类的</strong> <strong>.Class对象</strong>，作为这个类的各种数据的访问入口 。</li><li>验证：校验字节码文件的正确性 </li><li>准备：给类的静态变量分配内存，并赋予默认值 </li><li>解析：将<strong>符号引用</strong>替换为直接引用（地址引用）</li><li><strong>初始化</strong>：对类的静态变量初始化为指定的值，执行静态代码块</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h2><ul><li>bootstrap ClassLoader引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等 </li><li>ExtClassLoader 扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 类包</li><li>AppClassLoader 应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</li><li>自定义加载器：负责加载用户自定义路径下的类包</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a><strong>双亲委派机制</strong></h2><p>加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类</p>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类加载机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud知识点整理</title>
    <link href="/springCloud%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/springCloud%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-为什么会出现SpringCloud"><a href="#1-为什么会出现SpringCloud" class="headerlink" title="1. 为什么会出现SpringCloud?"></a>1. 为什么会出现SpringCloud?</h2><p>单体架构的优缺点</p><p>优点：</p><ul><li>部署简单：只有一个包</li><li>技术单一：同一个架构来说，基本上是一个一种技术，类似springboot + java</li><li>用人成本低：因为只需要一种技术</li></ul><p>缺点：</p><ul><li>代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。</li><li>经常需要解决冲突，开发效率低：开发人员同时维护同一套代码，很难避免代码冲突。开发过程中会伴随解决冲突，严重影响开发效率。</li><li>排查解决问题成本高：线上发现了bug，可能bu g很简单，但是由于只有一套代码，需要编译打包上线，成本很高。</li><li>监控很难：很多功能点，杂在一个系统中。</li></ul><p>由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题。近些年来，微服务架构逐渐取代了单体架构，且这种趋势将会越来越流行。</p><h2 id="2-什么是Spring-Cloud？"><a href="#2-什么是Spring-Cloud？" class="headerlink" title="2. 什么是Spring Cloud？"></a>2. <strong>什么是Spring Cloud</strong>？</h2><p>SpringCloud是基于SpringBoot的一整套实现微服务的<strong>框架</strong>。它提供了微服务开发所需的服务注册与发现,服务调用,负载均衡,API网关</p><p>配置管理,熔断器</p><p><strong>springCloud的优缺点</strong></p><p>优点：</p><ul><li>产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善 。</li><li>组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例 如、配置管理、服务发现、断路器、微服务网关等； </li><li>Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案</li><li>服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率</li><li>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发 </li><li>微服务可以是跨平台的，可以用任何一种语言开发</li></ul><p>缺点：</p><ul><li>微服务过多，治理成本高，不利于维护系统 </li><li>分布式系统开发的成本高（容错，分布式事务等）对团队挑战大</li></ul><h2 id="3-springboot-和springCloud-的区别和联系"><a href="#3-springboot-和springCloud-的区别和联系" class="headerlink" title="3. springboot 和springCloud 的区别和联系"></a>3. springboot 和springCloud 的区别和联系</h2><ul><li>springCloud 是基于Springboot 构建的，他里面的每个子项目就是一个springboot项目。SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不 开SpringBoot ，属于依赖的关系 </li><li>SpringBoot专注于快速方便的开发单个个体微服务。 SpringCloud是关注全局的微服务协调整理治理框架，为微服务架构提供了非常完整的支持。例如、配置管理、服务发现、断路器、微服务网关等</li></ul><h2 id="4-Spring-Cloud-Netflix核心组件？"><a href="#4-Spring-Cloud-Netflix核心组件？" class="headerlink" title="4. Spring Cloud Netflix核心组件？"></a>4. <strong>Spring Cloud Netflix</strong>核心组件？</h2><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等 核心组件。</p><ul><li><p>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制； </p></li><li><p>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略； </p></li><li><p>Feign：基于Ribbon和Hystrix的声明式服务调用组件； </p></li><li><p>Zuul：API网关组件，对请求提供路由及过滤功能。</p></li><li><p>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了 容错能力； </p></li><li><p>Bus:</p></li></ul><h1 id="5-微服务架构组成"><a href="#5-微服务架构组成" class="headerlink" title="5. 微服务架构组成"></a>5. 微服务架构组成</h1><h2 id="5-1-服务注册与发现"><a href="#5-1-服务注册与发现" class="headerlink" title="5.1 服务注册与发现"></a>5.1 服务注册与发现</h2><h3 id="1-服务注册和发现是什么"><a href="#1-服务注册和发现是什么" class="headerlink" title="1. 服务注册和发现是什么"></a>1. 服务注册和发现是什么</h3><ul><li>服务注册 ，就是将提供某个服务的模块信息 (通常是这个服务的ip和端口)注册到1个公共的组件上去。</li><li>服务发现 ，就是新<strong>注册的这个服务模块能够及时的被其他调用者发现。</strong></li></ul><h3 id="2-什么是注册中心"><a href="#2-什么是注册中心" class="headerlink" title="2. 什么是注册中心"></a>2. 什么是注册中心</h3><p>注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。</p><h3 id="3-注册中心的实现方式"><a href="#3-注册中心的实现方式" class="headerlink" title="3 注册中心的实现方式"></a>3 注册中心的实现方式</h3><ul><li>mysql: 将服务和服务地址的映射关系insert到数据库中，调用服务前去select。维护 一个心跳，定期去感应下节点状态是否正常，比如ping一下端口，如果不正常，修改此时节点状态</li><li>zookeeper：在这个父节点上创建临时子节点，用来存储服务和服务地址的映射关系，对应生成注册表。调用服务前去节点里查询节点数据，zookeeper有监听通知机制，我们对某个节点进行监听，当这个节点被删除时，监听方会感知到重新拉取服务列表。</li><li>Eureka</li></ul><h3 id="4-Spring-Cloud-如何实现服务注册和发现？"><a href="#4-Spring-Cloud-如何实现服务注册和发现？" class="headerlink" title="4. Spring Cloud 如何实现服务注册和发现？"></a>4. Spring Cloud 如何实<strong>现服务注册和发现？</strong></h3><p>由于所有服务都在 Eureka 服务器上注册并 通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><p><a href="https://pyr9.github.io/2022/07/21/CAP%E5%8E%9F%E5%88%99%E4%BB%A5%E5%8F%8Aeureka%E5%92%8Czookeeper%E7%9A%84%E5%AF%B9%E6%AF%94/">CAP原则以及eureka和zookeeper的对比 - 楼上有只喵 (pyr9.github.io)</a></p><h2 id="5-2-服务调用"><a href="#5-2-服务调用" class="headerlink" title="5.2 服务调用"></a>5.2 服务调用</h2><h2 id="5-3-负载均衡"><a href="#5-3-负载均衡" class="headerlink" title="5.3 负载均衡"></a>5.3 负载均衡</h2><h2 id="5-4-API网关"><a href="#5-4-API网关" class="headerlink" title="5.4 API网关"></a>5.4 API网关</h2><h3 id="Spring-Cloud-Gateway-和zuul"><a href="#Spring-Cloud-Gateway-和zuul" class="headerlink" title="Spring Cloud Gateway 和zuul"></a>Spring Cloud Gateway 和zuul</h3><p>相同点：二者都是可以用来实现API网关</p><p>不同点：</p><ul><li>开发团队不同。<ul><li>zuul是netfix开发的</li><li>spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，用来取代Zuul网关。</li></ul></li><li>zuul性能相对gateway较差。<ul><li>Zuul1.* 是一个极具阻塞IO的API GateWay，每次IO操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成。所以zuul的性能较差。zuu2理念更先进，基于netty非阻塞，但是springCloud还没有整合。</li><li>Spring Cloud Gateway 是基于 WebFlux 框架实现的，而 WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty。高并发和非阻塞通信就非常有优势</li><li>Spring Cloud Gateway还支持webSocket，并且与spring有很好的集成</li></ul></li></ul><blockquote><p>WebSocket 协议,大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。</p></blockquote><p> 多方面比较，gateWay是很理想的网关选择。</p><h2 id="5-5-配置管理"><a href="#5-5-配置管理" class="headerlink" title="5.5 配置管理"></a>5.5 配置管理</h2><h3 id="1-springCloud-config-是什么？"><a href="#1-springCloud-config-是什么？" class="headerlink" title="1 springCloud config 是什么？"></a>1 springCloud config 是什么？</h3><ul><li>Spring Cloud Config 是由 Spring Cloud 团队开发的项目，它可以为微服务架构中各个微服务提供集中化的外部配置支持。</li><li>Spring Cloud Config 可以将各个微服务的配置文件集中存储在一个外部的存储仓库或系统（例如 Git 、SVN 等）中，对配置的统一管理，以支持各个微服务的运行。</li><li>Spring Cloud Config 包含以下两个部分：<ul><li>Config Server：也被称为分布式配置中心，它是一个独立运行的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密信息和解密信息的访问接口。</li><li>Config Client：指的是微服务架构中的各个微服务，它们通过 Config Server 对配置进行管理，并从 Config Sever 中获取和加载配置信息。</li></ul></li></ul><h2 id="5-6-熔断器"><a href="#5-6-熔断器" class="headerlink" title="5.6 熔断器"></a>5.6 熔断器</h2><h3 id="1-什么是服务熔断？"><a href="#1-什么是服务熔断？" class="headerlink" title="1. 什么是服务熔断？"></a>1. 什么是服务熔断？</h3><ul><li>服务熔断就是对服务的调用执行熔断，对于后续的请求，不再调用目标服务，而是直接返回一个合理的信息，比如说请求量太大，返回一个”此时服务过载”，从而可以快速释放资源</li><li>保护系统</li></ul><h3 id="2-为什么会有这种熔断机制的出现"><a href="#2-为什么会有这种熔断机制的出现" class="headerlink" title="2 为什么会有这种熔断机制的出现?"></a>2 为什么会有这种熔断机制的出现?</h3><p>在微服务相互调用的时候可能会出现服务调用发生异常或调用超时,多此请求造成服务积压导致服务无法使用后接着级联导致调用此服务的消费者也出现异常或调用超时,最后导致整个系统的全部崩溃.这就是雪崩效应.</p><blockquote><p><a href="https://so.csdn.net/so/search?q=%E7%BA%A7%E8%81%94&spm=1001.2101.3001.7020">级联</a>(失败)雪崩：一个服务失败，导致整条链路的服务都失败的情形。</p></blockquote><h3 id="3-熔断器的功能"><a href="#3-熔断器的功能" class="headerlink" title="3. 熔断器的功能"></a>3. 熔断器的功能</h3><ul><li>异常处理。需要可以根据异常的类型，去处理异常</li><li>日志记录。记录失败的数目，才可以开启熔断</li><li>测试失败的操作。周期性的检查来测试服务是否健康。</li><li>手动复位。管理员可以强行关闭断路器，重置故障的计数器</li><li>并发。断路器可以支持大并发量</li><li>加速断路：检测出问题的速度要快，及时响应</li><li>重试失败请求：在服务可用时，可以安排重试</li></ul><h3 id="4-熔断和降级的区别"><a href="#4-熔断和降级的区别" class="headerlink" title="4 熔断和降级的区别"></a>4 熔断和降级的区别</h3><p>相同点：</p><ul><li>目的一致。通过技术手段来保护系统</li><li>表现类似：让用户体验到某些服务暂时不可用</li><li>粒度相同：都是基于服务的</li></ul><p>不同点</p><ul><li>触发条件不同<ul><li>服务熔断：服务熔断由链路上某个服务故障引起的</li><li>服务降级，整体负荷来考虑。比如：原本有一个系统可以承载100个请求，但是后面由于请求数降低，相应的服务数量也需要降低</li></ul></li><li>管理目标层级不同<ul><li>服务熔断：服务熔断是一个框架层次的处理，</li><li>服务降级：服务降级是业务层次的处理。降级一般是从外围服务开始</li></ul></li></ul><h3 id="5-熔断的意义？"><a href="#5-熔断的意义？" class="headerlink" title="5. 熔断的意义？"></a>5. 熔断的意义？</h3><ul><li>让系统更加稳定</li><li>减少性能损耗<ul><li>响应很简单，所以产生的性能很小。</li><li>用户知道服务有问题了，就不再调用，避免一直重试，也可以减少性能损耗。</li></ul></li><li>及时响应。不需要其他计算，直接就可以返回一个简单的响应。</li><li>阀值可定制，比如请求到达10000，就开启熔断器</li></ul><h3 id="6-Spring-Cloud-如何实现服务服务熔断"><a href="#6-Spring-Cloud-如何实现服务服务熔断" class="headerlink" title="6. Spring Cloud 如何实现服务服务熔断"></a>6. Spring Cloud 如何实<strong>现服务服务熔断</strong></h3><ul><li>Feign是Netflix开发的一款服务容错和保护组件</li><li>当出现服务异常或调用超时时，Hystrix 定义了一个回退方法，与公开服 务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br><span class="hljs-meta">@HystrixCommand(fallbackMethod=&quot;defaultCities&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> cityClient.listCity();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">defaultCities</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Micro weather city eureka is down!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-7-消息总线"><a href="#5-7-消息总线" class="headerlink" title="5.7 消息总线"></a>5.7 消息总线</h2><h3 id="1-Spring-Cloud-Bus"><a href="#1-Spring-Cloud-Bus" class="headerlink" title="1. Spring Cloud Bus"></a>1. Spring Cloud Bus</h3><ul><li>Spring Cloud Bus 又被称为消息总线，它能够通过轻量级的消息代理（例如 RabbitMQ、Kafka 等）来构建一个公用的<strong>消息主题</strong>，将微服务架构中的各个服务都连接上来起来，从而实现广播状态更改、事件推送等功能，还可以实现微服务之间的通信功能。</li><li>目前 Spring Cloud Bus 支持两种消息代理：RabbitMQ 和 Kafka。</li></ul><h2 id="Spring-Cloud-Bus-的基本原理"><a href="#Spring-Cloud-Bus-的基本原理" class="headerlink" title="Spring Cloud Bus 的基本原理"></a>Spring Cloud Bus 的基本原理</h2><ul><li>Spring Cloud Bus 会使用一个轻量级的消息代理来构建一个公共的消息主题 Topic（默认为“springCloudBus”），<strong>这个 Topic 中的消息会被所有服务实例监听和消费</strong>。</li><li>当其中的一个服务刷新数据时，Spring Cloud Bus 会把信息保存到 Topic 中，这样监听这个 Topic 的服务就收到消息并自动消费。</li></ul><h2 id="Spring-Cloud-Bus-动态刷新配置的原理"><a href="#Spring-Cloud-Bus-动态刷新配置的原理" class="headerlink" title="Spring Cloud Bus 动态刷新配置的原理"></a>Spring Cloud Bus 动态刷新配置的原理</h2><ul><li>当 Git 仓库中的配置发生了改变，我们只需要向某一个服务Config 服务端，也可以是 Config 客户端发送一个 POST 请求，Spring Cloud Bus 就可以通过消息代理通知其他服务重新拉取最新配置，以实现配置的动态刷新。</li><li>利用 Spring Cloud Bus 的特殊机制可以实现很多功能，其中配合 Spring Cloud Config 实现配置的动态刷新就是最典型的应用场景之一。</li></ul><h2 id="Spring-Cloud-Bus-整合Spring-Cloud-Config实现配置的动态刷新"><a href="#Spring-Cloud-Bus-整合Spring-Cloud-Config实现配置的动态刷新" class="headerlink" title="Spring Cloud Bus 整合Spring Cloud Config实现配置的动态刷新"></a>Spring Cloud Bus 整合Spring Cloud Config实现配置的动态刷新</h2><ol><li>当 Git 仓库中的配置发生改变后，运维人员向 Config 服务端发送一个 POST 请求，请求路径为“&#x2F;actuator&#x2F;refresh”。</li><li>Config 服务端接收到请求后，会将该请求转发给服务总线 Spring Cloud Bus。</li><li>Spring Cloud Bus 接到消息后，会通知给所有 Config 客户端。</li><li>Config 客户端接收到通知，请求 Config 服务端拉取最新配置。</li><li>所有 Config 客户端都获取到最新的配置。</li></ol><h3 id="Ribbon-和-Feign-的区别和联系"><a href="#Ribbon-和-Feign-的区别和联系" class="headerlink" title="Ribbon 和 Feign 的区别和联系"></a>Ribbon 和 Feign 的区别和联系</h3><ul><li><p>相同点：二者都是Netflix开发的，可以用来实现服务间的调用以及负载均衡。Feign 是在 Ribbon的基础上进行了一次改进，是一个使用起来更加方便的 HTTP 客户端。</p></li><li><p>调用方式不同</p><ul><li><p>ribbon是一个基于 HTTP 和 TCP <strong>客户端</strong>的负载均衡的工具。简单来说，rubbon &#x3D; 负载均衡+ restTemplate，需要自己构建请求，步骤相当繁琐。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//面向微服务编程，即通过微服务的名称来获取调用地址</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REST_URL_PREFIX = <span class="hljs-string">&quot;http://micro-weather-city-eureka&quot;</span>;<br>    <br> <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="hljs-string">&quot;/cities&quot;</span>, String.class);<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>采用接口的方式， <strong><code>只需要创建一个接口，然后在上面添加注解@FeignClient即可</code></strong> ，将需要调用的其他服务的方法定义成抽象方法即可， 不需要自己构建http请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;micro-weather-city-eureka&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CityClient</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-function">String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>启动类上使用的注解不同</p><p>Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients。</p></li></ul><p> 由于Ribbon写起来还需要自己拼请求，所以采用了更简单的Feign</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单体架构的优缺点</title>
    <link href="/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <url>/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="单体架构的优缺点"><a href="#单体架构的优缺点" class="headerlink" title="单体架构的优缺点"></a>单体架构的优缺点</h1><p>优点：</p><ul><li><p>部署简单：只有一个包</p></li><li><p>技术单一：同一个架构来说，基本上是一个一种技术，类似springboot + java</p></li><li><p>用人成本低：因为只需要一种技术</p></li></ul><p>缺点：</p><ul><li><p>代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。</p></li><li><p>开发效率低：开发人员同时维护同一套代码，很难避免代码冲突。开发过程中会伴随解决冲突，严重影响开发效率。</p></li><li><p>排查解决问题成本高：线上发现了bug，可能bu g很简单，但是由于只有一套代码，需要编译打包上线，成本很高。</p></li><li><p>监控很难：很多功能点，杂在一个系统中。</p></li></ul><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><ul><li>由很多服务组成，每个服务都可以独立部署，每个服务之间以一种轻量级的通讯方式进行交互，例如http。这些服务之间没有很强的技术关联，可以A用java，B用Go.</li><li>设计原则：<ul><li>拆分足够的微。颗粒太大，没法发挥微服务的优势，颗粒太小，管理混乱。</li><li>轻量级通信。rest，消息中间件</li><li>领域驱动原则。比如客户是一个领域，表单是一个领域</li><li>单一指责。服务应该尽可能不依赖其他服务，边界应该足够清晰，而且接口应该妥善设计，隐藏内部细节。</li><li>DevOps</li><li>不限技术栈。比如mongo, pg</li></ul></li><li>如何设计：<ul><li>服务拆分</li><li>服务注册。多个服务间的通信，需要一个服务注册机制。服务启动的时候，要将服务注册到注册中心；服务中心和微服务之间通过某种机制关联，例如心跳机制；不同服务之间可以进行发现，从服务注册中心，获取要调用的服务的信息。</li><li>服务消费，调用其他服务，调用方相当于是服务消费者，被调用方是服务供应商</li><li>统一入口，服务数量多起来之后，每一个消费者要记住所有服务的名称是比较困难的，所以需要一个统一的入口，我们只需要知道入口的名称，而不需要知道具体服务提供者的名称。</li><li>配置的管理。配置文件里写上不同服务需要的配置，不同服务去做个性化配置。</li><li>熔断机制：某个微服务出现异常时（请求反应慢或宕机），其整个流程还是可以友好的进行下去。即向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就可以保证调用方的线程不会被长时间、无厘头滴占用，从而保护整个系统，避免崩溃。</li><li>自动扩展：服务可以根据当前附在状况可以自动扩展。比如当前有10个实例，当负荷突然增大，比如请求数增大，可以自动扩展成20个。</li></ul></li><li>拆分的意义<ul><li>易于实现：服务更小，代码更少，更加利于理解，实现。</li><li>易于维护：更少的代码，更容易维护</li><li>易于部署：每个服务都是轻量级实现，jar包比较小</li><li>易于更新：服务之间都是隔离的，所以每个服务都可以独立更新，不会影响其他服务。</li></ul></li><li>拆分的方法<ul><li>横向拆分。数据采集，数据存储，数据查询，数据展示</li><li>纵向拆分。基础设施层，领域层，应用层，用户界面</li><li>使用DDD。不同的领域</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>postgreSQL、mysql、Mongoldb、redis的对比</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94/"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h1 id="1-postgreSQL-和-mysql的对比"><a href="#1-postgreSQL-和-mysql的对比" class="headerlink" title="1 postgreSQL 和 mysql的对比"></a>1 postgreSQL 和 mysql的对比</h1><ul><li><p>PostgreSQL是进程模式，MySQL是线程模式。进程模式对多CPU利用率比较高。</p></li><li><p>事务的支持：PostgreSQL支持事务的强一致性，事务保证性好，完全支持ACID特性。MySQL只有innodb引擎支持事务，mysiam不支持事务。</p></li><li><p>分区的实现：MySQL分区表的实现要优于PG的基于继承表的分区实现，主要体现在分区个数达到上千上万后的处理性能差异较大。</p></li><li><p>PG主表采用堆表存放，MySQL采用索引组织表，能够支持比MySQL更大的数据量。</p></li><li><p>MySQL不支持XML 数据类型，PostgreSQL支持</p></li><li><p>PostgreSQL完全免费，而且是BSD协议，如果把PostgreSQL改一改，然后再拿去卖钱，也没有人管你，这一点很重要，这表明了PostgreSQL数据库不会被其他公司控制。相反，MySQL现在主要是被Oracle公司控制。</p></li></ul><h1 id="2-Mysql-和Mongoldb对比"><a href="#2-Mysql-和Mongoldb对比" class="headerlink" title="2 Mysql 和Mongoldb对比"></a>2 Mysql 和Mongoldb对比</h1><ul><li>postgresql是关系型数据库，Mongoldb 是非关系型数据库，</li><li>查询语法不同。postgresql使用基本的sql操作，mongodb使用pipeline，比如pg join ，mongo $lookup</li><li>mongodb的优势就是文档存储，业务经常变动，需要不时的添加字段，那么mongodb比较适合</li><li>对于那些需要对多个文档（在单个或多个集合中）进行原子性读写的场景，MongoDB支持了<strong>多文档事务</strong>。</li><li>mysql集群主要模式是：主从+哨兵+cluster，mongoDb的是主从+复制集+分片集群</li></ul><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ul><li>非常丰富的数据结构</li><li>Redis提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断；</li><li>数据存在内存中，读写非常的高速，可以达到10w&#x2F;s的频率</li></ul><h1 id="es和mongo"><a href="#es和mongo" class="headerlink" title="es和mongo"></a>es和mongo</h1><p>相同点：</p><ul><li><code>MongoDB</code>和<code>Elasticsearch</code>都属于NoSQL大家族, 且都属于文档型数据存储</li><li>两者都通过分片支持水平扩展，分片将数据进行水平切分之后，将其存储到多个不同的服务器节点上的一 种扩展方式。</li></ul><blockquote><p> 水平分片: 通过某个字段(或某几个字段)，根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。取模，范围</p><p> 垂直分片: 按照业务将表进行归类，分布到不同的数据库或表</p></blockquote><p>不同点：</p><ul><li>定位不同<ul><li>MongoDB 是 <strong>文档型数据库</strong>, 提供 <strong>数据存储和管理服务</strong></li><li><a href="https://so.csdn.net/so/search?q=Elasticsearch&spm=1001.2101.3001.7020">Elasticsearch</a> 是<strong>搜索服务</strong>, 提供 <strong>数据检索服务</strong></li></ul></li><li>使用场景：<ul><li>如果你有一批数据要看, 但是不经常进行修改, 这个时候毫无疑问可以用es</li><li>如果你还打算继续修改数据, 最好就是使用MongoDB</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>postgreSQL</tag>
      
      <tag>mysql</tag>
      
      <tag>redis</tag>
      
      <tag>mongo</tag>
      
      <tag>es</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka知识点整理</title>
    <link href="/kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="kafka和RabbitMq的对比"><a href="#kafka和RabbitMq的对比" class="headerlink" title="kafka和RabbitMq的对比"></a>kafka和RabbitMq的对比</h3><ol><li><p>存储上：</p><ul><li>kafka支持了分布式存储，也就是分区。相当于把原来rabbitMq 的queue拆分成了很多个小队列，分布式存储在不同的服务上，提高了消息的发送的效率（一次可以发到多个分区），提高了消费效率，不同分区，使用不同的消费者，提高了并发处理能力。</li></ul></li><li><p>应用场景上：</p><ul><li>RabbitMQ,遵循AMQP协议，用在实时的对可靠性要求比较高的消息传递上。</li><li>kafka它主要用于处理活跃的流式数据,大数据量的数据处理上。</li></ul></li><li><p>吞吐量上：</p><ul><li>rabbitMQ在吞吐量方面稍逊于kafka，他们的出发点不一样，rabbitMQ支持对消息的可靠的传递，支持事务，不支持批量的操作</li><li>kafka具有高的吞吐量，内部采用消息的批量处理，zero-copy机制，数据的存储和获取是本地磁盘顺序批量操作，具有O(1)的复杂度，消息处理的效率很高。</li></ul></li><li><p>在可用性方面:</p><ul><li>rabbitMQ支持miror的queue，主queue失效，miror queue接管。</li><li>kafka的broker支持主备模式。</li></ul></li><li><p>在集群负载均衡方面:</p><ul><li>rabbitMQ的负载均衡需要单独的loadbalancer进行支持。</li><li>kafka采用zookeeper对集群中的broker、consumer进行管理，可以注册topic到zookeeper上；通过zookeeper的协调机制，producer保存对应topic的broker信息，可以随机或者轮询发送到broker上；并且producer可以基于语义指定分片，消息发送到broker的某分片上。</li></ul></li><li><p>消息的删除时间上：</p><ol><li>rabbitMQ 消费完了就删除。</li><li>kafka一般不会删除消息，不管这些消息有没有被消费。只会根据配置的日志保留时间(log.retention.hours)确认消息多久被删除，默认保留最近一周的日志消息。这些日志可以被重复读取和无限期保留。</li></ol></li></ol><h3 id="为什么要对Topic下数据进行分区存储？"><a href="#为什么要对Topic下数据进行分区存储？" class="headerlink" title="为什么要对Topic下数据进行分区存储？"></a>为什么要对Topic下数据进行分区存储？</h3><ol><li>commit log文件会受到所在机器的文件系统大小的限制，分区之后可以将不同的分区放在不同的机器上，相当于对</li></ol><p>数据做了<strong>分布式存储</strong>，理论上一个topic可以处理任意数量的数据。 </p><p>  2、为了<strong>提高并行度</strong>，consumer可以并行去处理不同分区拿到的数据。</p><h3 id="怎么理解Topic，Partition和Broker-？"><a href="#怎么理解Topic，Partition和Broker-？" class="headerlink" title="怎么理解Topic，Partition和Broker ？"></a>怎么理解<strong>Topic，Partition和Broker</strong> ？</h3><ol><li><p>一个topic，代表逻辑上的一个业务数据集，比如按数据库里不同表的数据操作消息区分放入不同topic。</p></li><li><p>订单相关操作消息放入订单topic，用户相关操作消息放入用户topic，对于大型网站来说，后端数据都是海量的，订单消息很可能是非常巨量的，比如有几百个G甚至达到TB级别，如果把这么多数据都放在一台机器上可定会有容量限制问题，那么就可以在 topic内部划分多个partition来分片存储数据。</p></li><li><p>不同的partition可以位于不同的机器上，每台机器上都运行一个Kafka的进程Broker。</p></li></ol><h3 id="kafka的消费者是-pull-拉-还是push-推-模式，这种模式有什么好处？"><a href="#kafka的消费者是-pull-拉-还是push-推-模式，这种模式有什么好处？" class="headerlink" title="kafka的消费者是**pull(拉)还是push(推)**模式，这种模式有什么好处？"></a><strong>kafka</strong>的消费者是**pull(<strong>拉</strong>)<strong>还是</strong>push(<strong>推</strong>)**模式，这种模式有什么好处？</h3><p>Kafka 遵循了一种大部分消息系统共同的传统的设计：producer 将消息推送到 broker，consumer 从broker 拉取消息。</p><p>优点：pull模式消费者自主决定是否批量从broker拉取数据，而push模式在无法知道消费者消费能力情况下，不易控制推送速度，太快可能造成消费者奔溃，太慢又可能造成浪费。</p><p>缺点：如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询，直到新消息到到达。为了避免这点，Kafka 有个参数可以让 consumer阻塞直到新消息到达，当然也可以阻塞直到消息的数量达到某个特定的量这样就可以批量发送。</p><h2 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h2><ul><li>leader处理所有的针对这个partition的读写请求。</li><li>而followers被动复制leader的结果，不提供读写(主要是为了保证多副本数据与消费的一致性）。如果这个leader失效了，其中的一个follower将会自动的变成新的leader。</li></ul><h2 id="消费顺序怎么保证？"><a href="#消费顺序怎么保证？" class="headerlink" title="消费顺序怎么保证？"></a>消费顺序怎么保证？</h2><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><ul><li><p><strong>发送端：</strong>发送消息的时候，往一个partition 中去发。</p><p>如果发送端配置了重试机制，就可能出现发送方发送时是1，2，3，但1发送失败，重试发送1，这样收到的消息就是2，3，1。这种情况下，需要同步的去发消息，只有第一个消息发送成功了，再去发送2，3。</p></li><li><p><strong>消费端：</strong>取消息的时候也从一个partition 中去取。一个partition同一个时刻，在一个consumer group里只能有一个consumer去消费，从而保证消费顺序。</p></li></ul><h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><ul><li><strong>发送端：</strong>发送消息的时候，往多个partition 中去发。</li><li><strong>消费端：</strong>只设置一个consumer，消息来了不立即处理，而是自己逻辑排序后处理。搞一个类似CountDownLatch，比如总共有3条消息，就只有当3条消息都接受到了后，才进行处理，consumer端自己可以在业务逻辑中排序，比如给消息里加上一个type类型，检测是下单的消息，就优先处理，然后再处理减库存，通知快递。如果考虑到性能还不够高，可以在consumer端，考虑增加<strong>多线程</strong>去处理。</li></ul><p>注意：</p><ul><li>consumer group中保证，consumer 的数量 &lt; partition的数量，否则多出的consumer得不到信息。</li><li>如果有在总体上保证消费顺序的需求，那么我们可以通过将topic的partition数量设置为1，将consumer group中的consumer 数量也设置为1，但是这样会影响性能，所以kafka的顺序消费很少用。</li></ul><h2 id="消息积压和解决"><a href="#消息积压和解决" class="headerlink" title="消息积压和解决"></a>消息积压和解决</h2><h3 id="1-生产者发送流量太大"><a href="#1-生产者发送流量太大" class="headerlink" title="1.生产者发送流量太大"></a>1.生产者发送流量太大</h3><ul><li>降低消息生产的速度。生产者端产生消息的速度通常是跟业务息息相关的，一般情况下不太好直接优化。但是可以采用批量发送消息的方式，降低IO频率。</li></ul><h3 id="2-消费者能力不足"><a href="#2-消费者能力不足" class="headerlink" title="2. 消费者能力不足"></a>2. 消费者能力不足</h3><ul><li>修改消费端程序，写一个临时的分发数据的 consumer 程序，将收到的消息快速转发给指定的新创建的topic，给这个topic设置原来10倍的分区。临时征用 10 倍的机器来部署 consumer，每一个 consumer 消费一个新主题的分区。</li><li>将消息快速转录。保存到数据库或者Redis，然后再慢慢进行处理。</li><li>kafka消费能力不足，则可以考虑增加Topic的Partition的个数，同时提升消费者组的消费者数量。</li></ul><h3 id="3-数据格式变动或者消费者有bug"><a href="#3-数据格式变动或者消费者有bug" class="headerlink" title="3. 数据格式变动或者消费者有bug"></a>3. 数据格式变动或者消费者有bug</h3><ul><li>将消费不成功的消息转发到其他队列里，类似死信队列，后面再慢慢分析。kafka没有死信队列需要自己实现。</li></ul><h3 id="kafka-如何不消费重复数据？"><a href="#kafka-如何不消费重复数据？" class="headerlink" title="kafka 如何不消费重复数据？"></a>kafka 如何不消费重复数据？</h3><p>重复数据的产生：</p><ul><li><p>发送方：发送消息如果配置了重试机制，比如网络抖动时间过长导致发送端发送超时，实际broker可能已经接收到消息，但发送方会重新发送消息</p></li><li><p>消费方：如果消费这边配置的是自动提交，刚拉取了一批数据处理了一部分，但还没来得及提交，服务挂了，下次重启又会拉取相同的一批数据重复处理。</p></li></ul><p> 解决方式：</p><ul><li><p>消费消息服务做幂等校验，比如：数据库&#x2F;redis：设置一个唯一的id去标志这条消息，消费时去查询一下，如果已经消费过了，则不进行消费。 </p></li><li><p>将<code>enable.auto.commit</code>参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：</p><p>什么时候提交offset合适？</p><ul><li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li><li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li></ul></li><li><h1 id="6-Zookeeper-在-Kafka-中的作用"><a href="#6-Zookeeper-在-Kafka-中的作用" class="headerlink" title="6 Zookeeper 在 Kafka 中的作用?"></a>6 Zookeeper 在 Kafka 中的作用?</h1><p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p><ol><li><p><strong>Broker 注册</strong> ：在Zookeeper上会有一个专门<strong>用来进行Broker服务器列表记录</strong>的节点&#x2F;brokers&#x2F;ids，每个Broker在启动时，都会到Zookeeper上进行注册，即到&#x2F;brokers&#x2F;ids下创建属于自己的节点，如&#x2F;brokers&#x2F;ids&#x2F;[0…N]。Kafka使用了全局唯一的数字来指代每个Broker服务器，不同的Broker必须使用不同的Broker ID进行注册，创建完节点后，<strong>每个Broker就会将自己的IP地址和端口信息记录</strong>到该节点中去。其中，Broker创建的节点类型是临时节点，一旦Broker宕机，则对应的临时节点也会被自动删除。</p></li><li><p><strong>Topic 注册</strong>： 在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></p></li><li><p><strong>负载均衡</strong> ：Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。<strong>当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</strong></p></li><li><p>之前，在消费者对指定消息分区进行消息消费的过程中，<strong>需要定时地将分区消息的消费进度Offset记录到Zookeeper上</strong>，以便在该消费者进行重启或者其他消费者重新接管该消息分区的消息消费后，能够从之前的进度开始继续进行消息消费。</p></li></ol></li></ul><h2 id="消费进度Offset的理解"><a href="#消费进度Offset的理解" class="headerlink" title="消费进度Offset的理解"></a>消费进度Offset的理解</h2><ul><li><p>在消费者对指定消息分区进行消息消费的过程中，<strong>需要定时地将分区消息的消费进度Offset记录到Zookeeper上</strong>，以便在该消费者进行重启或者其他消费者重新接管该消息分区的消息消费后，能够从之前的进度开始继续进行消息消费。</p></li><li><p>现在是放在了一个叫做__consumer_offset 的topic 里，<strong>key是</strong> consumerGroupId+topic+分区号，value就是当前offset的值。默认是50个分区，由consumer自己管理。 </p></li><li><p><strong>每个consumer是基于自己在commit log中的消费进度(offset)来进行工作的</strong>。</p></li><li><p>这意味kafka中的consumer对集群的影响是非常小的，添加一个或者减少一个consumer，对于集群或者其他consumer 来说，都是没有影响的，因为每个consumer维护各自的消费offset。</p></li><li><p>一般情况下我们按照顺序逐条消费commit log中的消息，当然我可以通过指定offset来重复消费某些消息， 或者跳过某些消息。</p></li></ul><h2 id="延迟队列的实现"><a href="#延迟队列的实现" class="headerlink" title="延迟队列的实现"></a>延迟队列的实现</h2><ol><li>发送延时消息时先把消息按照不同的延迟时间段发送到指定的队列中（topic_1s，topic_5s，topic_10s，…topic_2h，这个一 般不能支持任意时间段的延时）。</li><li>consumer通过定时器进行轮训消费这些topic，查看消息是否到期，如果到期就把这个消息发送到具体业务处理的topic中。提交时需要带上offset，便于下次知道从哪里开始消费。</li><li>队列中消息越靠前的到期时间越早，具体来说就是定时器在一次消费过程中，对消息的发送时间做判断，看下是否延迟到对 应时间了，如果到了就转发，如果还没到这一次定时任务就可以提前结束了。</li></ol><h2 id="kafka-高性能的原因？"><a href="#kafka-高性能的原因？" class="headerlink" title="kafka 高性能的原因？"></a>kafka 高性能的原因？</h2><ul><li><p>磁盘顺序读写：kafka消息不能修改以及不会从文件中间删除保证了磁盘顺序读，kafka的消息写入文件都是追加在文件末尾， </p><p>不会写入文件中的某个位置(随机写)保证了磁盘顺序写。 </p></li><li><p>读写数据的批量batch处理以及压缩传输 。Kafka采用的数据压缩的方式，以时间换空间，通过cpu时间的增加来尽量的减少磁盘空间的占用和网络IO的传输量，Kafka中消息的压缩是发生在生产者和Broker端的。</p><ul><li>在生产者端，消息发送的时候将消息进行压缩，可以通过参数来配置进行压缩的算法</li><li>在消费者端就需要对消息进行解压缩操作</li></ul></li><li><p>数据传输的零拷贝</p><ul><li><p>传统的IO流程，某台机器将一份数据（比如一个文件）通过网络传输到另外一台机器，主要包括 read 和 write 过程。</p><ul><li>read：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区</li><li>write：先把用户缓冲区的数据写入到 socket缓冲区，最后写入网卡设备</li></ul></li><li><p>需要经过四次拷贝和四次状态的转换</p><ul><li><p>用户空间的应用程序通过read()函数，向操作系统发起IO调用，<strong>上下文从用户态到切换到内核态（切换1）</strong>，然后再通过 DMA 控制器将数据从【磁盘文件】拷贝到【操作系统内核缓冲区】</p></li><li><p>CPU将数据从【内核缓冲区】拷贝到【用户缓冲区】，<strong>上下文从内核态转为用户态（切换2）</strong>，read函数返回。</p></li><li><p>用户应用进程通过write函数，发起IO调用，<strong>上下文从用户态转为内核态（切换3）</strong>，CPU将数据从【用户缓冲区】拷贝到【内核中Socket缓冲区】</p></li><li><p>MA控制器把数据从【内核中Socket缓冲区】拷贝到【内核中网卡的缓冲区】<strong>上下文从内核态切换回用户态（切换4）</strong>，write函数返回</p></li></ul></li><li><p>Kafka 使用sendfile 来实现零拷贝</p><ul><li>数据从从【磁盘文件】拷贝到【操作系统内核缓冲区】后，直接让操作系统内核缓冲区的数据发送到网卡，跳过了两次CPU拷贝数据的步骤。减少了内核态和用户态上下文状态的切换</li></ul></li></ul><p>注：<strong>其实零拷贝，并不是说拷贝的次数为零，只是说没有cup拷贝的过程，这里的零拷贝指的是cpu拷贝次数为零</strong>，</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228234101159.png" alt="image-20230228234101159"></p></li></ul><blockquote><p> 什么是用户态、内核态?</p></blockquote><blockquote><ul><li>如果进程运行于内核空间，被称为进程的内核态</li><li>如果进程运行于用户空间，被称为进程的用户态。</li></ul><p>操作系统为每个进程都分配了内存空间，一部分是用户空间，一部分是内核空间。<strong>内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域</strong></p></blockquote><h2 id="设计一个MQ的思路"><a href="#设计一个MQ的思路" class="headerlink" title="设计一个MQ的思路"></a>设计一个MQ的思路</h2><ul><li>可伸缩性：需要的时候快速扩容，就可以增加吞吐量和容量。参照一下 kafka 的设计理念， broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。 如果现在资源不够了，给 topic 增加 partition。</li><li>持久化：mq 的数据要落地磁盘，参考kafka顺序写，顺序读。这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的</li><li>高可用性：多副本 -&gt; leader &amp; follower，broker 挂了重新选举 leader</li><li>数据 0 丢失：参考：<a href="https://pyr9.github.io/RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E9%9B%B6%E4%B8%A2%E5%A4%B1%E6%96%B9%E6%A1%88/">RabbitMQ的消息零丢失方案 - 楼上有只喵 (pyr9.github.io)</a>， <a href="https://pyr9.github.io/kafka%E7%9A%84%E6%B6%88%E6%81%AF%E9%9B%B6%E4%B8%A2%E5%A4%B1%E6%96%B9%E6%A1%88/">kafka的消息零丢失方案 - 楼上有只喵 (pyr9.github.io)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 代理</title>
    <link href="/java-%E4%BB%A3%E7%90%86/"/>
    <url>/java-%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p> 代理是一种设计模式</p><ul><li>定义：通过代理对象访问目标对象。</li><li>好处：可以在不修改目标对象的基础上，扩展目标对象的功能</li></ul><p> 代理类可以分为静态代理和动态代理。</p><h2 id="1-静态代理和动态代理"><a href="#1-静态代理和动态代理" class="headerlink" title="1.静态代理和动态代理"></a><strong>1.静态代理</strong>和动态代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ol><li><p>定义： 通过声明一个明确的代理类来访问源对象。需要和目标对象一起实现相同的接口或者继承相同的父类。</p></li><li><p>特点：在编译器确定代理对象，在程序运行前，代理类的.class文件就已经存在了。</p></li><li><p>优点：可以做到不修改目标对象的前提下，对目标对象的方法进行扩展。</p></li><li><p>缺点：</p><ul><li><p>代理类需要和目标类实现相同的接口，同时要实现相同的方法，这样就出现了很多重复代码。</p></li><li><p>如果接口增加一个方法，代理类和目标类都需要实现这个方法，增加了代码维护的复杂度。</p></li></ul></li></ol><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><ol><li><p>定义：使用JDK官方的Proxy类创建代理对象。</p></li><li><p>特点：在程序运行过程中，动态生成代理类，代理类需要实现<strong>InvocationHandler</strong>，重写invoke方法。</p></li><li><p>优点：</p><ul><li>接口中声明的所有方法被迁移到代理类中的invoke方法进行实现，这样，如果接口方法很多的话，不需要为每一个方法进行中转，可以灵活处理。</li></ul></li></ol><h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><ol><li><p>使用：第三方CGLib的Enhancer类创建代理对象, 设置Superclass为目标类， 使用的是方法拦截器 <strong>MethodInterceptor</strong>，重写intercept方法。</p></li><li><p>特点：Cglib是通过生成子类来实现的，代理对象既可以赋值给实现类，又可以赋值给接口。</p></li><li><p>优点：Cglib速度比jdk动态代理更快，性能更好。</p></li></ol><h2 id="静态代理程序示例"><a href="#静态代理程序示例" class="headerlink" title="静态代理程序示例"></a>静态代理程序示例</h2><p>step1:定义委托类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Email</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlashEmail</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Email</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>            System.out.println(<span class="hljs-string">&quot;邮件发送中。。。。。&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>       System.out.println(<span class="hljs-string">&quot;邮件接受中..........&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>step2:定义代理类，与委托类有同样的接口</p><p> 不改变原接口实现类的情况下，就可以对接口的功能进行需求变更</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Email</span> </span>&#123;<br><br>Email email;<br>     <span class="hljs-comment">//传入委托类初始化代理类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmailProxy</span><span class="hljs-params">(Email email)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>.email=email;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;发送邮件前准备。。。&quot;</span>);<br>    email.send();<br>    System.out.println(<span class="hljs-string">&quot;发送后。。。。。。&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revieve</span><span class="hljs-params">()</span> </span>&#123;<br><br>System.out.println(<span class="hljs-string">&quot;接受邮件前准备。。。&quot;</span>); <br>email.receive();<br>System.out.println(<span class="hljs-string">&quot;接受邮件成功....&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>step3:测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//原始对象</span><br>   Email email=<span class="hljs-keyword">new</span> FlashEmail();<br>   <span class="hljs-comment">//接口的代理类</span><br>   EmailProxy ep=<span class="hljs-keyword">new</span> EmailProxy(email);<br>   ep.send();<br>   System.out.println(<span class="hljs-string">&quot;-----------------------------------------&quot;</span>);<br>   ep.receive();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>测试结果：</p><p>发送邮件前准备。。。<br> 邮件发送中。。。。。<br> 发送后。。。。。。<br> -—————————————-<br> 接受邮件前准备。。。<br> 邮件接受中……….<br> 接受邮件成功….</p><h3 id="2-JDK动态代理程序示例"><a href="#2-JDK动态代理程序示例" class="headerlink" title="2 JDK动态代理程序示例"></a>2 JDK动态代理程序示例</h3><p>Step1: 定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Email</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revieve</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>step1:定义委托类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlashEmail</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Email</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>            System.out.println(<span class="hljs-string">&quot;邮件发送中。。。。。&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>       System.out.println(<span class="hljs-string">&quot;邮件接受中..........&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>step2:在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，也叫动态代理类，以完成代理要完成的具体操作，这个类被要求实现<strong>InvocationHandler</strong>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.my.test.proxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>Object obj;<span class="hljs-comment">//委托对象</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmailProxy</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.obj = obj;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;send&quot;</span>.equals(method.getName())) &#123;<br> System.out.println(<span class="hljs-string">&quot;发送邮件前准备。。。&quot;</span>);<br> method.invoke(obj);<span class="hljs-comment">//从委托对象中，调用该对象的指定方法，这里相当于send方法</span><br>     System.out.println(<span class="hljs-string">&quot;发送后。。。。。。&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;receive&quot;</span>.equals(method.getName())) &#123;<br>System.out.println(<span class="hljs-string">&quot;接受邮件前准备。。。&quot;</span>); <br>method.invoke(obj);<br>System.out.println(<span class="hljs-string">&quot;接受邮件成功....&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>step4:测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Email email=<span class="hljs-keyword">new</span> FlashEmail();<br>    Email emailProxy=(Email) Proxy.newProxyInstance(<br>      email.getClass().getClassLoader(),<br>      email.getClass().getInterfaces(),<br>      <span class="hljs-keyword">new</span> EmailProxy(email) );<br>    emailProxy.send();<br>    System.out.println(<span class="hljs-string">&quot;---------------------------------------------------&quot;</span>);<br>    emailProxy.receive();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>测试结果：</p><p>发送邮件前准备。。。<br> 邮件发送中。。。。。<br> 发送后。。。。。。<br> -—————————————-<br> 接受邮件前准备。。。<br> 邮件接受中……….<br> 接受邮件成功….</p><h3 id="CGLIB动态代理程序示例"><a href="#CGLIB动态代理程序示例" class="headerlink" title="CGLIB动态代理程序示例"></a>CGLIB动态代理程序示例</h3><p>Step1: 引入cglib依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;cglib&lt;/groupId&gt;<br>  &lt;artifactId&gt;cglib&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">3.2</span><span class="hljs-number">.5</span>&lt;/version&gt;<br>  &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>Step2: 定义委托类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlashEmail</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;邮件发送中。。。。。&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;邮件接受中..........&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Step3: 创建一个拦截器，实现接口net.sf.cglib.proxy.MethodInterceptor，用于方法的拦截回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    Object result = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;send&quot;</span>.equals(method.getName())) &#123;<br>      System.out.println(<span class="hljs-string">&quot;发送邮件前准备。。。&quot;</span>);<br>      result = methodProxy.invokeSuper(proxy,args);<br>      System.out.println(<span class="hljs-string">&quot;发送后。。。。。。&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;receive&quot;</span>.equals(method.getName())) &#123;<br>      System.out.println(<span class="hljs-string">&quot;接受邮件前准备。。。&quot;</span>);<br>      result = methodProxy.invokeSuper(proxy,args);<br>      System.out.println(<span class="hljs-string">&quot;接受邮件成功....&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Step4: 测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> proxy;<br><br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建Enhancer对象，类似于JDK动态代理的Proxy类</span><br>    Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>    enhancer.setSuperclass(FlashEmail.class);<br>    enhancer.setCallback(<span class="hljs-keyword">new</span> LogInterceptor());<br>    <span class="hljs-comment">// create方法正式创建代理类</span><br>    FlashEmail emailProxy = (FlashEmail)enhancer.create();<br>    emailProxy.send();<br>    emailProxy.receive();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><p>发送邮件前准备。。。<br> 邮件发送中。。。。。<br> 发送后。。。。。。<br> -—————————————-<br> 接受邮件前准备。。。<br> 邮件接受中……….<br> 接受邮件成功….</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring知识点整理</title>
    <link href="/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="Spring是什么？有什么优点"><a href="#Spring是什么？有什么优点" class="headerlink" title="Spring是什么？有什么优点"></a>Spring是什么？有什么优点</h4><ul><li>Spring是一个轻量级的java框架，Spring的核心是IOC和AOP。主要的优点包括：<ul><li>方便解耦，简化开发。通过Spring提供的IOC容器，我们可以将对象的依赖关系交给Spring进行控制，避免硬编码造成的耦合性高。简单来说，之前，如果我们controller 需要一个service，则需要new service，现在是Spring发现你的controller 需要service，就给你自动注入。</li><li>AOP编程的支持。Spring提供面向切面编程，方便的实现对程序进行拦截，运行监控等。主要通过BeanPostProcessor 的postProcessBeforeInitialization，postProcessAfterInitialization， + 动态代理实现。（有接口就用JDK的动态代理，否则CJLIB）</li><li>声明式事务的支持。只需要配置就可以实现对事务的管理，而无需手动编程。</li><li>对Junit支持，方便程序测试。<ul><li>集成了各种优秀框架，如mybatis, quartz。</li></ul></li></ul></li></ul><h3 id="在-Spring-中，Bean-是如何生成的？-x2F-bean-的生命周期"><a href="#在-Spring-中，Bean-是如何生成的？-x2F-bean-的生命周期" class="headerlink" title="在 Spring 中，Bean 是如何生成的？&#x2F; bean 的生命周期"></a>在 Spring 中，Bean 是如何生成的？&#x2F; bean 的生命周期</h3><ul><li>Spring扫描class 文件，得到BeanDefinition</li><li>根据BeanDefinition去生成bean<ul><li>根据class推断构造方法</li><li>根据构造方法，利用反射，生成对象（原始对象）。</li><li>填充对象中依赖的属性（依赖注入）</li><li>如果对象被AOP了，就需要根据原始对象生成一个代理对象。（beanPostProcessor）</li></ul></li><li>最终把生成的对象放进单例池（singleton objects），下次获取对象就直接从单例池中获取。</li></ul><h3 id="Spring的循环依赖"><a href="#Spring的循环依赖" class="headerlink" title="Spring的循环依赖"></a>Spring的循环依赖</h3><ul><li><p>循环依赖就在创建bean的过程中，A对象依赖了B对象，B对象依赖了A对象，导致A，B两个对象都创建不出来。</p><blockquote><p> ABean 创建–&gt;依赖了 B 属性–&gt;触发 BBean 创建—&gt;B 依赖了 A 属性—&gt;需要 ABean（但 ABean 还在创建过程中）</p></blockquote></li><li><p>在 Spring 中，通过<strong>三级缓存</strong>机制帮开发者解决了部分循环依赖的问题。</p><ul><li>一级缓存为：<strong>singletonObjects</strong>: 缓存已经经历了完整生命周期的 bean 对象。</li><li>二级缓存为：<strong>earlySingletonObjects</strong>: 缓存的是早期的 bean 对象。表示 Bean 的生命周期还没走完就把这个 Bean 放入了 earlySingletonObjects。</li><li>三级缓存为：<strong>singletonFactories</strong>: 缓存的是 ObjectFactory，对象工厂，用来创建早期 bean 对象的工厂。实际上是一个 Lambda 表达式， 执行lambda表达式，得到就是对应的代理对象。</li></ul></li></ul><h3 id="Spring前后置环绕异常通知"><a href="#Spring前后置环绕异常通知" class="headerlink" title="Spring前后置环绕异常通知"></a>Spring前后置环绕异常通知</h3><ul><li>before: 方法执行前执行，如果通知抛出异常，则方法无法执行。</li><li>after: 方法执行后执行，不论方法中是否抛出异常。主要用来清理现场。</li><li>around：环绕通知，方法执行前后分别执行，必须手动调用目标方法。</li><li>afterReturning: 方法执行后执行，可以获得方法的返回值，方法中抛出异常则无法执行。</li><li>afterThrowing: 方法抛出异常后执行。</li></ul><h3 id="Spring事务传播行为（多个事务存在是怎么处理的？）"><a href="#Spring事务传播行为（多个事务存在是怎么处理的？）" class="headerlink" title="Spring事务传播行为（多个事务存在是怎么处理的？）"></a>Spring事务传播行为（多个事务存在是怎么处理的？）</h3><ul><li><p>equired(需要)： 默认值。如果当前存在事务则加入这个事务，如果当前没有事务就新创建一个。</p></li><li><p>supports(支持)：如果当前存在事务，就加入这个事务，否则就以非事务的方式运行。</p></li><li><p>Mandatory(必须，强制)：如果当前存在事务，就加入这个事务，如果当前没有事务，就抛出异常。</p></li><li><p>Requires_new: 如果当前存在事务，就将该事务挂起。创建一个新的事务来运行。</p></li><li><p>Not_supported: 如果当前存在事务，就将该事务挂起。以非事务的方式运行。</p></li><li><p>never:  如果当前存在事务，就抛出异常，以非事务的方式运行。</p></li><li><p>nested(嵌套)：  如果当前存在事务，就创建一个事务当作当前事务的嵌套事务来运行，如果当前没有事务，就创建一个事务。</p><p>(加入<em>3+ 挂起</em> * 2+ 异常 * 1 + 嵌套事务 *1 s)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java知识点整理</title>
    <link href="/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><p>定义：死锁是两个或两个以上的线程互相都持有对方所需要的资源，导致这些线程都处于等待状态。</p></li><li><p>死锁产生的条件：</p><ul><li>互斥条件：一个资源只能被一个进程占用。</li><li>请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不变。</li><li>不剥夺条件：任何一个资源在没被该进程释放之前，其他线程都无法对他剥夺占用。</li><li>循环等待：当发生死锁时，所等待的线程会进入一个类似死循环，造成阻塞。</li></ul></li><li><p>如何避免</p><ul><li>设置加锁顺序。当多个线程需要一些相同的锁时，按照不同的加锁顺序去加锁。这种需要你事先知道所有的锁，但某些情况是未知的。</li><li>设置加锁时限。当一个线程在制定时限内没有获取到所需要的锁，则会释放已经获取到的锁，然后等待一段时间再重试。</li></ul></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO,BIO,AIO</title>
    <link href="/NIO-BIO-AIO/"/>
    <url>/NIO-BIO-AIO/</url>
    
    <content type="html"><![CDATA[<h3 id="1-BIO、NIO、AIO定义"><a href="#1-BIO、NIO、AIO定义" class="headerlink" title="1.BIO、NIO、AIO定义"></a>1.BIO、NIO、AIO定义</h3><p>Java共支持3种<a href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">网络编程</a>模型IO模式</p><ul><li><p><strong>BIO</strong>：(blocking io）同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器就要启动一个线程进行处理，如果这个链接不做任何事，就容易造成不必要的线程开销。当一个线程调用 <code>read()</code> 或 <code>write()</code> 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p></li><li><p><strong>NIO</strong>：(non blocking io 或 new io)异步非阻塞，NIO相对于BIO来说出现了几个核心的组件，分别是 Channle（通道） 和 Buffer（缓冲区）、Selector（选择器）  。NIO出现于JDK 1.4之后。</p><ul><li><p>Channel：NIO的所有IO操作都从Channl开始： </p><ul><li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li><li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li></ul></li><li><p>Buffer: 缓冲区的出现导致了NIO和BIO的不同：读数据时可以先读一部分到缓冲区中，然后处理其他事情；写数据时可以先写一部分到缓冲区中，然后处理其他事情。读和写操作可以不再持续，所以不会阻塞。当缓冲区满后才会将其放入真正地读&#x2F;写。</p></li></ul></li><li><p><strong>Selector</strong>：选择器可以让单个线程处理多个通道，达到复用的目的。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57mhubk5zj210y0u0acq.jpg" style="zoom:50%;" /></li><li><p><strong>AIO</strong>:异步非阻塞：AIO出现于JDK 1.7，是NIO的改进版。它的特点是由操作系统完成后，才通知服务器启动线程去处理。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络知识点整理</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-get和post的区别"><a href="#1-get和post的区别" class="headerlink" title="1. get和post的区别"></a>1. get和post的区别</h1><ul><li>表现形式<ul><li>get 请求的数据会附在url之后，以？形式分割URL和传输的数据，参数之间以&amp;连接。</li><li>post请求的数据是提交在HTTP的包体中。</li></ul></li><li>对数据长度的限制<ul><li>get是通过URl提交数据，所以他的长度受浏览器的限制</li><li>post是没有数据长度的限制的，起限制作用的是：服务器的处理能力。</li></ul></li><li>安全性<ul><li>与post相比，Get安全性较差。get提交数据的时候，用户名和密码都会明文的出现在URL上。因为登录页面有可能被浏览器缓存，所以其他人查看浏览器的记录，就可以拿到你的账户密码了。</li><li>post参数不会保留在浏览器历史中。</li></ul></li></ul><h1 id="2-http的常用方法"><a href="#2-http的常用方法" class="headerlink" title="2. http的常用方法"></a>2. http的常用方法</h1><ul><li>Get: 使用给定的URL请求资源</li><li>post：将数据发送到服务器，用来创建或者更新资源</li><li>head: 获取报文首部</li><li>Put: 传输数据，与post不同的是，他制定了资源的存放位置，post是由服务器自己决定。</li><li>Delete: 删除文件</li><li>trace: 追踪路径</li><li>permission：访问支持的方法。</li></ul><h1 id="3-TCP和UDP的区别与联系"><a href="#3-TCP和UDP的区别与联系" class="headerlink" title="3. TCP和UDP的区别与联系"></a>3. TCP和UDP的区别与联系</h1><ul><li><p>相同点：都是基于IP协议的传输协议。</p></li><li><p>不同点：</p><ul><li><p>TCP: 面向连接，传输速度慢，可靠性高（TCP在传输数据之前，都会通过三次握手来建立连接），保证数据的准确性，面向字节流</p></li><li><p>UDP: 面向无连接，传输速度快，可靠性低（尽最大可能交付，如果网络质量不好，就可能丢包），面向报文</p></li></ul></li><li><p>使用场景：</p><ul><li>TCP：对通信质量有要求的时候，比如：Http、https、FTP等传输文件的协议，SMTP等传输邮件的协议。kafka中服务端和客户端之间的通信。</li><li>UDP: 通信质量要求不高，但是要求网络通讯速度尽可能快，比如：QQ语音，QQ视频</li></ul></li><li><p>TCP存在拆包，粘包问题。因为他是面向字节流的，不向UDP那样首部有数据长度，而发送数据，是缓冲区满才会发送，容易造成粘包。接受数据，是缓冲区满了，才会接受，接受时也会造成粘包。</p><ul><li>解决拆包和粘包问题的方式：<ul><li>发送端给数据加首部</li><li>设置数据包为制定长度，不够用空格来补</li><li>给数据加分界标记</li></ul></li></ul></li></ul><h1 id="4-HTTP的长连接和短连接"><a href="#4-HTTP的长连接和短连接" class="headerlink" title="4. HTTP的长连接和短连接"></a>4. HTTP的长连接和短连接</h1><ul><li>http的长连接和短连接本质上就是：Tcp的长连接和短连接</li><li>在http1.0 中默认使用短连接，客户端和服务端每进行一次HTTP操作，就建立一次短连接，任务结束就中断。从HTTP1.0 起，默认使用长连接，当一个网页打开完成后，客户端和服务器之间用户传输HTTP数据的TCP连接就不会关闭，客户端再次访问这个服务器，会使用这一条已经建立的连接。可以设置这个保持时间。</li><li>通过心跳机制维护长连接，客户端发送一个心跳给服务器，服务器给客户一个心跳应答，这样双方就可以知道他们的连接没有断开。</li></ul><p><strong>应用场景：</strong></p><ul><li>长连接：多用于操作频繁，点对点的通讯。</li><li>短连接：web网站的Http服务一般都使用短连接，因为长连接比较耗费资源。</li></ul><h1 id="5-HTTP和HTTPs的区别"><a href="#5-HTTP和HTTPs的区别" class="headerlink" title="5. HTTP和HTTPs的区别"></a>5. HTTP和HTTPs的区别</h1><ul><li><p>Http明文传输，数据都是未加密的，安全性比较差，https（ssl+http）传输过程是加密的，安全性较好，采用混合加密算法。</p></li><li><p>Http使用80端口，https使用的是443端口</p></li><li><p>https协议需要到CA（Certificate Authority，数字证书认证机构）去申请证书，一般免费证书比较少，需要一定的费用。</p></li><li><p>https除了TCP连接响应外，还要进行SSL通信，所以通信速率较低且由于加密解密，也会消耗更多的服务器资源。</p><blockquote><ul><li><p>SSL是独立与TCP的协议，他也可用来对其他协议的加密</p></li><li><p>Https 其实就是在HTTP协议的基础上加了：通信加密，证书认证，报文完整性保护，他在所以HTTPS要比HTTP更加耗费资源。</p></li></ul></blockquote></li></ul><h1 id="6-加密方式"><a href="#6-加密方式" class="headerlink" title="6 加密方式"></a>6 加密方式</h1><h4 id="对称加密："><a href="#对称加密：" class="headerlink" title="对称加密："></a>对称加密：</h4><ul><li>定义：服务器和客户端都拥有一把相同的钥匙，对报文的加密和解密都用的是这把钥匙。</li><li>流程：刚开始的时候B没有钥匙，A有，那A需要将钥匙发给B，在这个过程中一旦钥匙被攻击者X获取到，加密就失了意义。</li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul><li>定义：一把共有密钥，一把私有密钥。公有密钥是公开的，任何人都可以获取，私有的不公开。发送方用公有密钥进行加密，接受方用私有密钥解密。</li><li>流程：刚开始的时候A拥有一把私有密钥和一把公有公钥，B没有公钥匙，A将公钥发给B，再将通过私有密钥加密后的内容发给B，即使攻击者窃取也只能拿到公钥和加密后的明文，所以比较安全，但是性能比较低。</li></ul><h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><ul><li>http首先通过非对称加密来对对称密钥加密，当对称密钥安全传输后，双方则采取对称密钥的方式来进行传输。</li></ul><h1 id="7-cookie-和session-的区别和联系"><a href="#7-cookie-和session-的区别和联系" class="headerlink" title="7 cookie 和session 的区别和联系"></a>7 cookie 和session 的区别和联系</h1><ul><li>session是存储在服务器端的，cookie是存储在客户端的。</li><li>cookie不是很安全，因为别人可以分析你存放在本地的cookie进行cookie欺骗，考虑到安全应该放到session。</li><li>由于session存放在服务器上，所以当访问增多的时候，会比较占用服务器的性能，考虑到服务器性能，</li><li>session一般是通过cookie来实现会话跟踪的。第一次创建session的时候，服务器告诉客户端需要在cookie里记录一个session_id&#x3D;XX，之后客户端通过http请求来访问服务端的时候，都在请求里带上这个session_id，就可以告诉服务器我是谁了。如果客户端禁用cookie，就需要通过url重写的方式来记录，就是URL上附加一个sid&#x3D;XXX，这样服务器就知道你是谁了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三次握手</title>
    <link href="/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <url>/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><ol><li><p>定义：三次握手，顾名思义，就是客户端与服务端的三次通信</p></li><li><p>流程：</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57al19dnpj211a0u077e.jpg" style="zoom:50%;" /></li></ol><ul><li>第一次握手：建立连接。客户端发送请求连接报文段，然后客户端进入SYN_SEND（连接请求）状态，等待服务端的确认。</li><li>第二次握手：服务端收到客户端的SYN报文段，对这个报文段进行确认，同时，自己还要发送请求建立连接信息，服务端要将所有的信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务端进入SYN_RCVD（接受请求）状态。</li><li>第三次握手：客户端收到服务端的SYN+ACK报文段。向服务端发送ACK报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISH状态，完成TCP三次握手。</li></ul><ol start="3"><li>为什么要进行三次握手？</li></ol><p>三次握手的目的就是：建立可靠的通信渠道。确认双方的发送和接收都是正常的。</p><ul><li>第一次握手：客户端什么都不能确认，服务端能确认客户端发送数据是正常的，自己接受数据正常的。</li><li>第二次握手：客户端可以确认自己：接受和发送数据都是正常的， 服务端发送数据，接受数据是正常的。</li><li>第三次握手：服务端可以确认自己发送和接受正常，客户端发送和接受正常。</li></ul><p>假设不考虑三次握手，会出现的一种情况是：</p><p>已经实效的报文段突然传送到了主机B，因而产生错误。</p><p>考虑这样一种情况：当A发送连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次。第二个报文段到达了主机B，收到了确认，建立了连接。传输完毕后，就释放连接。       </p><p>   现假定出现另一种情况：A发送的第一个请求报文段并没有丢失，而是在某些网点滞留时间太长，以致延误到这次的连接释放后才到大主机B，本来这已经是一个已经失效的报文段，但主机B收到这个报文段，却误认为主机A又发送了一次新的请求，于是向A发送确认报文段，同意建立连接。</p><p>  主机A并没有要求建立连接，因此不会理睬主机B的确认，也不会向主机B发送数据，但主机B却以为连接已经建立，并且一直等待主机A发送数据，于是主机B的许多资源就这样被浪费了。</p><p>   而如果采用了三次连接就可以防止以上现象的发生。例如在刚才的情况下，主机A不会再向主机B的确认发送确认。主机B收不到确认，就建立不了连接。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四次挥手</title>
    <link href="/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><ol><li><p>定义：四次挥手就是客户端和服务端释放连接时的四个步骤。</p></li><li><p>产生原因：TCP连接是全双工的，因此每个方向都需要单独关闭，一方发送FIN只表示自己发完了要发送的数据。</p></li><li><p>流程：</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h578ibfbfnj20yk0qeq6p.jpg" style="zoom:50%;" /><ol><li><p>第一次挥手：当客户端不再向服务端发送数据了。客户端先向TCP发出连接释放请求，TCP通知服务端需要释放从客户端到服务端的这个连接，客户端进入FIN_WAIT-1 （终止等待状态）。</p></li><li><p>第二次挥手：服务端收到客户端的释放连接请求后，立即释放连接。这样客户端到服务端的连接就释放了，服务端进入CLOSE_WAIT（半关闭状态）。相当于客户端对服务端说：我已经发完了我要发的数据，但仍然可以接收你发的数据。</p></li><li><p>第三次挥手：当服务端不再向客户端发送数据了。服务端先向TCP发出连接释放请求，TCP通知客户端需要释放从服务端到客户端的这个连接，服务端进入LAST_WAIT（最后确认状态）。</p></li><li><p>第四次挥手：客户端收到服务端的释放请求后，进入2MSL（一个报文的来回时间）的TIME_WAIT（时间等待）状态，接着发送一个ACK给服务端，服务端进入CLOSE（关闭状态）整个连接全部释放。客户端在2MSL的TIME_WAIT后进入CLOSE状态。</p></li></ol></li></ol><p><strong>以上释放过程是4次联络，也可以看成2个2次联络。</strong></p><ol start="4"><li><p>TIME_WAIT的状态必须等待2MSL的原因？</p><ul><li><p>保证当客户端最后一个ACK丢失后，能收到服务端重传的FIN包。这个ACK报文段可能丢失，因而处于LAST_ACK状态的B可能收不到对已发送的FIN+ACK报文段的确认，服务端会超时重传这个报文段，则客户端就可以在2MSL这个时间内收到这个重传的FIN+ACK报文段。接着客户端会重传一次确认，然后启动2MSL计时器。</p></li><li><p>如果客户端在TIME_WAIT这个状态不等待一段时间，而是在发送ACK报文段后立即释放连接，那么就无法收到服务端重传的FIN+ACK报文段，因而也不会再发送一次确认报文段，B则无法按正常步骤进入CLOSED状态。（注：TIME_WAIT状态一般维持在1-4分钟）</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态代理的实现方式</title>
    <link href="/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>User_setting 的表结构(last_visted_project_id)+ 切面(el-&gt; app -&gt;) </p><p>动态代理： c g li b+ jdk</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">InvocationHandler</span> ： 该类必须有接口<br></code></pre></td></tr></table></figure><p> c g li b：Enhancer ：是基于<strong>父子类</strong>的，被代理类（UserService）是父类，代 </p><p>理类是子类，代理对象就是代理类的实例对象</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">invoke</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 持久化</title>
    <link href="/Kafka%20%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/Kafka%20%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Kafka-持久化"><a href="#1-Kafka-持久化" class="headerlink" title="1 Kafka 持久化"></a>1 Kafka 持久化</h1><ul><li>每个 Topic 将消息分成多 Partition，每个 Partition 在存储层面是 append log 文件。</li><li>任何发布到此 Partition 的消息都会被直接追加到 log 文件的尾部，每条消息在文件中的位置称为 Offest（偏移量）</li><li>Partition 是以文件的形式存储在文件系统中</li><li>log 文件根据 Broker 中的配置保留一定时间后删除来释放磁盘空间。</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228234231530.png" alt="image-20230228234231530"></p>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka入门</title>
    <link href="/kafka%E5%85%A5%E9%97%A8/"/>
    <url>/kafka%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-kafka-是什么？"><a href="#1-kafka-是什么？" class="headerlink" title="1 kafka 是什么？"></a>1 kafka 是什么？</h1><p>Kafka 是一个分布式，支持分区（partition）, 多副本（replication）,基于zookeeper 的分布式消息系统。它最大的特性就是可以实时的处理大数据量。</p><p>Kafka的使用场景：</p><ul><li>日志的收集：记录各种服务的log。，通过kafka以统一接口服务的方式开放给各种 consumer，例如hadoop、Hbase、Solr等。</li><li>消息系统：解耦和生产者和消费者、缓存消息等。</li><li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和掘。</li><li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li></ul><h1 id="2-kafka-的整体设计"><a href="#2-kafka-的整体设计" class="headerlink" title="2 kafka 的整体设计"></a>2 kafka 的整体设计</h1><p>从一个较高的层面上来看，producer通过网络发送消息到Kafka集群，然后consumer来进行消费，如下图</p><blockquote><p>服务端(brokers)和客户端(producer、consumer)之间通信通过<strong>TCP协议</strong>来完成。 </p></blockquote><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231340194.png" alt="image-20230228231340194"></p><p>还有几个概念：</p><ul><li><p>Producer: 消息生产者，向Broker发送消息的客户端 。</p></li><li><p>Broker: 消息中间件处理节点，一个Kafka实例就是一个broker，一个或者多个Broker可以组成一个Kafka集群。</p></li><li><p>Topic：Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic ，类似activeMq的queue</p></li><li><p>Partition: 一个topic可以分为多个partition，每个 partition内部消息是有序的.</p></li><li><p>ConsumerGroup:每个Consumer属于一个特定的Consumer Group，一条消息可以被多个不同的Consumer Group消费，但是一个 </p><p>Consumer Group中只能有一个Consumer能够消费该消息</p></li><li><p>Consumer: 消息消费者，从Broker读取消息的客户端</p></li></ul><h1 id="3-Kafka-的基本使用"><a href="#3-Kafka-的基本使用" class="headerlink" title="3 Kafka 的基本使用"></a>3 Kafka 的基本使用</h1><ol><li><p>启动zookeeper <a href="https://pyr9.github.io/2021/09/22/zookeeper%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/">zookeeper特性与节点介绍 - 楼上有只喵 (pyr9.github.io)</a></p></li><li><p>下载并解压： <a href="https://kafka.apache.org/downloads">Apache Kafka</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cd kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure></li><li><p>修改配置文件config&#x2F;server.properties，根据需要修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">broker.id=<span class="hljs-number">0</span>     <span class="hljs-comment">//如果是单机安装则不用修改，如果是集群安装则要保证每个broker.id配置不同的值</span><br>log.dirs=/Tools/kafka_2<span class="hljs-number">.13</span>-<span class="hljs-number">2.4</span><span class="hljs-number">.1</span>/logs    <span class="hljs-comment">//日志位置，该文件夹必须存在，否则启动时会报错</span><br>zookeeper.connect=localhost:<span class="hljs-number">2181</span>     <span class="hljs-comment">//zookeeper的连接地址，多个地址用逗号分隔</span><br></code></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">bin/kafka-server-start.sh -daemon  config/server.properties<br></code></pre></td></tr></table></figure><ul><li>server.properties的配置路径是一个强制的参数</li><li>­daemon表示以后台进程运行</li></ul><p><strong>我们进入zookeeper目录通过zookeeper客户端查看下zookeeper的目录树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">2</span>] ls /<br>[admin, brokers, cluster, config, consumers, controller, controller_epoch, feature, isr_change_notification, latest_producer_id_block, log_dir_event_notification, zookeeper]<br></code></pre></td></tr></table></figure><p><strong>查看kafka节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">3</span>]  ls /brokers/ids<br>[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li><li><p>停止服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">bin/kafka‐server‐stop.sh<br></code></pre></td></tr></table></figure></li><li><p>创建主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --create --topic test --bootstrap-server localhost:<span class="hljs-number">9092</span><br>Created topic test.<br></code></pre></td></tr></table></figure></li><li><p>查看kafka中目前存在的topic </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span>  bin/kafka-topics.sh --list --bootstrap-server localhost:<span class="hljs-number">9092</span><br>test<br></code></pre></td></tr></table></figure></li><li><p>发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-console-producer.sh --topic test --bootstrap-server localhost:<span class="hljs-number">9092</span><br>&gt;my first event<br>&gt;my second event<br></code></pre></td></tr></table></figure></li><li><p>消费消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-console-consumer.sh --topic test --from-beginning --bootstrap-server localhost:<span class="hljs-number">9092</span><br><br>my first event<br>my second event<br></code></pre></td></tr></table></figure><blockquote><p>–from-beginning 可选，加上的话，就可以收到历史已经发送的数据。默认不加的话，是消费最新的消息</p></blockquote></li><li><p>单播消费</p><ul><li>一条消息只能被某一个消费者消费的模式。类似queue模式。</li><li>只需让所有消费者在同一个消费组里即可。</li></ul><p>分别在两个客户端执行如下消费命令，然后往主题里发送消息，结果只有一个客户端能收到消息 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-console-consumer.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --consumer-property group.id=group1 --topic test<br></code></pre></td></tr></table></figure></li><li><p>多播消费</p><ul><li>一条消息能被多个消费者消费的模式，类似publish-subscribe模式。</li><li>针对Kafka同一条消息只能被同一个消费组下的某一个消费者消费的特性，要实现多播只要保证这些消费者属于不同的消费组即可。</li><li>我们再增加一个消费者，该消费者属于group2消费组，结果两个客户端都能收到消息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java'">➜  kafka_2.12-3.2.1 bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --consumer-property group.id=group2 --topic test<br></code></pre></td></tr></table></figure></li><li><p>查看消费组名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-consumer-groups.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --list<br>testGroup1<br>group2<br>group1<br></code></pre></td></tr></table></figure></li><li><p>查看消费组的消费偏移量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-consumer-groups.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --describe --group group1<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231400113.png" alt="image-20230228231400113"></p><ul><li>current-offset：当前消费组的已消费偏移量</li><li>log-end-offset：主题对应分区消息的结束偏移量(HW) </li><li>lag：当前消费组未消费的消息数</li></ul></li></ol><h1 id="4-Topic-和-partition-详解"><a href="#4-Topic-和-partition-详解" class="headerlink" title="4 Topic 和 partition 详解"></a>4 Topic 和 partition 详解</h1><ul><li><p>topic 是一个类别的名称，同类消息，发送到一个topic下，对于每一个topic可以有多个分区(partition)。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231408951.png" alt="image-20230228231408951"></p></li><li><p>partition 是一个有序的message序列，这些message将按顺序添加到commitlog文件中。一个partition 对应一个commit log 文件，对应存放在配置的log文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> cd /tmp/kafka-logs<br>➜  kafka-logs cd test-<span class="hljs-number">0</span><br>➜  test-<span class="hljs-number">0</span> ls<br><span class="hljs-number">00000000000000000000.</span>index     <span class="hljs-number">00000000000000000000.</span>timeindex partition.metadata<br><span class="hljs-number">00000000000000000000.</span>log       leader-epoch-checkpoint<br>➜  test-<span class="hljs-number">0</span> cat <span class="hljs-number">00000000000000000000.</span>log<br>F_:�����<span class="hljs-number">6</span>����<span class="hljs-number">6</span>�(my first eventG�����������*my second event&gt;I=;���R����R�<br></code></pre></td></tr></table></figure></li><li><p>每个partion 中的消息都有一个唯一的编号，叫做offset，用来标识这条消息。</p></li><li><p>创建多个分区的主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --create --topic test2 --bootstrap-server localhost:<span class="hljs-number">9092</span> ‐‐replication‐factor <span class="hljs-number">1</span> ‐‐partitions <span class="hljs-number">2</span><br>Created topic test2.<br></code></pre></td></tr></table></figure></li></ul><h1 id="5-Kafka副本集"><a href="#5-Kafka副本集" class="headerlink" title="5 Kafka副本集"></a>5 <strong>Kafka副本集</strong></h1><ul><li>Kafka副本集是指将日志复制多份，我们知道Kafka的数据是存储在日志文件中的，这就相当于数据的备份、冗余</li><li>Kafka可以为每个Topic设置副本集，Kafka中的Topic只是个逻辑概念，实际存储数据的是Partition，所以真正被复制的也是Partition，副本集是相对于Partition来说的</li><li>一个Topic的副本集可以分布在多个Broker中，当一个Broker挂掉了，其他的Broker上还有数据，这就提高了数据的可靠性，这也是副本集的主要作用。</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231420153.png" alt="image-20230228231420153"></p><ul><li>查看下topic的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --describe --topic test2<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231430788.png" alt="image-20230228231430788"></p><ul><li>leader节点负责给定partition的所有读写请求。</li><li>replicas 表示某个partition在哪几个broker上存在备份。不管这个几点是不是”leader“，甚至这个节点挂了，也会列出。</li><li>isr**(InSyncRepli)** ：leader副本保持一定同步程度的副本（包括leader）组成ISR。是replicas的一个子集。</li></ul><h1 id="6-Kafka节点故障原因及处理方式"><a href="#6-Kafka节点故障原因及处理方式" class="headerlink" title="6 Kafka节点故障原因及处理方式"></a>6 <strong>Kafka节点故障原因及处理方式</strong></h1><p>Kafka节点（Broker）故障的两种情况：</p><ul><li>Kafka节点与Zookeeper心跳未保持视为节点故障</li><li>当follower的消息落后于leader太多也会视为节点故障</li></ul><p>Kafka对节点故障的处理方式：</p><ul><li>Kafka会对故障节点进行移除，所以基本不会因为节点故障而丢失数据</li><li>Kafka的语义担保也很大程度上避免了数据丢失</li><li>Kafka会对消息进行集群内平衡，减少消息在某些节点热度过高</li></ul>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka集群</title>
    <link href="/kafka%E9%9B%86%E7%BE%A4/"/>
    <url>/kafka%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="kafka-集群"><a href="#kafka-集群" class="headerlink" title="kafka 集群"></a>kafka 集群</h1><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><ul><li><p>Kafka集群依赖于Zookeeper进行协调，Kafka节点只要注册到同一个Zookeeper上就代表它们是同一个集群的</p></li><li><p>Kafka通过brokerId来区分集群中的不同节点</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231625775.png" alt="image-20230228231625775"></p></li></ul><h1 id="2-Kafka集群中的几个角色："><a href="#2-Kafka集群中的几个角色：" class="headerlink" title="2 Kafka集群中的几个角色："></a>2 <strong>Kafka集群中的几个角色：</strong></h1><ul><li>Broker：一般指Kafka的部署节点</li><li>Leader：用于处理消息的接收和消费等请求，也就是说producer是将消息push到leader，而consumer也是从leader上去poll消息</li><li>Follower：主要用于备份消息数据，一个leader会有多个follower，不提供读写(主要是为了保证多副本数据与消费的一致性）。如果这个leader失效了，其中的一个follower将会自动的变成新的leader。</li></ul><h1 id="3-kafka配置中request-required-acks"><a href="#3-kafka配置中request-required-acks" class="headerlink" title="3 kafka配置中request.required.acks"></a>3 kafka配置中request.required.acks</h1><p><strong>Kafka通过配置request.required.acks属性来确认消息的生产</strong></p><ul><li>0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的，存在丢消息：数据还没写入leader，leader就挂了</li><li>1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。</li><li>-1或all producer需要等待ISR中的所有副本都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有副本都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。这种性能不高，一般是金融级别或者和钱打交道的时候采用。</li></ul><p><strong>避免消息丢失就可以将ack设置成-1或all</strong></p><h1 id="4-producer-的写入流程"><a href="#4-producer-的写入流程" class="headerlink" title="4 producer 的写入流程"></a>4 producer 的写入流程</h1><ol><li>producer 先从 zookeeper 的 “&#x2F;brokers&#x2F;…&#x2F;state” 节点找到该 partition 的 leader </li><li>producer 将消息发送给该 leader </li><li>leader 将消息写入本地 log </li><li>followers 从 leader pull  消息，写入本地 log 后 leader 发送 ACK </li><li>leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset） 并向 producer 发送 ACK</li></ol><h1 id="5-Partition副本选举Leader机制"><a href="#5-Partition副本选举Leader机制" class="headerlink" title="5 Partition副本选举Leader机制"></a>5 Partition副本选举Leader机制</h1><ul><li>如果有接触过其他一些分布式组件就会了解到大部分组件都是通过投票选举来在众多节点中选举出一个leader，但在Kafka中没有采用投票选举来选举leader</li><li>Kafka会动态维护一组Leader数据的副本（ISR）</li><li>Kafka会在ISR列表里挑第一个broker作为leader(第一个broker最先放进ISR列表，可能是同步数据最多的副本)</li></ul><p>Kafka有一种无奈的情况，就是ISR中副本全部宕机。对于这种情况，Kafka默认会进行unclean leader选举。Kafka提供了两种不同的方式进行处理：</p><ol><li>等待ISR中任一Replica恢复，并选它为Leader</li></ol><ul><li>等待时间较长，会降低可用性，或ISR中的所有Replica都无法恢复或者数据丢失，则该Partition将永不可用</li></ul><ol><li>选择第一个恢复的Replica为新的Leader，无论它是否在ISR中</li></ol><ul><li>并未包含所有已被之前Leader Commit过的消息，因此会造成数据丢失，但可用性较高</li></ul><h1 id="6-Controller"><a href="#6-Controller" class="headerlink" title="6 Controller"></a>6 Controller</h1><p>在kafka集群启动的时候，会自动选举一台broker作为controller，它负责管理整个集群中所有分区和副本的状态。</p><ul><li>当某个分区的leader副本出现故障时，由控制器负责为该分区<strong>选举新的leader</strong>副本。</li><li>当检测到某个分区的ISR集合发生变化时，由控制器负责<strong>通知所有broker更新其元数据信息</strong>。</li><li>当使用kafka-topics.sh脚本为某个topic<strong>增加分区数量</strong>时，同样还是由控制器负责让新分区被其他节点感知到。</li></ul><h1 id="7-Controller选举机制"><a href="#7-Controller选举机制" class="headerlink" title="7 Controller选举机制"></a>7 Controller选举机制</h1><ul><li>集群中每个broker都会尝试在zookeeper上创建一个 &#x2F;controller 临时节点</li><li>zookeeper会保证有且仅有一个broker能创建成功，这个broker就会成为集群的总控器controller</li><li>当这个controller角色的broker宕机了，此时zookeeper临时节点会消失，集群里其他broker会一直监听这个临时节点，发现临时节点消失了，就竞争再次创建临时节点</li></ul><h1 id="3-集群配置流程"><a href="#3-集群配置流程" class="headerlink" title="3 集群配置流程"></a>3 集群配置流程</h1><ol><li><p>编写配置文件</p><ul><li><p><code>vim config/server.properties</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">broker</span>.id=<span class="hljs-number">0</span>     //如果是单机安装则不用修改，如果是集群安装则要保证每个broker.id配置不同的值<br><span class="hljs-attribute">listeners</span>=PLAINTEXT://localhost:<span class="hljs-number">9092</span> <br><span class="hljs-attribute">log</span>.dirs=/Tools/kafka_<span class="hljs-number">2</span>.<span class="hljs-number">13</span>-<span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>/logs    //日志位置，该文件夹必须存在，否则启动时会报错<br><span class="hljs-attribute">zookeeper</span>.connect=localhost:<span class="hljs-number">2181</span>     //zookeeper的连接地址，多个地址用逗号分隔<br></code></pre></td></tr></table></figure></li></ul></li><li><p>建立好其他2个broker的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">cp config/server.properties config/server‐<span class="hljs-number">1.</span>properties<br>cp config/server.properties config/server‐<span class="hljs-number">2.</span>properties<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">broker</span>.id=<span class="hljs-number">1</span>     //如果是单机安装则不用修改，如果是集群安装则要保证每个broker.id配置不同的值<br><span class="hljs-attribute">listeners</span>=PLAINTEXT://localhost:<span class="hljs-number">9093</span> <br><span class="hljs-attribute">log</span>.dirs=/Tools/kafka_<span class="hljs-number">2</span>.<span class="hljs-number">13</span>-<span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>/logs-<span class="hljs-number">1</span>    //日志位置，该文件夹必须存在，否则启动时会报错<br><span class="hljs-attribute">zookeeper</span>.connect=localhost:<span class="hljs-number">2181</span>     //zookeeper的连接地址，多个地址用逗号分隔<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">broker</span>.id=<span class="hljs-number">2</span>     //如果是单机安装则不用修改，如果是集群安装则要保证每个broker.id配置不同的值<br><span class="hljs-attribute">listeners</span>=PLAINTEXT://localhost:<span class="hljs-number">9094</span> <br><span class="hljs-attribute">log</span>.dirs=/Tools/kafka_<span class="hljs-number">2</span>.<span class="hljs-number">13</span>-<span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>/logs-<span class="hljs-number">2</span>    //日志位置，该文件夹必须存在，否则启动时会报错<br><span class="hljs-attribute">zookeeper</span>.connect=localhost:<span class="hljs-number">2181</span>     //zookeeper的连接地址，多个地址用逗号分隔<br></code></pre></td></tr></table></figure></li><li><p>分别启动broker实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-server-start.sh -daemon config/server.properties<br>➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-server-start.sh -daemon config/server-<span class="hljs-number">1.</span>properties<br>➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-server-start.sh -daemon config/server-<span class="hljs-number">2.</span>properties<br></code></pre></td></tr></table></figure></li><li><p>查看zookeeper确认集群节点是否都注册成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">19</span>]  ls /brokers/ids<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure></li></ol><h2 id="集群使用"><a href="#集群使用" class="headerlink" title="集群使用"></a>集群使用</h2><ol><li><p>创建一个新的topic，副本数设置为3，分区数设置为2： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --create --replication-factor <span class="hljs-number">3</span> --partitions <span class="hljs-number">2</span> --topic test6<br></code></pre></td></tr></table></figure></li><li><p>查看下topic的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --describe --topic test6<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231644650.png" alt="image-20230228231644650"></p></li><li><p>向新建的 test6 中发送一些message，kafka集群可以加上所有kafka节点</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">➜  kafka_2.<span class="hljs-number">12</span>-<span class="hljs-number">3.2</span>.<span class="hljs-number">1</span>  bin/kafka-console-producer.<span class="hljs-keyword">sh</span> ‐‐broker‐<span class="hljs-keyword">list</span> localhos<span class="hljs-variable">t:9092</span>,localhos<span class="hljs-variable">t:9093</span>,localhos<span class="hljs-variable">t:9094</span> --topic test6  --bootstrap-server localhos<span class="hljs-variable">t:9092</span><br>&gt;my test msg <span class="hljs-number">1</span><br>&gt;my test msg <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>开始消费</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">➜  kafka_2.12-3.2.1 bin/kafka-console-consumer.<span class="hljs-keyword">sh</span> --topic test6 --from-beginning --<span class="hljs-keyword">bootstrap</span>-server localhost:9092,localhost:9093,localhost:9094<br>my <span class="hljs-keyword">test</span> msg 1<br>my <span class="hljs-keyword">test</span> msg 2<br></code></pre></td></tr></table></figure></li><li><p>测试容错性，目前broker2 是分区0的leader，现在将他kill</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> ps -ef|grep server‐<span class="hljs-number">2.</span>properties<br>➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> kill -<span class="hljs-number">9</span> <span class="hljs-number">80024</span><br></code></pre></td></tr></table></figure></li><li><p>再次查看topic的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --describe --topic test6<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231658763.png" alt="image-20230228231658763"></p><p>可以看到，此时分区0的leader变成了broker1，在isr中也已经没有了2号节点。</p></li></ol><p>  此时，依旧可以消费消息：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231708348.png" alt="image-20230228231708348"></p>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
      <tag>集群</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之Config+Bus</title>
    <link href="/springCloud%E4%B9%8BConfig-Bus/"/>
    <url>/springCloud%E4%B9%8BConfig-Bus/</url>
    
    <content type="html"><![CDATA[<h1 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h1><ul><li><p>在微服务架构的系统中，通常会使用<strong>轻量级的消息代理</strong>来构建一个公用的<strong>消息主题</strong>，并让系统中的所有实例都连接上来。由于该<strong>主题的消息会被所有实例监听和消费</strong>，所以称之为消息总线。</p></li><li><p>在总线上的各个实例，都可以方便的广播一些让其他连接在给主题实例上都知道的消息。</p></li></ul><h1 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h1><ul><li><p>Spring Cloud Bus 又被称为消息总线，它能够通过轻量级的消息代理（例如 RabbitMQ、Kafka 等）将微服务架构中的各个服务连接起来，实现广播状态更改、事件推送等功能，还可以实现微服务之间的通信功能。</p></li><li><p>目前 Spring Cloud Bus 支持两种消息代理：RabbitMQ 和 Kafka。</p></li></ul><h2 id="Spring-Cloud-Bus-的基本原理"><a href="#Spring-Cloud-Bus-的基本原理" class="headerlink" title="Spring Cloud Bus 的基本原理"></a>Spring Cloud Bus 的基本原理</h2><ul><li>Spring Cloud Bus 会使用一个轻量级的消息代理来构建一个公共的消息主题 Topic（默认为“springCloudBus”），<strong>这个 Topic 中的消息会被所有服务实例监听和消费</strong>。</li><li>当其中的一个服务刷新数据时，Spring Cloud Bus 会把信息保存到 Topic 中，这样监听这个 Topic 的服务就收到消息并自动消费。</li></ul><h2 id="Spring-Cloud-Bus-动态刷新配置的原理"><a href="#Spring-Cloud-Bus-动态刷新配置的原理" class="headerlink" title="Spring Cloud Bus 动态刷新配置的原理"></a>Spring Cloud Bus 动态刷新配置的原理</h2><ul><li><p>当 Git 仓库中的配置发生了改变，我们只需要向某一个服务（既可以是 Config 服务端，也可以是 Config 客户端）发送一个 POST 请求，Spring Cloud Bus 就可以通过消息代理通知其他服务重新拉取最新配置，以实现配置的动态刷新。</p></li><li><p>利用 Spring Cloud Bus 的特殊机制可以实现很多功能，其中配合 Spring Cloud Config 实现配置的动态刷新就是最典型的应用场景之一。</p></li></ul><h2 id="Spring-Cloud-Bus-整合Spring-Cloud-Config实现配置的动态刷新"><a href="#Spring-Cloud-Bus-整合Spring-Cloud-Config实现配置的动态刷新" class="headerlink" title="Spring Cloud Bus 整合Spring Cloud Config实现配置的动态刷新"></a>Spring Cloud Bus 整合Spring Cloud Config实现配置的动态刷新</h2><ol><li>当 Git 仓库中的配置发生改变后，运维人员向 Config 服务端发送一个 POST 请求，请求路径为“&#x2F;actuator&#x2F;refresh”。</li><li>Config 服务端接收到请求后，会将该请求转发给服务总线 Spring Cloud Bus。</li><li>Spring Cloud Bus 接到消息后，会通知给所有 Config 客户端。</li><li>Config 客户端接收到通知，请求 Config 服务端拉取最新配置。</li><li>所有 Config 客户端都获取到最新的配置。</li></ol>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud集成consul</title>
    <link href="/SpringCloud%E9%9B%86%E6%88%90consul/"/>
    <url>/SpringCloud%E9%9B%86%E6%88%90consul/</url>
    
    <content type="html"><![CDATA[<h1 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h1><ul><li><p>Consul 是一套开源的分布式服务发现和配置管理系统，由HashCorp公司用Go语言开发</p></li><li><p>它提供了几个关键功能：</p><ul><li>服务发现：Consul client 可以提供服务，例如api或mysql，也可以使用Consul client来发现指定服务的提供者。 使用DNS或HTTP，应用程序可以轻松找到他们所依赖的服务。</li><li>健康检查：Consul client 可以提供任何数量的健康检查，或者与给定的服务（“Web服务器是否返回200 OK”），或与本地节点（“内存利用率是否低于90％”）相关联。 可以使用此信息来监控集群运行状况，服务发现组件使用此信息将流量从有问题的主机中移除出去。</li><li>KV Store：应用程序可以使用Consul的分层键&#x2F;值存储，包括动态配置，功能标记，协调，leader选举等等。 简单的HTTP API使其易于使用。</li><li>多数据中心：Consul支持多个数据中心。 这意味着Consul的用户不必担心构建额外的抽象层以扩展到多个区域。</li></ul></li><li><p>使用场景</p><p>Consul的应用场景包括服务发现、服务隔离、服务配置：</p><ul><li><p>服务发现场景中consul作为注册中心，服务地址被注册到consul中以后，可以使用consul提供的dns、http接口查询，consul支持health check。</p></li><li><p>服务隔离场景中consul支持以服务为单位设置访问策略，能同时支持经典的平台和新兴的平台，支持tls证书分发，service-to-service加密。</p></li><li><p>服务配置场景中consul提供key-value数据存储功能，并且能将变动迅速地通知出去，通过工具consul-template可以更方便地实时渲染配置文件。</p></li></ul></li></ul><h1 id="SpringCloud集成consul"><a href="#SpringCloud集成consul" class="headerlink" title="SpringCloud集成consul"></a>SpringCloud集成consul</h1><p><a href="https://www.springcloud.cc/spring-cloud-consul.html">Spring Cloud Consul 中文文档 参考手册 中文版</a></p><h2 id="1-consul-安装和启动"><a href="#1-consul-安装和启动" class="headerlink" title="1. consul 安装和启动"></a>1. consul 安装和启动</h2><p>参考<a href="https://learn.hashicorp.com/tutorials/consul/get-started-install">Install Consul | Consul - HashiCorp Learn</a></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">➜  ~ consul agent -<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>访问<a href="http://localhost:8500/">http://localhost:8500/</a></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232955363.png" alt="image-20230228232955363"></p><h2 id="2-引入依赖"><a href="#2-引入依赖" class="headerlink" title="2. 引入依赖"></a>2. 引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml">plugins&#123;<br>id &#x27;org.springframework.boot&#x27; version &#x27;2.6.1&#x27;<br>id &#x27;io.spring.dependency-management&#x27; version &#x27;1.0.8.RELEASE&#x27;<br>id &#x27;java&#x27;<br>&#125;<br><br>ext &#123;<br>set(&#x27;springCloudVersion&#x27;, &quot;2021.0.0&quot;)<br>name = &#x27;Eureka Server&#x27;<br>description = &#x27;Eureka Server demo project&#x27;<br>version=&#x27;0.0.1-SNAPSHOT&#x27;<br>sourceEncoding=&#x27;UTF-8&#x27;<br>&#125;<br><br>repositories &#123;<br>mavenCentral()<br>maven &#123; url &#x27;https://repo.spring.io/release/&#x27; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-snapshot-local&quot; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-milestone-local&quot; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-release-local&quot; &#125;<br>maven &#123; url &quot;https://repo.springsource.org/plugins-release&quot; &#125;<br>&#125;<br><br>dependencyManagement &#123;<br>imports &#123;<br>mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;<br>&#125;<br>&#125;<br><br>dependencies &#123;<br>//consul 依赖<br>implementation &#x27;org.springframework.cloud:spring-cloud-starter-consul-discovery&#x27;<br>implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.  修改配置文件"></a>3.  修改配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=9091<br><br>spring.application.name= micro-weather-consul<br>spring.cloud.consul.host= localhost<br>spring.cloud.consul.port= 8500<br>spring.cloud.consul.discovery.service-name= $&#123;spring.application.name&#125;<br># 打开心跳机制<br>spring.cloud.consul.discovery.heartbeat.enabled= true<br></code></pre></td></tr></table></figure><h3 id="3-修改启动类"><a href="#3-修改启动类" class="headerlink" title="3. 修改启动类"></a>3. 修改启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>再次访问<a href="http://localhost:8500/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0micro-weather-consul%E6%9C%8D%E5%8A%A1%E5%B7%B2%E7%BB%8F%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F">http://localhost:8500/，可以看到micro-weather-consul服务已经注册成功</a></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228233006492.png" alt="image-20230228233006492"></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>注册中心</tag>
      
      <tag>consul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之Eureka集群搭建</title>
    <link href="/springCloud%E4%B9%8BEureka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/springCloud%E4%B9%8BEureka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="springCloud之Eureka集群搭建"><a href="#springCloud之Eureka集群搭建" class="headerlink" title="springCloud之Eureka集群搭建"></a>springCloud之Eureka集群搭建</h1><h2 id="1-搭建3个Eureka-server"><a href="#1-搭建3个Eureka-server" class="headerlink" title="1. 搭建3个Eureka server"></a>1. 搭建3个Eureka server</h2><ul><li><p>参考：<a href="https://pyr9.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (pyr9.github.io)</a></p></li><li><p>三个eureka-server的application.yml文件如下：</p><ul><li><p>eureka-server</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port: 8761<br><br>eureka.instance.hostname: localhost<br>#false表示不向注册中心注册自己。<br>eureka.client.registerWithEureka: false<br> #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务<br>eureka.client.fetchRegistry: false<br>#eureka.client.serviceUrl.defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/<br>eureka.client.serviceUrl.defaultZone: http://eureka8762.com:8762/eureka/,http://eureka8763.com:8763/eureka/<br></code></pre></td></tr></table></figure></li><li><p>eureka-server1</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port: 8762<br>spring.application.name = micro-weather-eureka-server2<br><br>eureka.instance.hostname: localhost<br>eureka.client.registerWithEureka: false<br>eureka.client.fetchRegistry: false<br>eureka.client.serviceUrl.defaultZone: http://eureka8761.com:8761/eureka/,http://eureka8763.com:8763/eureka/<br></code></pre></td></tr></table></figure></li><li><p>eureka-server2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port: 8763<br>spring.application.name = micro-weather-eureka-server1<br><br>eureka.instance.hostname: localhost<br>eureka.client.registerWithEureka: false<br>eureka.client.fetchRegistry: false<br>eureka.client.serviceUrl.defaultZone: http://eureka8761.com:8761/eureka/,http://eureka8762.com:8762/eureka/<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-配置三个hostname"><a href="#2-配置三个hostname" class="headerlink" title="2.配置三个hostname"></a>2.配置三个hostname</h2><p>sudo vim &#x2F;etc&#x2F;hosts</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">127.0.0.1       eureka8761.com<br>127.0.0.1       eureka8762.com<br>127.0.0.1       eureka8763.com<br></code></pre></td></tr></table></figure><h2 id="3-启动三个eureka-server，并访问"><a href="#3-启动三个eureka-server，并访问" class="headerlink" title="3. 启动三个eureka-server，并访问"></a>3. 启动三个eureka-server，并访问</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231901993.png" alt="image-20230228231901993"></p><p>注意⚠️：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231913871.png" alt="image-20230228231913871"></p><ul><li><p>这里的意思就是这两个注册中心是当前注册中心的集群节点，当前注册中心会从这两个节点同步服务</p></li><li><p>这里是通过hostname辨别的，所以配置yml参数的时候需要配置不同的hostname。</p></li><li><p>这里有显示配置的集群节点，就证明集群配置成功了。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>eureka</tag>
      
      <tag>集群</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之集成zookeeper</title>
    <link href="/springCloud%E4%B9%8B%E9%9B%86%E6%88%90zookeeper/"/>
    <url>/springCloud%E4%B9%8B%E9%9B%86%E6%88%90zookeeper/</url>
    
    <content type="html"><![CDATA[<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><ul><li>zookeeper基本概念：<a href="https://pyr9.github.io/2021/09/22/zookeeper%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/">zookeeper特性与节点介绍 - 楼上有只喵 (pyr9.github.io)</a></li><li>zookeeper 是一个分布式协调服务，可以用来实现注册中心功能，类似eureka</li><li>服务节点是临时结点</li></ul><h1 id="springCloud之集成zookeeper"><a href="#springCloud之集成zookeeper" class="headerlink" title="springCloud之集成zookeeper"></a>springCloud之集成zookeeper</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>启动zookeeper</p><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml">plugins&#123;<br>id &#x27;org.springframework.boot&#x27; version &#x27;2.6.1&#x27;<br>id &#x27;io.spring.dependency-management&#x27; version &#x27;1.0.8.RELEASE&#x27;<br>id &#x27;java&#x27;<br>&#125;<br><br>ext &#123;<br>set(&#x27;springCloudVersion&#x27;, &quot;2021.0.0&quot;)<br>name = &#x27;Eureka Server&#x27;<br>description = &#x27;Eureka Server demo project&#x27;<br>version=&#x27;0.0.1-SNAPSHOT&#x27;<br>sourceEncoding=&#x27;UTF-8&#x27;<br>&#125;<br><br>repositories &#123;<br>mavenCentral()<br>maven &#123; url &#x27;https://repo.spring.io/release/&#x27; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-snapshot-local&quot; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-milestone-local&quot; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-release-local&quot; &#125;<br>maven &#123; url &quot;https://repo.springsource.org/plugins-release&quot; &#125;<br>&#125;<br><br>dependencyManagement &#123;<br>imports &#123;<br>mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;<br>&#125;<br>&#125;<br><br>dependencies &#123;<br>implementation &#x27;org.springframework.cloud:spring-cloud-starter-zookeeper-discovery&#x27;<br>implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27;<br>&#125;<br><br>test&#123;<br>useJUnitPlatform()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h2><ul><li>配置服务的名称和zookeeper的地址</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=9091<br><br>spring.application.name: micro-weather-zookeeper<br>spring.cloud.zookeeper.connect-string: localhost:2181<br></code></pre></td></tr></table></figure><h2 id="3-修改启动类"><a href="#3-修改启动类" class="headerlink" title="3. 修改启动类"></a>3. 修改启动类</h2><ul><li>加上@EnableDiscoveryClient注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-进入zookeeper客户端，查看已经注册的服务"><a href="#4-进入zookeeper客户端，查看已经注册的服务" class="headerlink" title="4.进入zookeeper客户端，查看已经注册的服务"></a>4.进入zookeeper客户端，查看已经注册的服务</h2><p>可以看到 micro-weather-zookeeper服务已经存在，SpringCloud以[Zookeeper]为注册中心整合成功</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228233716687.png" alt="image-20230228233716687"></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>注册中心</tag>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud集成Ribbon</title>
    <link href="/SpringCloud%E9%9B%86%E6%88%90Ribbon/"/>
    <url>/SpringCloud%E9%9B%86%E6%88%90Ribbon/</url>
    
    <content type="html"><![CDATA[<h1 id="负载均衡（load-balance）"><a href="#负载均衡（load-balance）" class="headerlink" title="负载均衡（load balance）"></a>负载均衡（load balance）</h1><ul><li>简单来说负载均衡就是将客户的请求平摊到多个服务上，从而达到系统的高可用，常用的负载均衡方式有Nginx，F5</li><li>常见的负载均衡方式有两种：<ul><li>服务端负载均衡</li><li>客户端负载均衡</li></ul></li></ul><h2 id="服务端负载均衡"><a href="#服务端负载均衡" class="headerlink" title="服务端负载均衡"></a>服务端负载均衡</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>服务端负载均衡是最常见的负载均衡方式，其工作原理如下图。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225113562.png" alt="image-20230228225113562"></p><ul><li>在客户端和服务端之间建立一个独立的负载均衡服务器，该服务器既可以是硬件设备（例如 F5），也可以是软件（例如 Nginx）</li><li>这个负载均衡服务器维护了一份可用服务端清单，然后通过心跳机制来删除故障的服务端节点，以保证清单中的所有服务节点都是可以正常访问的。</li><li>当客户端发送请求时，该请求不会直接发送到服务端进行处理，而是全部交给负载均衡服务器，由负载均衡服务器按照某种算法（例如轮询、随机等），从其维护的可用服务清单中选择一个服务端，然后进行转发。</li></ul><h3 id="服务端负载均衡的特点"><a href="#服务端负载均衡的特点" class="headerlink" title="服务端负载均衡的特点"></a>服务端负载均衡的特点</h3><p>服务端负载均衡具有以下特点：</p><ul><li>需要建立一个独立的负载均衡服务器。</li><li>负载均衡是在客户端发送请求后进行的，因此客户端并不知道到底是哪个服务端提供的服务。</li><li>可用服务端清单存储在负载均衡服务器上。</li></ul><h2 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h2><p>相较于服务端负载均衡，客户端服务是将负载均衡逻辑以代码的形式封装到客户端上</p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>客户端负载均衡的工作原理如下图。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225122260.png" alt="image-20230228225122260"></p><ul><li>客户端通过服务注册中心（例如 Eureka Server）获取到一份服务端提供的可用服务清单。</li><li>有了服务清单后，负载均衡器会在客户端发送请求前通过负载均衡算法（如简单轮训，随机连接等）选择一个服务端实例再进行访问</li><li>客户端负载均衡也需要心跳机制去维护服务端清单的有效性，这个过程需要配合服务注册中心一起完成。</li></ul><h3 id="客户端负载均衡的特点："><a href="#客户端负载均衡的特点：" class="headerlink" title="客户端负载均衡的特点："></a>客户端负载均衡的特点：</h3><ul><li><p>负载均衡器位于客户端，不需要单独搭建一个负载均衡服务器。</p></li><li><p>负载均衡是在客户端发送请求前进行的，因此客户端清楚地知道是哪个服务端提供的服务。</p></li><li><p>客户端都维护了一份可用服务清单，而这份清单都是从服务注册中心获取的。</p></li></ul><h2 id="Ribbon和Nginx实现负载均衡的区别"><a href="#Ribbon和Nginx实现负载均衡的区别" class="headerlink" title="Ribbon和Nginx实现负载均衡的区别"></a>Ribbon和Nginx实现负载均衡的区别</h2><ul><li>Ribbon 就是一个基于 HTTP 和 TCP 的客户端负载均衡器，当我们将 Ribbon 和 Eureka 一起使用时，Ribbon 会从 Eureka Server（服务注册中心）中获取服务端列表，然后通过负载均衡策略（如简单轮训，随机连接等），从服务端列表选择一个服务实例进行访问，从而达到负载均衡的目的。</li><li>而Nginx是服务端负载均衡，客户端的所有请求会交给Nginx，然后Nginx实现转发请求</li></ul><h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><ul><li>ribbon是Netflix开发的一款负载均衡的服务调用组件，具有多种负载均衡调用策略； </li><li>Ribbon 是 Spring Cloud Netflix 模块的子模块，它是 Spring Cloud 对 Netflix Ribbon 的二次封装。通过它，我们可以将面向服务的 RestTemplate请求转换为客户端负载均衡的服务调用。</li><li>简单来说，rubbon &#x3D; 负载均衡+ restTemplate</li></ul><h1 id="Ribbon-实现服务调用"><a href="#Ribbon-实现服务调用" class="headerlink" title="Ribbon 实现服务调用"></a>Ribbon 实现服务调用</h1><ol><li><p>搭建Eureka Client : <a href="https://pyr9.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (pyr9.github.io)</a></p></li><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">implementation &#x27;org.springframework.cloud:spring-cloud-starter-netflix-ribbon&#x27;<br></code></pre></td></tr></table></figure></li><li><p>修改application.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=8085<br>spring.application.name: micro-weather-eureka-client-ribbon<br>eureka.client.serviceUrl.defaultZone: http://localhost:8761//eureka/<br></code></pre></td></tr></table></figure></li><li><p>修改启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建一个名为 RestConfiguration 的配置类，将 RestTemplate 注入到容器中，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.config;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.client.RestTemplateBuilder;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfiguration</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RestTemplateBuilder restTemplateBuilder;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@LoadBalanced</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> restTemplateBuilder.build();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建一个CityController来实现通过restTemplate对服务的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CityController</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>  <span class="hljs-comment">//面向微服务编程，即通过微服务的名称来获取调用地址</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REST_URL_PREFIX = <span class="hljs-string">&quot;http://micro-weather-city-eureka&quot;</span>;<br><br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="hljs-string">&quot;/cities&quot;</span>, String.class);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>访问[localhost:8085&#x2F;cities，可以获取到指定服务接口的返回</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225138488.png" alt="image-20230228225138488"></p></li></ol><h1 id="Ribbon-实现负载均衡"><a href="#Ribbon-实现负载均衡" class="headerlink" title="Ribbon 实现负载均衡"></a>Ribbon 实现负载均衡</h1><p>java -jar msa-weather-city-eureka-0.0.1-SNAPSHOT.jar –server.port&#x3D;8084</p><p>java -jar msa-weather-city-eureka-0.0.1-SNAPSHOT.jar –server.port&#x3D;8083</p><p>java -jar msa-weather-city-eureka-0.0.1-SNAPSHOT.jar –server.port&#x3D;8086</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228233156385.png" alt="image-20230228233156385"></p><p>再次访问<a href="http://localhost:8085/cities">localhost:8085&#x2F;cities</a></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>负载均衡</tag>
      
      <tag>Ribbon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAP原则以及eureka和zookeeper的对比</title>
    <link href="/CAP%E5%8E%9F%E5%88%99%E4%BB%A5%E5%8F%8Aeureka%E5%92%8Czookeeper%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <url>/CAP%E5%8E%9F%E5%88%99%E4%BB%A5%E5%8F%8Aeureka%E5%92%8Czookeeper%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h1 id="1-CAP理论是什么？"><a href="#1-CAP理论是什么？" class="headerlink" title="1 CAP理论是什么？"></a>1 CAP理论是什么？</h1><p>CAP即：</p><ul><li>Consistency（一致性）：对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败，返回一个错误或超时，其强调的是数据正确。</li><li>Availability（可用性）：任何客户端的请求都能得到响应数据，不会出现响应错误，但不保证数据最新，强调的是不出错。比如我们购买商品时，他的点赞数就与购买商品无关，我们可以允许他不是最新的。</li><li>Partition tolerance（分区容忍性）：由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉。</li></ul><p>这三个性质对应了分布式系统的三个指标。而CAP理论说的就是：一个分布式系统，不可能同时做到这三点。分布式系统必须满足分区容错性，所以要么是AP,要么是CP。</p><h1 id="2-分布式CAP定理，为什么不能同时满足三个特性"><a href="#2-分布式CAP定理，为什么不能同时满足三个特性" class="headerlink" title="2 分布式CAP定理，为什么不能同时满足三个特性"></a>2 分布式CAP定理，为什么不能同时满足三个特性</h1><p>假设有两台服务器，一台放着应用A和数据库V，一台放着应用B和数据库V，他们之间的网络可以互通，也就相当于分布式系统的两个部分。</p><p>在满足一致性的时候，两台服务器(假设为N1,N2)的数据是一样的，DB0&#x3D;DB0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。</p><p>用户通过N1中的A应用请求数据更新到服务器DB0，这时N1中的服务器DB0变为DB1，通过分布式系统的数据同步更新操作，N2服务器中的数据库V0也更新为了DB1（图2），这时，用户通过B向数据库发起请求得到的数据就是即时更新后的数据DB1。</p><p>上面是正常运作的情况，但分布式系统中，最大的问题就是网络，现在假设一种极端情况，N1和N2之间的网络断开了，但我们仍要支持这种网络异常，也就是满足分区容错性，那么这样能不能同时满足一致性和可用性呢？</p><p>假设N1和N2之间通信的时候网络突然出现故障，有用户向N1发送数据更新请求，那N1中的数据DB0将被更新为DB1，由于网络是断开的，N2中的数据库仍旧是DB0；</p><p>如果这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据DB1，怎么办呢？有二种选择，第一，牺牲数据一致性，响应旧的数据DB0给用户；第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作完成之后，再给用户响应最新的数据DB1。</p><h1 id="3-作为服务中心，eureka和zookeeper的对比"><a href="#3-作为服务中心，eureka和zookeeper的对比" class="headerlink" title="3 作为服务中心，eureka和zookeeper的对比"></a>3 作为服务中心，eureka和zookeeper的对比</h1><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228233310740.png" alt="image-20230228233310740"></p><h2 id="3-1-集群方式不同"><a href="#3-1-集群方式不同" class="headerlink" title="3.1 集群方式不同"></a>3.1 集群方式不同</h2><ul><li><p>zookeeper集群是存在leader和follower关系的，也就是一主多从。</p></li><li><p>eureka集群中的各个节点是平等的地位，peer to peer对等通信。这是一种<strong>去中心化</strong>的架构，在这种架构风格中，节点通过彼此互相注册来提高可用性，每个节点都可被视为其他节点的副本</p></li></ul><h2 id="3-2-zookeeper-保证CP，eureka保证-AP"><a href="#3-2-zookeeper-保证CP，eureka保证-AP" class="headerlink" title="3.2 zookeeper 保证CP，eureka保证 AP"></a>3.2 zookeeper 保证CP，<strong>eureka保证 AP</strong></h2><ul><li><strong>Zookeeper保证 CP</strong>，在使用 Zookeeper 获取服务列表时，如果此时的 Zookeeper 集群中的 Leader 宕机了，该集群就要进行 Leader 的选举，<strong>选举是需要时间的，在这一段时间内，将无法处理请求</strong>。所以说，Zookeeper 不能保证服务可用性。</li><li><strong>eureka保证 AP</strong>，在Eureka平台中，如果某台服务器宕机，客户端请求会自动切换到新的Eureka节点，<strong>只要有一台Eureka还在，就能保证注册服务可用，只不过查到的信息可能不是最新的</strong>。当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。</li></ul><h2 id="3-3-zookeeper的实时性更好"><a href="#3-3-zookeeper的实时性更好" class="headerlink" title="3.3 zookeeper的实时性更好"></a>3.3 zookeeper的实时性更好</h2><p>eureka是通过心跳体制，检测节点是否正常，相比于zookeeper的watcher机制，实时性稍差一点</p><p><strong>正常情况下，为了满足用户体验，应该先选可用性。所以，理论上来说，Eureka作为系统服务的注册中心是最适合的。</strong></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>CAP原则</tag>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之自动扩展</title>
    <link href="/springCloud%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%89%A9%E5%B1%95/"/>
    <url>/springCloud%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是自动扩展？"><a href="#什么是自动扩展？" class="headerlink" title="什么是自动扩展？"></a>什么是自动扩展？</h1><p>自动扩展分为水平扩展和垂直扩展</p><ul><li>水平扩展就是一台机子不够了，就再搞几台</li><li>垂直扩展是硬件层面的，比如双核不够了，就4核</li></ul><h1 id="自动扩展的意义"><a href="#自动扩展的意义" class="headerlink" title="自动扩展的意义"></a>自动扩展的意义</h1><ul><li>提高了高可用性和容错能力。比如某个服务不可用了，自动扩展可以再增加一个新服务来替换他。</li><li>增加了可伸缩性。允许访问流量可以自动选择水平扩展的规模。</li><li>具有最佳使用率，并节约成本。按需使用，需要几台就部署几台</li><li>优先考虑某些服务或服务组。低优先级服务中实例移除，添加到高优先级的服务实例中。</li></ul><h1 id="自动扩展的常用方法"><a href="#自动扩展的常用方法" class="headerlink" title="自动扩展的常用方法"></a>自动扩展的常用方法</h1><ul><li>资源限制。比如Cpu使用率&gt;60%</li><li>特定时间段。指定时间去扩展</li><li>消息长度。消息队列的长度&gt; 设置的长度（此时队列里堆积的消息太多了）就去扩展</li><li>业务事件。比如新产生了10笔订单，就增加一个实例</li><li>根据预测<ul><li>历史信息</li><li>当前趋势</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>自动扩展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之集成Hystrix</title>
    <link href="/springCloud%E4%B9%8B%E9%9B%86%E6%88%90Hystrix/"/>
    <url>/springCloud%E4%B9%8B%E9%9B%86%E6%88%90Hystrix/</url>
    
    <content type="html"><![CDATA[<h1 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h1><h2 id="什么是服务熔断？"><a href="#什么是服务熔断？" class="headerlink" title="什么是服务熔断？"></a>什么是服务熔断？</h2><ul><li><p>服务熔断就是对服务的调用执行熔断，对于后续的请求，不再调用目标服务，而是直接返回一个合理的信息，比如说请求量太大，返回一个”此时服务过载”，从而可以快速释放资源</p></li><li><p>保护系统</p></li></ul><h2 id="为什么会有这种熔断机制的出现"><a href="#为什么会有这种熔断机制的出现" class="headerlink" title="为什么会有这种熔断机制的出现?"></a>为什么会有这种熔断机制的出现?</h2><p>在微服务相互调用的时候可能会出现服务调用发生异常或调用超时,多此请求造成服务积压导致服务无法使用后接着级联导致调用此服务的消费者也出现异常或调用超时,最后导致整个系统的全部崩溃.这就是雪崩效应.</p><blockquote><p><a href="https://so.csdn.net/so/search?q=%E7%BA%A7%E8%81%94&spm=1001.2101.3001.7020">级联</a>(失败)雪崩：一个服务失败，导致整条链路的服务都失败的情形。</p></blockquote><h2 id="熔断的意义？"><a href="#熔断的意义？" class="headerlink" title="熔断的意义？"></a>熔断的意义？</h2><ul><li>让系统更加稳定</li><li>减少性能损耗<ul><li>响应很简单，所以产生的性能很小。</li><li>用户知道服务有问题了，就不再调用，避免一直重试，也可以减少性能损耗。</li></ul></li><li>及时响应。不需要其他计算，直接就可以返回一个简单的响应。</li><li>阀值可定制，比如请求到达10000，就开启熔断器</li></ul><h2 id="熔断器的功能"><a href="#熔断器的功能" class="headerlink" title="熔断器的功能"></a>熔断器的功能</h2><ul><li>异常处理。需要可以根据异常的类型，去处理异常</li><li>日志记录。记录失败的数目，才可以开启熔断</li><li>测试失败的操作。周期性的检查来测试服务是否健康。</li><li>手动复位。管理员可以强行关闭断路器，重置故障的计数器</li><li>并发。断路器可以支持大并发量</li><li>加速断路：检测出问题的速度要快，及时响应</li><li>重试失败请求：在服务可用时，可以安排重试</li></ul><h2 id="熔断和降级的区别"><a href="#熔断和降级的区别" class="headerlink" title="熔断和降级的区别"></a>熔断和降级的区别</h2><p>相同点：</p><ul><li>目的一致。通过技术手段来保护系统</li><li>表现类似：让用户体验到某些服务暂时不可用</li><li>粒度相同：都是基于服务的</li></ul><p>不同点</p><ul><li>触发条件不同<ul><li>服务熔断：服务熔断由链路上某个服务故障引起的</li><li>服务降级，整体负荷来考虑。比如：原本有一个系统可以承载100个请求，但是后面由于请求数降低，相应的服务数量也需要降低</li></ul></li><li>管理目标层级不同<ul><li>服务熔断：服务熔断是一个框架层次的处理，</li><li>服务降级：服务降级是业务层次的处理。降级一般是从外围服务开始</li></ul></li></ul><h1 id="hystrix"><a href="#hystrix" class="headerlink" title="hystrix"></a>hystrix</h1><h2 id="hystrix是什么？"><a href="#hystrix是什么？" class="headerlink" title="hystrix是什么？"></a>hystrix是什么？</h2><ul><li>Feign是Netflix开发的一款服务容错和保护组件</li></ul><h2 id="SpringCloud-集成hystrix"><a href="#SpringCloud-集成hystrix" class="headerlink" title="SpringCloud 集成hystrix"></a>SpringCloud 集成hystrix</h2><ol><li><p>搭建Eureka Client并集成Feign ：<a href="https://pyr9.github.io/2022/08/18/springCloud%E4%B9%8BFeign%E6%90%AD%E5%BB%BA/">springCloud之Feign搭建 - 楼上有只喵 (pyr9.github.io)</a></p></li><li><p>导入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-hystrix&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>启动类加上@EnableCircuitBreaker注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@EnableCircuitBreaker</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>properties修改配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=8085<br>spring.application.name: micro-weather-eureka-client-feign-hystrix<br>eureka.client.serviceUrl.defaultZone: http://localhost:8761//eureka/<br>feign.client.config.feignName.connectTimeout: 5000<br>feign.client.config.feignName.readTimeout: 5000<br><br># 开启feign.hystrix<br>feign.hystrix.enabled=true<br></code></pre></td></tr></table></figure></li><li><p>修改CityClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name=&quot;micro-weather-city-eureka&quot;, fallback = CityClientFallBack.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CityClient</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-function">String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义CityClientFallBack实现CityClient</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.service;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CityClientFallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CityClient</span></span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;City is empty!&quot;</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="7"><li><p>访问<a href="http://localhost:8085/cities">localhost:8085&#x2F;cities</a></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232404189.png" alt="image-20230228232404189"></p></li></ol><p><strong>另一种实现方式</strong></p><ol><li><p>修改业务类，使用@HystrixCommand(fallbackMethod&#x3D;XXX)，指明熔断时调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br><br><span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<br><span class="hljs-keyword">import</span> com.pyr.spring.cloud.weather.service.CityClient;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CityController</span> </span>&#123;<br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> CityClient cityClient;<br><br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-meta">@HystrixCommand(fallbackMethod=&quot;defaultCities&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> cityClient.listCity();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">defaultCities</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Micro weather city eureka is down!&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li><p>CityClient不需要修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.service;<br><br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-meta">@FeignClient(name=&quot;micro-weather-city-eureka&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CityClient</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-function">String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li><p>停止micro-weather-city-eureka服务，访问<a href="http://localhost:8085/cities">localhost:8085&#x2F;cities</a></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232412332.png" alt="image-20230228232412332"></p></li></ol><p>注：这种方式不需要添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">feign.hystrix.enabled=<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>服务熔断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud网关</title>
    <link href="/springCloud%E7%BD%91%E5%85%B3/"/>
    <url>/springCloud%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-网关是什么"><a href="#1-网关是什么" class="headerlink" title="1.网关是什么"></a>1.网关是什么</h1><h2 id="1-1-网关产生的原因？"><a href="#1-1-网关产生的原因？" class="headerlink" title="1.1 网关产生的原因？"></a>1.1 网关产生的原因？</h2><ol><li><p>在微服务架构中，一个系统往往由多个微服务组成，而这些服务可能部署在不同机房、不同地区、不同域名下。这种情况下，客户端想要直接请求这些服务，就需要知道它们具体的地址信息，例如 IP 地址、端口号等。这种客户端直接请求服务的方式存在以下问题：</p><ul><li><p>当服务数量众多时，客户端需要维护大量的服务地址，这对于客户端来说，是非常繁琐复杂的。</p></li><li><p>在某些场景下可能会存在跨域请求的问题。</p></li><li><p>身份认证的难度大，每个微服务需要独立认证。</p></li></ul></li><li><p>在微服务架构中，每个服务都有对外提供服务的地址和端口，都有一些<strong>共同的功能</strong>，比如：<strong>权限校验、日志记录、限流、熔断、监控</strong>等等。如果任由每个服务独立对外提供接口。<strong>协调管理这些接口</strong>就会变得非常麻烦， 且会<strong>造成代码的重复</strong>。</p></li></ol><h2 id="1-2-网关是什么？"><a href="#1-2-网关是什么？" class="headerlink" title="1.2 网关是什么？"></a>1.2 网关是什么？</h2><p>API 网关是一个<strong>搭建在客户端和微服务之间的服务</strong>。</p><ul><li><p>API 网关就像整个微服务系统的门面一样，是系统对外的唯一入口。有了它，客户端会先将请求发送到 API 网关，然后由 API 网关根据请求的标识信息将请求转发到微服务实例。</p></li><li><p>我们可以在 API 网关中处理一些非业务功能的逻辑，例如权限验证、监控、缓存、请求路由等。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232252488.png" alt="image-20230228232252488"></p></li></ul><h2 id="1-3-网关的优点和缺点"><a href="#1-3-网关的优点和缺点" class="headerlink" title="1.3 网关的优点和缺点"></a>1.3 网关的优点和缺点</h2><p><strong>优点：</strong></p><ul><li>集合多个API</li><li>统一API入口，客户端通过 API 网关与微服务交互时，客户端只需要知道 API 网关地址即可，而不需要维护大量的服务地址，简化了客户端的开发。</li><li>客户端直接与 API 网关通信，能够减少客户端与各个服务的交互次数。</li><li>API 网关还提供了安全、流控、过滤、缓存、计费以及监控等 API 管理功能。</li></ul><p><strong>缺点：</strong></p><ul><li>在架构上需要考虑更多的管理，比如哪些API放在哪个网关上</li><li>路由上需要进行统一的配置</li><li>可能引发单点故障，API是一个独立的入口，很容易出现高并发，设计不好，如果API网管不可用，整个系统不可用</li></ul><h2 id="1-4-API网关的实现方式"><a href="#1-4-API网关的实现方式" class="headerlink" title="1.4 API网关的实现方式"></a>1.4 API网关的实现方式</h2><ul><li>Spring Cloud Gateway</li><li>pring Cloud Netflix Zuul</li><li>Nginx</li><li>Traefik</li><li>Kong: 底层也是基于ngin x</li></ul><h1 id="2-Zuul"><a href="#2-Zuul" class="headerlink" title="2 Zuul"></a>2 Zuul</h1><p>Zuul 是Netflix开发的一款API网关组件。</p><p>优点：</p><ol><li>成熟稳定：Zuul 是 Netflix 开源的项目，已经在大规模生产环境中被验证过。</li><li>社区支持：拥有成熟的社区，有大量的文档和案例可供参考。</li><li>易于上手：相对较简单，易于配置和使用。</li></ol><p>缺点：</p><ol><li>阻塞式 I&#x2F;O：Zuul 使用阻塞式 I&#x2F;O，每个请求都会占用一个线程，可能会导致线程资源耗尽。</li><li>动态路由困难：Zuul 在运行时动态更新路由规则比较困难，需要重启服务。</li><li>不支持响应式编程：Zuul 1.x 不支持响应式编程模型，无法充分利用异步和非阻塞的特性。</li></ol><h2 id="2-1-SpringCloud-集成Zuul"><a href="#2-1-SpringCloud-集成Zuul" class="headerlink" title="2.1 SpringCloud 集成Zuul"></a>2.1 SpringCloud 集成Zuul</h2><ol><li><p>搭建Eureka Client : <a href="https://pyr9.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (pyr9.github.io)</a></p></li><li><p>引入依赖</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-zuul&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注：springCloud 版本过高，会存在zuul无法引入的问题，所以本地，将SpringCloud版本降低了，相应的SpringBoot版本也降低了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">plugins&#123;<br>id <span class="hljs-string">&#x27;org.springframework.boot&#x27;</span> version <span class="hljs-string">&#x27;2.2.0.RELEASE&#x27;</span><br>&#125;<br>ext &#123;<br>set(<span class="hljs-string">&#x27;springCloudVersion&#x27;</span>, <span class="hljs-string">&quot;Hoxton.SR12&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>properties修改配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=9090<br>spring.application.name: micro-weather-eureka-client-zuul<br>eureka.client.serviceUrl.defaultZone: http://localhost:8761//eureka/<br><br># 可配置多对路由<br>zuul.routes.demo.path: /demo/**<br>zuul.routes.demo.serviceId: micro-weather-eureka-client<br><br>#zuul.routes.city.path: /city/**<br>#zuul.routes.city.serviceId: msa-weather-city-eureka<br><br>#zuul.routes.data.path: /data/**<br>#zuul.routes.data.serviceId: msa-weather-data-eureka<br></code></pre></td></tr></table></figure><ol start="4"><li>启动类加入注解@EnableZuulProxy</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableZuulProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>访问<a href="http://localhost:9090/demo/hello">localhost:9090&#x2F;demo&#x2F;hello</a>，得到micro-weather-eureka-client 服务的数据</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232304736.png" alt="image-20230228232304736"></p><h1 id="3-Spring-Cloud-Gateway"><a href="#3-Spring-Cloud-Gateway" class="headerlink" title="3 Spring Cloud Gateway"></a>3 Spring Cloud Gateway</h1><p>在Zulu2 中，zuul的技术方案一直在跳票，spring cloud 自己开发了一个网关Spring Cloud Gateway，用来取代Zuul网关。</p><ul><li><p><strong>响应式编程支持</strong>：Spring Cloud Gateway 是基于 WebFlux 框架实现的，而 WebFlux 框架底层则使用了通信框架 Netty。这意味着它能够更高效地处理大量并发请求，而不会出现线程阻塞和资源浪费的问题。（Netty 使用了 Java NIO 提供的非阻塞 I&#x2F;O 模型，能够处理大量并发的连接和请求，并且不会阻塞线程，提高了系统的并发处理能力和性能。）</p></li><li><p><strong>Spring Cloud 生态集成</strong>：作为 Spring Cloud 生态系统的一部分，Spring Cloud Gateway 与其他 Spring Cloud 组件（如 Eureka、Consul、Ribbon 等）有着良好的集成，可以方便地构建和管理微服务架构。</p></li></ul><h2 id="3-1-Spring-Cloud-Gateway-核心概念"><a href="#3-1-Spring-Cloud-Gateway-核心概念" class="headerlink" title="3.1 Spring Cloud Gateway 核心概念"></a>3.1 Spring Cloud Gateway 核心概念</h2><ul><li>Route（路由）： 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。</li><li>Predicate（断言）:路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，<strong>如果请求与断言匹配成功，则将请求转发到相应的服务。</strong></li><li>Filter（过滤器）:过滤器，使用过滤器，我们可以对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。</li></ul><p><strong>注意：其中 Route 和 Predicate 必须同时声明。</strong></p><p>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由 RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言 的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters 是各种过滤器，用来对请求做各种判断和修改。</p><h2 id="3-2-Spring-Cloud-Gateway-特性"><a href="#3-2-Spring-Cloud-Gateway-特性" class="headerlink" title="3.2 Spring Cloud Gateway 特性"></a>3.2 Spring Cloud Gateway 特性</h2><ul><li>基于 Spring Framework 5、Project Reactor 和 Spring Boot 2.0 构建。</li><li>能够在任意请求属性上匹配路由。</li><li>predicates（断言） 和 filters（过滤器）是特定于路由的。</li><li>集成了 Hystrix 熔断器。</li><li>集成了 Spring Cloud DiscoveryClient（服务发现客户端）。</li><li>易于编写断言和过滤器。</li><li>能够限制请求频率。</li><li>能够重写请求路径。</li></ul><h2 id="3-3-Gateway-的工作流程"><a href="#3-3-Gateway-的工作流程" class="headerlink" title="3.3 Gateway 的工作流程"></a>3.3 Gateway 的工作流程</h2><p><strong>核心逻辑：路由转发+执行过滤器</strong></p><ol><li><p>客户端将请求发送到 Spring Cloud Gateway 上。</p></li><li><p>Spring Cloud Gateway 通过 Gateway Handler Mapping 找到与请求相匹配的路由，将其发送给 Gateway Web Handler。</p></li><li><p>Gateway Web Handler 通过指定的过滤器链（Filter Chain），将请求转发到实际的服务节点中，执行业务逻辑返回响应结果。</p></li><li><p>过滤器之间用虚线分开是因为过滤器可能会在转发请求之前（pre）或之后（post）执行业务逻辑。</p></li><li><p>过滤器（Filter）可以在请求被转发到服务端前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等。</p></li><li><p>过滤器可以在响应返回客户端之前，对响应进行拦截和再处理，例如修改响应内容或响应头、日志输出、流量监控等。</p></li><li><p>响应原路返回给客户端。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224346059.png" alt="image-20230228224346059"></p></li></ol><h2 id="3-4-Spring-Cloud-Gateway-动态路由"><a href="#3-4-Spring-Cloud-Gateway-动态路由" class="headerlink" title="3.4 Spring Cloud Gateway 动态路由"></a>3.4 Spring Cloud Gateway 动态路由</h2><p>默认情况下，Spring Cloud Gateway 会根据服务注册中心（例如 Eureka Server）中维护的服务列表，以服务名（spring.application.name）作为路径创建动态路由进行转发，从而实现动态路由功能。</p><p>我们可以在配置文件中，将 Route 的 uri 地址修改为以下形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">lb:<span class="hljs-comment">//service-name</span><br></code></pre></td></tr></table></figure><p>以上配置说明如下：</p><ul><li>lb：uri 的协议，表示开启 Spring Cloud Gateway 的负载均衡功能。</li><li>service-name：服务名，Spring Cloud Gateway 会根据它获取到具体的微服务地址。</li></ul><h2 id="3-5-SpringCloud-使用GateWay"><a href="#3-5-SpringCloud-使用GateWay" class="headerlink" title="3.5 SpringCloud 使用GateWay"></a>3.5 SpringCloud 使用GateWay</h2><ol><li><p>搭建Eureka Client : <a href="https://pyr9.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (pyr9.github.io)</a></p></li><li><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-gateway&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>修改application.yml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml">server:<br>  port: 9090<br>spring:<br>  application:<br>    name: micro-weather-eureka-client-gateway<br>  cloud:<br>    gateway: #网关路由配置<br>      routes:<br>        #将 micro-service-cloud-provider-dept-8001 提供的服务隐藏起来，不暴露给客户端，只给客户端暴露 API 网关的地址 9527<br>        - id: micro_weather_eureka_client_path #路由 id,没有固定规则，但唯一，建议与服务名对应<br>          uri: http://localhost:9091         #匹配后提供服务的路由地址<br>          predicates:<br>            #以下是断言条件，必选全部符合条件<br>            - Path=/test/**               #断言，路径匹配 注意：Path 中 P 为大写<br>            - Method=GET #只能时 GET 请求时，才能访问<br>eureka:<br>  client:<br>    fetch-registry: true<br>    register-with-eureka: true<br>    service-url:<br>      defaultZone: http://localhost:8761//eureka/<br></code></pre></td></tr></table></figure></li><li><p>修改启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>可以看到根据路由匹配，通过<a href="http://localhost:9090/%E8%AE%BF%E9%97%AE%E5%88%B0%E4%BA%86http://localhost:9091/%E7%9A%84%E6%8E%A5%E5%8F%A3">http://localhost:9090/访问到了http://localhost:9091/的接口</a></p><ul><li>访问<a href="http://localhost:9091/test/%E5%BC%A0%E4%B8%89">localhost:9091&#x2F;test&#x2F;张三</a></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224437860.png" alt="image-20230228224437860"></p><ul><li>访问<a href="http://localhost:9090/test/%E5%BC%A0%E4%B8%89">localhost:9090&#x2F;test&#x2F;张三</a></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224445551.png" alt="image-20230228224445551"></p></li></ol><p><strong>Spring Cloud Gateway 动态路由</strong></p><p>修改application.yml 的配置，使用注册中心中的微服务名创建动态路由进行转发</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224403815.png" alt="image-20230228224403815"></p><h1 id="4-zuul和spring-cloudgateway比较"><a href="#4-zuul和spring-cloudgateway比较" class="headerlink" title="4 zuul和spring cloudgateway比较"></a>4 zuul和spring cloudgateway比较</h1><table><thead><tr><th></th><th>Gateway</th><th>Zuul1</th><th>Zuul2</th></tr></thead><tbody><tr><td>靠谱性</td><td>spring cloud官方支持</td><td>曾经靠谱</td><td>专业放鸽子</td></tr><tr><td>性能</td><td>Netty</td><td>同步阻塞，性能慢</td><td>Netty</td></tr><tr><td>RPS</td><td>&gt;32000</td><td>20000左右</td><td>25000左右</td></tr><tr><td>spring cloud</td><td>已整合</td><td>已整合</td><td>暂无整合计划</td></tr><tr><td>长链接</td><td>支持</td><td>不支持</td><td>支持</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之集成Feign</title>
    <link href="/springCloud%E4%B9%8BFeign%E6%90%AD%E5%BB%BA/"/>
    <url>/springCloud%E4%B9%8BFeign%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Feign是什么？"><a href="#Feign是什么？" class="headerlink" title="Feign是什么？"></a>Feign是什么？</h1><ul><li>Feign是Netflix开发的一款声明式服务调用组件</li><li>Feign可以帮助我们更快捷、优雅地调用HTTP API。</li><li>Feign 是 Spring Cloud Netflix 模块的子模块，它是 Spring Cloud 对 Netflix Feign 的二次封装，主要负责 Spring Cloud 的服务调用功能。</li></ul><h1 id="SpringCloud-集成Feign"><a href="#SpringCloud-集成Feign" class="headerlink" title="SpringCloud 集成Feign"></a>SpringCloud 集成Feign</h1><ol><li><p>搭建Eureka Client : <a href="https://pyr9.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (pyr9.github.io)</a></p></li><li><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-openfeign&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>修改application.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=8085<br>spring.application.name: micro-weather-eureka-client-feign<br>eureka.client.serviceUrl.defaultZone: http://localhost:8761//eureka/<br># 连接的超时时间<br>feign.client.config.feignName.connectTimeout: 5000<br># 读数据的超时时间<br>feign.client.config.feignName.readTimeout: 5000<br></code></pre></td></tr></table></figure></li><li><p>创建一个接口，用FeignClient注解，指明需要调用的服务名和rest接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;micro-weather-city-eureka&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CityClient</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-function">String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br>   <br>   <span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br>   <span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br>   <span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br>   <span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<br>   <br>   <span class="hljs-meta">@SpringBootApplication</span><br>   <span class="hljs-meta">@EnableDiscoveryClient</span><br>   <span class="hljs-meta">@EnableFeignClients</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>   <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       SpringApplication.run(Application.class, args);<br>     &#125;<br>   &#125;<br>   <br><br><span class="hljs-number">6.</span> 创建一个RestClientController来实现对Feign客户端的调用<br><br>   ```java<br>   <span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br>   <br>   <span class="hljs-keyword">import</span> com.pyr.spring.cloud.weather.service.CityClient;<br>   <span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br>   <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br>   <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br>   <br>   <span class="hljs-meta">@RestController</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CityController</span> </span>&#123;<br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-keyword">private</span> CityClient cityClient;<br>   <br>     <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> cityClient.listCity();<br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>查看euraka服务端，可以看到该客户端注册成功，访问[localhost:8085&#x2F;cities，可以获取到指定服务接口的返回</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232728757.png" alt="image-20230228232728757"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之集成SpringCloud Config</title>
    <link href="/springCloud%E4%B9%8B%E9%9B%86%E6%88%90SpringCloud-Config/"/>
    <url>/springCloud%E4%B9%8B%E9%9B%86%E6%88%90SpringCloud-Config/</url>
    
    <content type="html"><![CDATA[<h1 id="集中化配置"><a href="#集中化配置" class="headerlink" title="集中化配置"></a>集中化配置</h1><h2 id="什么场景会用到配置"><a href="#什么场景会用到配置" class="headerlink" title="什么场景会用到配置"></a>什么场景会用到配置</h2><ul><li>想到某一个地方去读取文件</li><li>Application.yml&#x2F; bootstrap.yml</li><li>环境变量： 比如启动参数</li><li>数据库存储（系统变量）</li></ul><h2 id="为什么要集中化配置？"><a href="#为什么要集中化配置？" class="headerlink" title="为什么要集中化配置？"></a>为什么要集中化配置？</h2><ul><li>微服务数量多，配置多</li><li>没有版本控制（尤其数据库的系统变量）</li><li>分布零散：有的配置在代码里，有的在yml配置文件，有的在数据库</li><li>基于静态的配置：每次修改都需要重新发布</li><li>手工管理配置繁琐</li></ul><h2 id="配置分类"><a href="#配置分类" class="headerlink" title="配置分类"></a>配置分类</h2><p>按照动态静态区分</p><ul><li>静态：<ul><li>环境配置：数据库连接串，eureka注册中心，kāfka连接，应用名称</li><li>安全配置：连接密码，公钥私钥，http连接的证书</li></ul></li><li>动态：<ul><li>应用参数：白名单，缓存过期时间，日志级别</li><li>业务相关：隐私协议内容，动态文案</li><li>功能开关：灰度发布，功能开关</li></ul></li></ul><h2 id="配置中心的要求"><a href="#配置中心的要求" class="headerlink" title="配置中心的要求"></a>配置中心的要求</h2><ul><li><p>版本管理：可以看到修改记录</p></li><li><p>权限控制：某些人可改某些配置</p></li><li><p>配置业务分离：对配置单独进行管理</p></li><li><p>业务需求：动态推送变更，内容加密</p></li><li><p>高可用</p></li><li><p>面向可配置的编码：避免硬编码，设置常量，运行时可读取</p></li><li><p>个理性：生产环境的配置和测试环境配置不一样</p></li><li><p>一致性：相同部署环境下，应该配置相同</p></li><li><p>集中化配置：分布式环境下，应用的配置应该具备可以管理性，提供远程管理的能力。</p></li></ul><h1 id="SpringCloud-Config"><a href="#SpringCloud-Config" class="headerlink" title="SpringCloud Config"></a>SpringCloud Config</h1><h2 id="springCloud-config-是什么？"><a href="#springCloud-config-是什么？" class="headerlink" title="springCloud config 是什么？"></a>springCloud config 是什么？</h2><ul><li>Spring Cloud Config 是由 Spring Cloud 团队开发的项目，它可以为微服务架构中各个微服务提供集中化的外部配置支持。</li><li>Spring Cloud Config 可以将各个微服务的配置文件集中存储在一个外部的存储仓库或系统（例如 Git 、SVN 等）中，对配置的统一管理，以支持各个微服务的运行。</li><li>Spring Cloud Config 包含以下两个部分：<ul><li>Config Server：也被称为分布式配置中心，它是一个独立运行的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密信息和解密信息的访问接口。</li><li>Config Client：指的是微服务架构中的各个微服务，它们通过 Config Server 对配置进行管理，并从 Config Sever 中获取和加载配置信息。</li></ul></li></ul><h2 id="搭建-Config-服务端"><a href="#搭建-Config-服务端" class="headerlink" title="搭建 Config 服务端"></a>搭建 Config 服务端</h2><ol><li><p>搭建Eureka Client : <a href="https://pyr9.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (pyr9.github.io)</a></p></li><li><p>github或者码云上创建一个仓库存储配置信息，github国内不是很稳定，我用了码云</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232125832.png" alt="image-20230228232125832"></p></li><li><p>在config-repo路径下，编写配置文件config-dev.yml</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232134545.png" alt="image-20230228232134545"></p></li><li><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-config-server&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>properties修改配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">server.port=<span class="hljs-number">8888</span><br>spring.application.name: micro-weather-eureka-server-config<br>eureka.client.serviceUrl.defaultZone: http:<span class="hljs-comment">//localhost:8761//eureka/</span><br><br># git 地址，用来存储配置文件<br>spring.cloud.config.server.git.uri=https:<span class="hljs-comment">//gitee.com/panyuro/spring-cloud-microservice-config.git</span><br><br>#存储配置文件的目录<br>spring.cloud.config.server.git.searchPaths=config-repo<br></code></pre></td></tr></table></figure></li><li><p>启动类加入注解@EnableConfigServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableConfigServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动项目，访问<a href="http://localhost:8888/config-dev.yml">localhost:8888&#x2F;config-dev.yml</a>，我们可以看到8888微服务可以成功的读取到远端的配置文件。如下图：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232147874.png" alt="image-20230228232147874"></p></li></ol><p>访问<a href="http://localhost:8888/config/dev/master">localhost:8888&#x2F;config&#x2F;dev&#x2F;master</a></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232155081.png" alt="image-20230228232155081"></p><h2 id="搭建-Config客户端"><a href="#搭建-Config客户端" class="headerlink" title="搭建 Config客户端"></a>搭建 Config客户端</h2><ol><li><p>搭建Eureka Client : <a href="https://pyr9.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (pyr9.github.io)</a></p></li><li><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-config-client&#x27;</span><br></code></pre></td></tr></table></figure><p>springcloud 版本较高，无法成功启动项目的时候，需要再引入starter-bootstrap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>properties修改配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">server.port=<span class="hljs-number">9091</span><br>spring.application.name: micro-weather-config-client<br>eureka.client.serviceUrl.defaultZone: http:<span class="hljs-comment">//localhost:8761//eureka/</span><br><br>spring.cloud.config.profile=dev<br>spring.cloud.config.uri=http:<span class="hljs-comment">//localhost:8888/</span><br>spring.cloud.config.name=config<br></code></pre></td></tr></table></figure></li><li><p>编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigController</span> </span>&#123;<br><br>  <span class="hljs-meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> String info;<br><br>  <span class="hljs-meta">@Value(&quot;$&#123;config.version&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> String version;<br><br>  <span class="hljs-meta">@GetMapping(&quot;/config&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">config</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;info: &quot;</span>+info+<span class="hljs-string">&quot; version: &quot;</span>+version;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试，访问<a href="http://localhost:9091/config">localhost:9091&#x2F;config</a>，可以查询到正确的配置</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232205076.png" alt="image-20230228232205076"></p></li></ol><h1 id="Config客户端之动态刷新"><a href="#Config客户端之动态刷新" class="headerlink" title="Config客户端之动态刷新"></a>Config客户端之动态刷新</h1><p>避免每次修改githib上的配置都需要重启客户端</p><h2 id="手动版"><a href="#手动版" class="headerlink" title="手动版"></a>手动版</h2><p>优点：解决了重启 Config 客户端才能获取最新配置的问题，</p><p>缺点：只要配置仓库中的配置发生改变，就需要我们挨个向 Config 客户端手动发送 POST 请求，通知它们重新拉取配置。</p><p>那么有没有“一次通知，处处生效”的方式呢？答案是肯定的。Spring Cloud Config 配合 Bus 就可以实现配置的动态刷新。</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>集中化配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之Eureka搭建</title>
    <link href="/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/"/>
    <url>/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Eureka是什么？"><a href="#Eureka是什么？" class="headerlink" title="Eureka是什么？"></a>Eureka是什么？</h1><ul><li>Eureka是 Netflix 公司开发的一款开源的服务注册与发现组件。</li><li>Spring Cloud 将 Eureka 与 Netflix 中的其他开源服务组件（例如 Ribbon、Feign 以及 Hystrix 等）一起整合进 Spring Cloud Netflix 模块中，整合后的组件全称为 Spring Cloud Netflix Eureka。</li><li>Eureka 是 Spring Cloud Netflix 模块的子模块，它是 Spring Cloud 对 Netflix Eureka 的二次封装，主要负责 Spring Cloud 的服务注册与发现功能。</li></ul><h1 id="Eureka-两大组件"><a href="#Eureka-两大组件" class="headerlink" title="Eureka 两大组件"></a>Eureka 两大组件</h1><p>Eureka 采用 CS（Client&#x2F;Server，客户端&#x2F;服务器） 架构，它包括以下两大组件：</p><ul><li><p><strong>Eureka Server</strong>：Eureka 服务注册中心，主要用于提供服务注册功能。当微服务启动时，会将自己的服务注册到 Eureka Server。Eureka Server 维护了一个可用服务列表，存储了所有注册到 Eureka Server 的可用服务的信息，这些可用服务可以在 Eureka Server 的管理界面中直观看到。</p></li><li><p><strong>Eureka Client</strong>：Eureka 客户端，通常指的是微服务系统中各个微服务，主要用于和 Eureka Server 进行交互。在微服务应用启动后，Eureka Client 会向 Eureka Server 发送心跳（默认周期为 30 秒）。若 Eureka Server 在多个心跳周期内没有接收到某个 Eureka Client 的心跳，Eureka Server 将它从可用服务列表中移除（默认 90 秒</p></li></ul><h1 id="Eureka-自我保护机制"><a href="#Eureka-自我保护机制" class="headerlink" title="Eureka 自我保护机制"></a>Eureka 自我保护机制</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>默认情况下,EurekaClient会定时向EurekaServer端发送心跳，如果EurekaServer在一定时间内没有收到EurekaClient发送的心跳，便会把该实例从注册服务列表中剔除（默认是90秒)</li><li>但是在短时间内丢失大量的实例心跳，这时候EurekaServer会开启自我保护机制，<a href="https://so.csdn.net/so/search?q=Eureka&spm=1001.2101.3001.7020">Eureka</a>不会踢出该服务，而是会对该服务的信息进行保存。</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上 (即保证当前节点依然可用)</li><li>当网络稳定时，当前实例新的注册信息会被同步到其他节点中</li></ul><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>为了防止EurekaClient正常运行，但是与EurekaServer网络不通（延迟、拥堵、卡顿）的情况下，EurekaServer不会对EurekaClient服务进行剔除，因为微服务本身是建康的，此时不应该注销这个微服务。</p><h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>本地环境建议禁止自我保护，生产环境建议开启自我保护。</p><h2 id="eureka停止更新了"><a href="#eureka停止更新了" class="headerlink" title="eureka停止更新了"></a>eureka停止更新了</h2><p><a href="https://github.com/Netflix/eureka/wiki">Home · Netflix&#x2F;eureka Wiki (github.com)</a></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232003650.png" alt="image-20230228232003650"></p><h1 id="Eureka-Server搭建"><a href="#Eureka-Server搭建" class="headerlink" title="Eureka Server搭建"></a>Eureka Server搭建</h1><p>参考<a href="https://github.com/spring-cloud-samples/eureka">GitHub - spring-cloud-samples&#x2F;eureka</a></p><ul><li><p>Step1: 新建一个springBoot项目</p></li><li><p>Step2: 修改依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">plugins&#123;<br>id <span class="hljs-string">&#x27;org.springframework.boot&#x27;</span> version <span class="hljs-string">&#x27;2.6.1&#x27;</span><br>id <span class="hljs-string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="hljs-string">&#x27;1.0.8.RELEASE&#x27;</span><br>id <span class="hljs-string">&#x27;java&#x27;</span><br>&#125;<br><br>ext &#123;<br>set(<span class="hljs-string">&#x27;springCloudVersion&#x27;</span>, <span class="hljs-string">&quot;2021.0.0&quot;</span>)<br>name = <span class="hljs-string">&#x27;Eureka Server&#x27;</span><br>description = <span class="hljs-string">&#x27;Eureka Server demo project&#x27;</span><br>version=<span class="hljs-string">&#x27;0.0.1-SNAPSHOT&#x27;</span><br>sourceEncoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span><br>&#125;<br><br>repositories &#123;<br>mavenCentral()<br>maven &#123; url <span class="hljs-string">&#x27;https://repo.spring.io/release/&#x27;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-snapshot-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-milestone-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-release-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.springsource.org/plugins-release&quot;</span> &#125;<br>&#125;<br><br>dependencyManagement &#123;<br>imports &#123;<br>mavenBom <span class="hljs-string">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>&#125;<br>&#125;<br><br>dependencies &#123;<br>implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-server&#x27;</span><br>testImplementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Step3: application配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port: 8761<br><br>eureka.instance.hostname: localhost<br>#eureka可以同时作为服务端和客户端，这里禁用掉他客户端的能力<br>eureka.client.registerWithEureka: false<br>eureka.client.fetchRegistry: false<br>eureka.client.serviceUrl.defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/<br><br>#关闭自我保护机制，以确保注册中心将不可用的实例及时正确剔除<br>eureka.server.enable-self-preservation=false<br></code></pre></td></tr></table></figure></li><li><p>step4.启动类加上@EnableEurekaServer注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>启动成功后，访问<a href="http://localhost:8761/">Eureka</a>可以看到如下页面，可以看出此时还没有实例注册到该服务上。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232017385.png" alt="image-20230228232017385"></p></li></ul><h1 id="Eureka-Client搭建"><a href="#Eureka-Client搭建" class="headerlink" title="Eureka Client搭建"></a>Eureka Client搭建</h1><ul><li><p>Step1: 新建一个springBoot项目</p></li><li><p>Step2: 修改依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">plugins&#123;<br>id <span class="hljs-string">&#x27;org.springframework.boot&#x27;</span> version <span class="hljs-string">&#x27;2.6.1&#x27;</span><br>id <span class="hljs-string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="hljs-string">&#x27;1.0.8.RELEASE&#x27;</span><br>id <span class="hljs-string">&#x27;java&#x27;</span><br>&#125;<br><br>ext &#123;<br>set(<span class="hljs-string">&#x27;springCloudVersion&#x27;</span>, <span class="hljs-string">&quot;2021.0.0&quot;</span>)<br>name = <span class="hljs-string">&#x27;Eureka Server&#x27;</span><br>description = <span class="hljs-string">&#x27;Eureka Server demo project&#x27;</span><br>version=<span class="hljs-string">&#x27;0.0.1-SNAPSHOT&#x27;</span><br>    <br>sourceEncoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span><br>&#125;<br><br>repositories &#123;<br>mavenCentral()<br>maven &#123; url <span class="hljs-string">&#x27;https://repo.spring.io/release/&#x27;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-snapshot-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-milestone-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-release-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.springsource.org/plugins-release&quot;</span> &#125;<br>&#125;<br><br>dependencyManagement &#123;<br>imports &#123;<br>mavenBom <span class="hljs-string">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>&#125;<br>&#125;<br><br>dependencies &#123;<br>implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br><br>testImplementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Step3: application配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.application.name: micro-weather-eureka-client<br>eureka.client.serviceUrl.defaultZone: http:<span class="hljs-comment">//localhost:8761//eureka/</span><br></code></pre></td></tr></table></figure></li><li><p>step4.启动类加上@EnableDiscoveryClient注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>刷新</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232035911.png" alt="image-20230228232035911"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 反射</title>
    <link href="/java-%E5%8F%8D%E5%B0%84/"/>
    <url>/java-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h1><ul><li><p>反射就是指在运行状态中，对于任何一个类，能够知道这个类的所有属性和方法。</p></li><li><p>对于任何一个对象，都能调用它的任意属性和方法，并且可以改变他的属性。</p></li><li><p>反射是java被市委准动态语言的关键，反射机制允许程序在执行期间借助反射Api来获取任何类的内部信息，并能够直接操作任意对象的内部属性及方法。</p></li><li><p>加载完类后，在堆内存的方法区就产生了一个Class类型的对象，对应这个类。这个对象就包含了这个类的完整结构信息，我们可以通过这个对象看到类的结构。这个对象就像一面镜子，通过这面镜子我们可以看到类的结构，所以我们称之为：反射。</p></li></ul><h1 id="反射可以做什么"><a href="#反射可以做什么" class="headerlink" title="反射可以做什么"></a>反射可以做什么</h1><p>反射允许我们在程序运行时，取得任何一个已知class的内部信息，包括其属性，方法等，并可以在运行时改变他们呢。</p><p>获取class对象的五种方式：<a href="https://pyr9.github.io/2022/07/13/Java%E8%8E%B7%E5%8F%96class%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/">Java获取class的五种方式 - 楼上有只喵 (pyr9.github.io)</a></p><h1 id="反射的具体实现"><a href="#反射的具体实现" class="headerlink" title="反射的具体实现"></a>反射的具体实现</h1><p>查阅 API 可以看到 Class 有很多方法：</p><ul><li><p>getName()：获得类的完整名字。</p></li><li><p>getFields()：获得类的public类型的属性。</p><ul><li>getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类</li><li>getMethods()：获得类的public类型的方法。</li><li>getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类</li><li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</li><li>getConstructors()：获得类的public类型的构造方法。</li><li>getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类</li><li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象</li></ul></li></ul><p><strong>代码测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.my.test.reflection;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>  <span class="hljs-keyword">public</span> String fatherId;<br>  <span class="hljs-keyword">private</span> String fatherName;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFatherHobbies</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;eat&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFatherWork</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;computer&quot;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>  <span class="hljs-keyword">public</span> String sonId;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> Integer age;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSonHobbies</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;study&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getSonWork</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.my.test.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;<br>    <span class="hljs-keyword">final</span> Class&lt;Son&gt; clazz = Son.class;<br>    System.out.println(<span class="hljs-string">&quot;获得类的完整名字-------------------&quot;</span>);<br>    System.out.println(clazz.getName());<br><br>    System.out.println(<span class="hljs-string">&quot;获得类的public类型的属性-------------------&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Field field : clazz.getFields()) &#123;<br>      <span class="hljs-comment">// 由于JDK的安全检查耗时较多.所以通过setAccessible(true)的方式关闭安全检查就可以达到提升反射速度的目的</span><br>      field.setAccessible(<span class="hljs-keyword">true</span>);<br>      System.out.println(field.getName());<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;获得类的所有属性。包括private的---------------&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Field field : clazz.getDeclaredFields()) &#123;<br>      System.out.println(field.getName());<br>    &#125;<br><br><br>    System.out.println(<span class="hljs-string">&quot;获得类的public类型的方法,包括Object的-------------------&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Method method : clazz.getMethods()) &#123;<br>      System.out.println(method.getName());<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;获得类的所有方法。-------------------&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Method method : clazz.getDeclaredMethods()) &#123;<br>      System.out.println(method.getName());<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;获得指定的public属性。-------------------&quot;</span>);<br>    Field sonId = clazz.getField(<span class="hljs-string">&quot;sonId&quot;</span>);<br>    System.out.println(sonId);<br><br>    System.out.println(<span class="hljs-string">&quot;获得指定的private属性。-------------------&quot;</span>);<br>    Field age = clazz.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>    age.setAccessible(<span class="hljs-keyword">true</span>);<br>    System.out.println(age);<br><br>    System.out.println(<span class="hljs-string">&quot;创建这个类的一个对象-------------------&quot;</span>);<br>    <span class="hljs-keyword">final</span> Son son = clazz.getDeclaredConstructor().newInstance();<br>    System.out.println(son);<br><br>    System.out.println(<span class="hljs-string">&quot;将son对象的age属性赋值为19------------&quot;</span>);<br>    age.set(son, <span class="hljs-number">19</span>);<br>    System.out.println(age.get(son));<br><br>    System.out.println(<span class="hljs-string">&quot;获取构造方法-------------&quot;</span>);<br>    <span class="hljs-keyword">final</span> Constructor&lt;?&gt;[] constructors = clazz.getConstructors();<br>    <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;<br>      System.out.println(constructor.toString());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Console:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs stylus">获得类的完整名字-------------------<br>com<span class="hljs-selector-class">.my</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.reflection</span><span class="hljs-selector-class">.Son</span><br>获得类的public类型的属性-------------------<br>sonId<br>fatherId<br>获得类的所有属性。包括private的---------------<br>sonId<br>name<br>age<br>获得类的public类型的方法,包括Object的-------------------<br>getSonHobbies<br>getFatherHobbies<br>wait<br>wait<br>wait<br>equals<br>toString<br>hashCode<br>getClass<br>notify<br>notifyAll<br>获得类的所有方法。-------------------<br>getSonWork<br>getSonHobbies<br>getFatherHobbies<br>获得指定的public属性。-------------------<br>public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> com<span class="hljs-selector-class">.my</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.reflection</span><span class="hljs-selector-class">.Son</span><span class="hljs-selector-class">.sonId</span><br>获得指定的private属性。-------------------<br>private java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Integer</span> com<span class="hljs-selector-class">.my</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.reflection</span><span class="hljs-selector-class">.Son</span><span class="hljs-selector-class">.age</span><br>创建这个类的一个对象-------------------<br>com<span class="hljs-selector-class">.my</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.reflection</span>.Son@<span class="hljs-number">1</span>cd072a9<br>将son对象的age属性赋值为<span class="hljs-number">19</span>------------<br><span class="hljs-number">19</span><br>获取构造方法-------------<br>public com<span class="hljs-selector-class">.my</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.reflection</span><span class="hljs-selector-class">.Son</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>isAssignableFrom()</title>
    <link href="/isAssignableFrom-%E5%92%8Cinstanceof/"/>
    <url>/isAssignableFrom-%E5%92%8Cinstanceof/</url>
    
    <content type="html"><![CDATA[<h1 id="isAssignableFrom"><a href="#isAssignableFrom" class="headerlink" title="isAssignableFrom()"></a>isAssignableFrom()</h1><p>A.isAssignableFrom(B)方法可用来判断B是否可以由A转换（赋值得来），即</p><p>1.当A是类时，表示：类A是否为B类的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.my.test.isAggsignableFrom;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brother</span> </span>&#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println(Parent.class.isAssignableFrom(Son1.class));   =&gt; <span class="hljs-keyword">true</span><br>    System.out.println(Parent.class.isAssignableFrom(Brother.class));  =&gt; <span class="hljs-keyword">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.当A是接口时，表示：接口A是否被类B实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.my.test.isAggsignableFrom;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span></span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span></span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B1</span></span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println(A.class.isAssignableFrom(A1.class));  =&gt; <span class="hljs-keyword">true</span><br>    System.out.println(A.class.isAssignableFrom(B1.class));  =&gt; <span class="hljs-keyword">false</span><br>  &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java获取class的五种方式</title>
    <link href="/Java%E8%8E%B7%E5%8F%96class%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/Java%E8%8E%B7%E5%8F%96class%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="获取Class-类实例的五种方式"><a href="#获取Class-类实例的五种方式" class="headerlink" title="获取Class 类实例的五种方式"></a>获取Class 类实例的五种方式</h1><h2 id="1-已知具体的类，直接取该类的class属性-最安全，最可靠"><a href="#1-已知具体的类，直接取该类的class属性-最安全，最可靠" class="headerlink" title="1.已知具体的类，直接取该类的class属性(最安全，最可靠)"></a>1.已知具体的类，直接取该类的class属性(最安全，最可靠)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz01 = Person.class;<br></code></pre></td></tr></table></figure><h2 id="2-已知某个类的示例，调用该示例的getClass"><a href="#2-已知某个类的示例，调用该示例的getClass" class="headerlink" title="2.已知某个类的示例，调用该示例的getClass()"></a>2.已知某个类的示例，调用该示例的getClass()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz02 = <span class="hljs-keyword">new</span> Person().getClass();<br></code></pre></td></tr></table></figure><h2 id="3-已知该类的全路径，通过Class-forName-获得"><a href="#3-已知该类的全路径，通过Class-forName-获得" class="headerlink" title="3.已知该类的全路径，通过Class.forName() 获得"></a>3.已知该类的全路径，通过Class.forName() 获得</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class class03 = Class.forName(<span class="hljs-string">&quot;com.getClass.pojo.Person&quot;</span>);<br></code></pre></td></tr></table></figure><p>该方式可能会抛出：ClassNotFoundException</p><h2 id="4-已知该类的全路径，通过ClassLoader-loadClass-获得"><a href="#4-已知该类的全路径，通过ClassLoader-loadClass-获得" class="headerlink" title="4.已知该类的全路径，通过ClassLoader.loadClass() 获得"></a>4.已知该类的全路径，通过ClassLoader.loadClass() 获得</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader classLoader = MySpringApplicationContext.class.getClassLoader();<br><span class="hljs-keyword">final</span> Class clazz05 = classLoader.loadClass(<span class="hljs-string">&quot;com.getClass.pojo.Person&quot;</span>);<br></code></pre></td></tr></table></figure><p>该方式可能会抛出：ClassNotFoundException</p><h2 id="5-基本了类型的包装类，直接调用-type"><a href="#5-基本了类型的包装类，直接调用-type" class="headerlink" title="5. 基本了类型的包装类，直接调用.type"></a>5. 基本了类型的包装类，直接调用.type</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz04 = Integer.TYPE;<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring事务失效</title>
    <link href="/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/"/>
    <url>/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<p>~&#x2F;IdeaProjects&#x2F;hexo_blog&#x2F;source&#x2F;_posts&#x2F;spring事务失效.md</p><p>![image-20220626230019084](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220626230019084.png)</p><p>![image-20220626230308183](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220626230308183.png)</p><p>![image-20220626231230229](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220626231230229.png)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java命令--jstack的使用</title>
    <link href="/java%E5%91%BD%E4%BB%A4-jstack-%E5%B7%A5%E5%85%B7/"/>
    <url>/java%E5%91%BD%E4%BB%A4-jstack-%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>jstack用于生成java虚拟机当前时刻的线程快照。可以用来分析线程问题（如死锁），CPU突然飙升问题</p><h1 id="1-案例一-找出死锁"><a href="#1-案例一-找出死锁" class="headerlink" title="1. 案例一 找出死锁"></a>1. 案例一 找出死锁</h1><h2 id="1-1-问题代码"><a href="#1-1-问题代码" class="headerlink" title="1.1 问题代码"></a>1.1 问题代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockTest</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object lock1 = <span class="hljs-keyword">new</span> Object();<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object lock2 = <span class="hljs-keyword">new</span> Object();<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>         <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               System.out.println(<span class="hljs-string">&quot;thread1 begin&quot;</span>);<br>               Thread.sleep(<span class="hljs-number">5000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>               System.out.println(<span class="hljs-string">&quot;thread1 end&quot;</span>);<br>            &#125;<br>         &#125;<br>      &#125;).start();<br><br>      <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>         <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               System.out.println(<span class="hljs-string">&quot;thread2 begin&quot;</span>);<br>               Thread.sleep(<span class="hljs-number">5000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>               System.out.println(<span class="hljs-string">&quot;thread2 end&quot;</span>);<br>            &#125;<br>         &#125;<br>      &#125;).start();<br><br>      System.out.println(<span class="hljs-string">&quot;main thread end&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-问题定位"><a href="#1-2-问题定位" class="headerlink" title="1.2 问题定位"></a>1.2 问题定位</h2><h3 id="1-2-1-方式一-jps-jstack"><a href="#1-2-1-方式一-jps-jstack" class="headerlink" title="1.2.1 方式一 jps+jstack"></a>1.2.1 方式一 jps+jstack</h3><ol><li>运行<code>jps</code>，查看当前所有java进程的pid</li><li><code>jstack pid</code> 查看当前进程的堆栈状态，如果有死锁会打印出来found 1 deadLock</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231139474.png" alt="image-20230228231139474"></p><p>​       可以定位出是17行出了死锁问题。</p><h3 id="1-2-2-方式二-jvisualvm自动检测死锁"><a href="#1-2-2-方式二-jvisualvm自动检测死锁" class="headerlink" title="1.2.2 方式二 jvisualvm自动检测死锁"></a>1.2.2 方式二 jvisualvm自动检测死锁</h3><p>代码运行起来后，启动jvisualvm，在线程页面会直接有一个红色的显示：监测到死锁</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231151238.png" alt="image-20230228231151238"></p><h1 id="2-案例二-找出占用cpu最高的线程堆栈信息"><a href="#2-案例二-找出占用cpu最高的线程堆栈信息" class="headerlink" title="2 案例二 找出占用cpu最高的线程堆栈信息"></a>2 案例二 找出占用cpu最高的线程堆栈信息</h1><h2 id="2-1-问题代码"><a href="#2-1-问题代码" class="headerlink" title="2.1 问题代码"></a>2.1 问题代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> initData = <span class="hljs-number">666</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User user = <span class="hljs-keyword">new</span> User();<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">//一个方法对应一块栈帧内存区域</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> c = (a + b) * <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> c;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   Math math = <span class="hljs-keyword">new</span> Math();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      math.compute();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-问题定位"><a href="#2-2-问题定位" class="headerlink" title="2.2 问题定位"></a>2.2 问题定位</h2><h3 id="2-2-1-命令top-p-，显示你的java进程的内存情况，找到当前进程的PID"><a href="#2-2-1-命令top-p-，显示你的java进程的内存情况，找到当前进程的PID" class="headerlink" title="2.2.1 命令top -p  ，显示你的java进程的内存情况，找到当前进程的PID"></a>2.2.1 命令top -p <pid> ，显示你的java进程的内存情况，找到当前进程的PID</h3><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231203454.png" alt="image-20230228231203454"></p><h3 id="2-2-2-按H，获取每个线程的内存情况"><a href="#2-2-2-按H，获取每个线程的内存情况" class="headerlink" title="2.2.2 按H，获取每个线程的内存情况"></a>2.2.2 按H，获取每个线程的内存情况</h3><h3 id="2-2-3-找到内存和cpu占用最高的线程tid"><a href="#2-2-3-找到内存和cpu占用最高的线程tid" class="headerlink" title="2.2.3 找到内存和cpu占用最高的线程tid"></a>2.2.3 找到内存和cpu占用最高的线程tid</h3><h3 id="2-2-4-执行-jstack-PID-grep-A-10-4cd0"><a href="#2-2-4-执行-jstack-PID-grep-A-10-4cd0" class="headerlink" title="2.2.4 执行 jstack PID|grep -A 10 4cd0"></a>2.2.4 执行 <code>jstack PID|grep -A 10 4cd0</code></h3><p>比如tid为19664 ，转为十六进制得到 0x4cd0，执行 jstack 19663|grep -A 10 4cd0，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调用方法 </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228231212070.png" alt="image-20230228231212070"></p><p>6，查看对应的堆栈信息找出可能存在问题的代码</p>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象内存回收</title>
    <link href="/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <url>/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>垃圾收集主要是针对<strong>堆和方法区</strong>进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p><h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><p>要对垃圾进行回收，首先得判断这个对象是否可以被回收，有两种方法来判断： </p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><strong>引用计数法</strong></h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。<br>在两个对象出现<strong>循环引用</strong>的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>以 GC Roots 为起始点向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连，证明此对象是不可的。</p><p><strong>GC Roots</strong>根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等 </p><h1 id="常见引用类型"><a href="#常见引用类型" class="headerlink" title="常见引用类型"></a><strong>常见引用类型</strong></h1><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用 </p><ul><li><strong>强引用</strong>：普通的变量引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User user = <span class="hljs-keyword">new</span> User(); <br></code></pre></td></tr></table></figure><ul><li><strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SoftReference&lt;User&gt; user = <span class="hljs-keyword">new</span> SoftReference&lt;User&gt;(<span class="hljs-keyword">new</span> User()); <br></code></pre></td></tr></table></figure><ul><li>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容就可以使用软引用存储。</li></ul><p>​（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建 </p><p>​（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出 </p><ul><li><p><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用 </p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WeakReference&lt;User&gt; user = <span class="hljs-keyword">new</span> WeakReference&lt;User&gt;(<span class="hljs-keyword">new</span> User()); <br></code></pre></td></tr></table></figure></li><li><p><strong>虚引用：</strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</p></li></ul><h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a><strong>finalize()方法</strong></h1><p><strong>从Java9开始，finalize方法已被标注为@Deprecated，也就是过期了</strong></p><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 </p><p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong> </p><p><strong>1. 第一次标记并进行一次筛选。</strong> </p><p>筛选的条件是此对象是否有必要执行finalize()方法。 </p><p>当对象没有覆盖finalize方法，对象将直接被回收。 </p><p><strong>2. 第二次标记</strong> </p><p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。 </p><p>注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。 </p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.id=id;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;id&quot;</span>+id);<br>    <span class="hljs-keyword">super</span>.finalize();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      list.add(<span class="hljs-keyword">new</span> User(i++));<br>      <span class="hljs-keyword">new</span> User(j--);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228234402806.png" alt="image-20230228234402806"></p><p>可以看出，id为负数的user实例，也就是需要回收的对象，是会调用finalize()方法的！</p><h1 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a><strong>如何判断一个类是无用的类</strong></h1><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ： </p><ul><li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 </p></li><li><p>加载该类的 ClassLoader 已经被回收。 这点就使得大部分的类都没办法回收，因为类加载器很难被回收，自定义类加载器会有可能。</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能调优</tag>
      
      <tag>垃圾回收</tag>
      
      <tag>常见引用类型</tag>
      
      <tag>如何判断一个类是无用的类</tag>
      
      <tag>finalize()方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java命令--jinfo&amp;jstat</title>
    <link href="/java%E5%91%BD%E4%BB%A4-jinfo&amp;jstat%E5%B7%A5%E5%85%B7/"/>
    <url>/java%E5%91%BD%E4%BB%A4-jinfo&amp;jstat%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="Jstat"><a href="#Jstat" class="headerlink" title="Jstat"></a><strong>Jstat</strong></h1><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230728148.png" alt="image-20230228230728148"></p><h2 id="垃圾回收统计"><a href="#垃圾回收统计" class="headerlink" title="垃圾回收统计"></a>垃圾回收统计</h2><p><strong>jstat -gc pid 最常用</strong>，可以评估程序内存使用及GC压力整体情况 </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230735468.png" alt="image-20230228230735468"></p><ul><li><p>S0C：第一个幸存区的大小，单位KB</p></li><li><p>S1C：第二个幸存区的大小</p></li><li><p>S0U：第一个幸存区的使用大小</p></li><li><p>S1U：第二个幸存区的使用大小</p></li><li><p>EC：伊甸园区的大小</p></li><li><p>EU：伊甸园区的使用大小</p></li><li><p>OC：老年代大小</p></li><li><p>OU：老年代使用大小</p></li><li><p>MC：方法区大小(元空间)</p></li><li><p>MU：方法区使用大小</p></li><li><p>CCSC:压缩类空间大小</p></li><li><p>CCSU:压缩类空间使用大小</p></li><li><p>YGC：年轻代垃圾回收次数，指的是程序从运行起来到现在的次数</p></li><li><p>YGCT：年轻代垃圾回收消耗时间，单位s</p></li><li><p>FGC：老年代垃圾回收次数 </p></li><li><p>FGCT：老年代垃圾回收消耗时间，单位s</p></li><li><p>GCT：垃圾回收消耗总时间，单位s</p></li></ul><p> <strong>jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)</strong></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230742585.png" alt="image-20230228230742585"></p><h2 id="堆内存统计"><a href="#堆内存统计" class="headerlink" title="堆内存统计"></a>堆内存统计</h2><p>命令：<code>jstat -gccapacity 3548</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230751160.png"></p><ul><li>NGCMN：新生代最小容量</li><li>NGCMX：新生代最大容量</li><li>NGC：当前新生代容量</li><li>S0C：第一个幸存区大小</li><li>S1C：第二个幸存区的大小</li><li>EC：伊甸园区的大小</li><li>OGCMN：老年代最小容量</li><li>OGCMX：老年代最大容量</li><li>OGC：当前老年代大小</li><li>OC:当前老年代大小</li><li>MCMN:最小元数据容量</li><li>MCMX：最大元数据容量</li><li>MC：当前元数据空间大小</li><li>CCSMN：最小压缩类空间大小</li><li>CCSMX：最大压缩类空间大小</li><li>CCSC：当前压缩类空间大小</li><li>YGC：年轻代gc次数</li><li>FGC：老年代GC次数</li></ul><h2 id="新生代垃圾回收统计"><a href="#新生代垃圾回收统计" class="headerlink" title="新生代垃圾回收统计"></a>新生代垃圾回收统计</h2><p> 命令：<code>jstat -gcnew 3548</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230803600.png" alt="image-20230228230803600"></p><ul><li>S0C：第一个幸存区的大小</li><li>S1C：第二个幸存区的大小</li><li>S0U：第一个幸存区的使用大小</li><li>S1U：第二个幸存区的使用大小</li><li>TT:对象在新生代存活的次数</li><li>MTT:对象在新生代存活的最大次数</li><li>DSS:期望的幸存区大小</li><li>EC：伊甸园区的大小</li><li>EU：伊甸园区的使用大小</li><li>YGC：年轻代垃圾回收次数</li><li>YGCT：年轻代垃圾回收消耗时间</li></ul><h2 id="新生代内存统计"><a href="#新生代内存统计" class="headerlink" title="新生代内存统计"></a>新生代内存统计</h2><p><code>jstat -gcnewcapacity 3548</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230814113.png"></p><ul><li>NGCMN：新生代最小容量</li><li>NGCMX：新生代最大容量</li><li>NGC：当前新生代容量</li><li>S0CMX：最大幸存1区大小</li><li>S0C：当前幸存1区大小</li><li>S1CMX：最大幸存2区大小</li><li>S1C：当前幸存2区大小</li><li>ECMX：最大伊甸园区大小</li><li>EC：当前伊甸园区大小</li><li>YGC：年轻代垃圾回收次数</li><li>FGC：老年代回收次数</li></ul><h2 id="JVM运行情况预估"><a href="#JVM运行情况预估" class="headerlink" title="JVM运行情况预估"></a><strong>JVM运行情况预估</strong></h2><p>用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。</p><p><strong>年轻代对象增长的速率</strong></p><p>可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不同的时间分别估算不同情况下对象增长速率。</p><p><strong>Young GC的触发频率和每次耗时</strong></p><p>知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT&#x2F;YGC 公式算出，根据结果我们大概就能知道<strong>系统大概多久会因为Young GC的执行而卡顿多久。</strong></p><p><strong>每次Young GC后有多少对象存活和进入老年代</strong></p><p>这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden，survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出<strong>老年代对象增长速率。</strong></p><p><strong>Full GC的触发频率和每次耗时</strong></p><p>知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT&#x2F;FGC 计算得出。</p><p><strong>优化思路</strong>其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。</p><h1 id="Jinfo"><a href="#Jinfo" class="headerlink" title="Jinfo"></a><strong>Jinfo</strong></h1><p>查看正在运行的Java应用程序的扩展参数 以及jvm的参数 </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230825681.png" alt="image-20230228230825681"></p><h2 id="flags"><a href="#flags" class="headerlink" title="-flags"></a>-flags</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230833623.png" alt="image-20230228230833623"></p>]]></content>
    
    
    <categories>
      
      <category>JVM调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql事务隔离级别</title>
    <link href="/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-事务"><a href="#mysql-事务" class="headerlink" title="mysql 事务"></a>mysql 事务</h1><h2 id="1-事务定义"><a href="#1-事务定义" class="headerlink" title="1.事务定义"></a>1.事务定义</h2><p>事务是一个操作集合，这些操作要么都执行，要么都不执行，他是一个不可分割的工作单位。</p><h2 id="2-事务的四大特性"><a href="#2-事务的四大特性" class="headerlink" title="2.事务的四大特性"></a>2.事务的四大特性</h2><ul><li>原子性：事务是一个原子操作单元，它对数据的修改，要么都执行，要么都不执行。</li><li>一致性：一个事务执行前和执行后，数据必须保持一致，如：转账前用户AB的钱加在一起时500，转账后也应该是500</li><li>隔离型：事务外的实体不可以知道事务过程中的中间状态</li><li>持久性：对数据库的操作是永久性的，即使系统故障也能保持</li></ul><h2 id="3-不考虑事务的隔离性会产生并发问题"><a href="#3-不考虑事务的隔离性会产生并发问题" class="headerlink" title="3.不考虑事务的隔离性会产生并发问题"></a>3.不考虑事务的隔离性会产生并发问题</h2><ul><li>更新丢失：当两个或者多个事务同时对一行数据进行更新，会发生数据的覆盖，最后的更新覆盖了其他事务的更新。</li><li>脏读：读到了没有提交的数据，一个事务正在写操作，另一个事务进行了读操作，读到了脏数据。如果此时事务回滚，读取到的数据就是无效的。</li><li>不可重复读：读到了已经提交的数据，事务A多次读取同一数据，但在这个过程中，事务B对数据进行了修改并提交，会导致事务A多次读取数据结果不一致。</li><li>幻读：事务A读取到了事务B提交的新增数据。查询某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</li></ul><h1 id="mysql-事务隔离级别"><a href="#mysql-事务隔离级别" class="headerlink" title="mysql 事务隔离级别"></a>mysql 事务隔离级别</h1><ul><li><p>脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制来解决。</p></li><li><p>mysql隔离级别越高，性能越差。因为事务的本质就是串行化，这显然与并发是矛盾的。</p></li><li><p><code>RR</code> 级别作为 <code>mysql</code> 事务默认隔离级别，是事务安全与性能的折中。</p></li><li><p>查看当前事务的隔离级别 <code>select @@transaction_isolation;</code></p></li><li><p>设置事务隔离级别</p><ul><li>当前会话： <code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></li><li>全局：<code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></li></ul></li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>可能</td><td>可能</td><td align="center">可能</td></tr><tr><td>读已提交</td><td>不可能</td><td>可能</td><td align="center">可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td align="center">可能</td></tr><tr><td>串行化</td><td>不可能</td><td>不可能</td><td align="center">不可能</td></tr></tbody></table><h2 id="1-读未提交"><a href="#1-读未提交" class="headerlink" title="1.读未提交"></a>1.读未提交</h2><ul><li><p>打开两个客户端：客户端A设置当前事务模式为read uncommitted，查询employees 表的初始值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@transaction</span>_isolation <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> READ<span class="hljs-operator">-</span>UNCOMMITTED        <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure></li><li><p>客户端B开启事务，并执行更新操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  update employees <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;newLiLei&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据，一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是<strong>脏数据</strong>： </p></li><li><pre><code class="sql">mysql&gt;  select * from employees;+----+-----------+-----+----------+---------------------+| id | name      | age | position | hire_time           |+----+-----------+-----+----------+---------------------+|  4 | newLiLei  |  22 | mana ger | 2021-12-06 21:36:50 ||  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 ||  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |+----+-----------+-----+----------+---------------------+3 rows in set (0.00 sec)<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br>## 读已提交<br><br><span class="hljs-bullet">- </span>打开两个客户端：客户端A设置当前事务模式为read committed，查询employees 表的初始值<br><br><span class="hljs-code">```sql</span><br><span class="hljs-code">mysql&gt; select @@transaction_isolation;</span><br><span class="hljs-code">+-------------------------+</span><br><span class="hljs-code">| @@transaction_isolation |</span><br><span class="hljs-code">+-------------------------+</span><br><span class="hljs-code">| READ-COMMITTED          |</span><br><span class="hljs-code">+-------------------------+</span><br><span class="hljs-code">1 row in set (0.00 sec)</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; select * from employees;</span><br><span class="hljs-section">+----+-----------+-----+----------+---------------------+</span><br><span class="hljs-section">| id | name      | age | position | hire_time           |</span><br><span class="hljs-section">+----+-----------+-----+----------+---------------------+</span><br>|  4 | LiLei     |  22 | mana ger | 2021-12-06 21:36:50 |<br>|  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |<br><span class="hljs-section">|  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |</span><br><span class="hljs-section">+----+-----------+-----+----------+---------------------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure></code></pre></li><li><p>客户端B开启事务，并执行更新操作</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  update employees <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;newLiLei&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><ul><li>客户端B的事务提交</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">commit</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><ul><li>客户端A再次查询，结果 与上一步不一致，即产生了不可重复读的问题</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> newLiLei  <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br></code></pre></td></tr></table></figure><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><ul><li>打开两个客户端：客户端A设置当前事务模式为REPEATABLE-READ，查询employees 表的初始值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@transaction</span>_isolation <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ         <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><ul><li>客户端B开启事务，并执行更新操作, 并提交。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  update employees <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;newLiLei&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>在客户端A查询表account的所有记录，与上一次查询结果一致，没出现有出现不可重复读的问题</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><blockquote><p>Mysql默认级别是repeatable-read，有办法解决幻读问题吗？ </p><p><strong>间隙锁在某些情况下可以解决幻读问题</strong> </p><p>要避免幻读可以用间隙锁在Session_1下面执行update account set name &#x3D; ‘zhuge’ where id &gt; 10 and id &lt;&#x3D;20;，则其他Session没法在这个范围所包含的间隙里插入或修改任何数据</p></blockquote><h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><ul><li>打开两个客户端：客户端A设置当前事务模式为SERIALIZABLE，查询employees 表的初始值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@transaction</span>_isolation <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> SERIALIZABLE            <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec) <br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> newLiLei  <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy123   <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7</span> <span class="hljs-operator">|</span> wangwu123 <span class="hljs-operator">|</span>  <span class="hljs-number">18</span> <span class="hljs-operator">|</span> super    <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">53</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br></code></pre></td></tr></table></figure><ul><li>打开一个客户端B，并设置当前事务模式为serializable，插入一条记录报错，表被锁了插入失败，mysql中事务隔离级别为serializable时会锁表，因此不会出现幻读的情况，这种隔离级别并发性极低，开发中很少会用到。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> employees <span class="hljs-keyword">values</span>(<span class="hljs-number">12</span>,&quot;lili2&quot;,<span class="hljs-number">11</span>,&quot;manager&quot;,&quot;2021-12-06 21:36:55&quot;);<br>ERROR <span class="hljs-number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction<br></code></pre></td></tr></table></figure><h1 id="InnoDB与MYISAM的最大不同有两点："><a href="#InnoDB与MYISAM的最大不同有两点：" class="headerlink" title="InnoDB与MYISAM的最大不同有两点："></a>InnoDB与MYISAM的最大不同有两点：</h1><ol><li>支持事务</li><li>支持行锁</li></ol><h1 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h1><ul><li><p>尽可能低级别事务隔离</p></li><li><p>尽可能减少检索条件范围，避免间隙锁 </p></li><li><p>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行 </p></li><li><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 </p><blockquote><p>无索引行锁会升级为表锁：锁主要是加在索引上，如果对非索引字段更新, 行锁可能会变表锁</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql事务隔离性的实现</title>
    <link href="/mvcc%E4%BB%8B%E7%BB%8D/"/>
    <url>/mvcc%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql事务隔离性的实现"><a href="#mysql事务隔离性的实现" class="headerlink" title="mysql事务隔离性的实现"></a>mysql事务隔离性的实现</h1><h2 id="MVCC机制（多版本并发控制）"><a href="#MVCC机制（多版本并发控制）" class="headerlink" title="MVCC机制（多版本并发控制）"></a>MVCC机制（多版本并发控制）</h2><ul><li>Mysql在读已提交和可重复读隔离级别下都实现了MVCC机制。 </li><li>主要是保存数据在某个时间点的快照实现的。</li><li>mysql在每行记录后面，保存了两个隐藏列，分别为：创建事务id和删除事务id</li><li>MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。</li></ul><ul><li><p>当执行select操作的时候，mysql底层会带上过滤条件：</p><ul><li><p>创建事务id &lt;&#x3D; max(当前事务id, 已提交的最大事务id)，保证该事务读到的数据，要么是开始前就已经存在的，要么是自身插入或修改后的。</p></li><li><p>删除事务id  &gt;  max (当前事务id, 已提交的最大事务id) 或  删除事务id未定义。保证事务读到的行，在事务开始前没有被删除</p></li></ul></li></ul><h2 id="undo日志版本链"><a href="#undo日志版本链" class="headerlink" title="undo日志版本链"></a><strong>undo日志版本链</strong></h2><p>undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链。</p><ul><li>roll_pointer： 可以根据roll_pointer找到之前的老数据，如果事务失败，就可以找到之前的老数据</li><li>每次修改，就是写进新的事务id,以及把回滚指针指向上一条数据的位置</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h385eu22j0j218m0u042n.jpg"></p><h2 id="read-view机制详解"><a href="#read-view机制详解" class="headerlink" title="read view机制详解"></a><strong>read view机制详解</strong></h2><ul><li><p>在<strong>可重复读隔离级别</strong>，当事务开启，执行任何查询sql时会生成当前事务的<strong>一致性视图read-view，</strong>该视图在事务结束 之前都不会变化(<strong>如果是读已提交隔离级别在每次执行查询sql时都会重新生成</strong>)。</p></li><li><p>这个视图由执行查询时所有未提交事务id<strong>数组</strong>（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h385hvu2m4j210w0c2myc.jpg" style="zoom:50%;" /></h2><p>Eg:</p><p>假设当前新开启了一个事务A，事务id为300，在该事务之前有两个事务B和C，均id分别为100和200。</p><p>当事务A执行第一个select的时候，事务B已经提交了，而事务C还没有提交，那么此时的read-view为【200】，300</p><p><strong>版本链比对规则：</strong> </p><ol><li><p>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的； </p></li><li><p>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若</p></li></ol><p>row 的 trx_id 就是当前自己的事务是可见的）；</p><ol start="3"><li>如果 row 的 trx_id 落在黄色部分(min_id &lt;&#x3D;trx_id&lt;&#x3D; max_id)，那就包括两种情况</li></ol><p>​a. 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自己的事务是可见的)； </p><p>​b. 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</p><p><strong>删除的情况</strong>：</p><p>对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的 trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数据。</p><p><strong>注意：</strong></p><p>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作InnoDB表的语句， </p><p>事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。 </p><h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>串行化隔离级别为了保证较高的隔离性是通过将所有操 作加锁互斥来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postgresql索引基础</title>
    <link href="/postgresql%E5%9F%BA%E7%A1%80/"/>
    <url>/postgresql%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="PostgreSQL索引类型"><a href="#PostgreSQL索引类型" class="headerlink" title="PostgreSQL索引类型"></a>PostgreSQL索引类型</h1><ul><li>PostgreSQL提供了多种索引类型： B-tree、Hash、GiST、SP-GiST 、GIN 和 BRIN。</li><li>每一种索引类型使用了 一种不同的算法来适应不同类型的查询。</li><li>默认情况下，CREATE INDEX命令创建适合于大部分情况的B-tree 索引。</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>flex 布局</title>
    <link href="/flex-%E5%B8%83%E5%B1%80/"/>
    <url>/flex-%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-开启flex-布局"><a href="#1-开启flex-布局" class="headerlink" title="1 开启flex 布局"></a>1 开启flex 布局</h1><ul><li>开启flex布局，只需要在最外层容器设置<code> display: flex</code>即可</li><li>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</li><li>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。<ul><li>主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；</li><li>交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code></li></ul></li><li>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529192600.png"></p><p><strong>示例</strong>：</p><p>开启flex布局，默认沿主轴排列</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529194352.png" style="zoom:33%;" /><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: bisque;</span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">  &#125;</span><br><span class="css">  <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span>;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-容器的属性"><a href="#2-容器的属性" class="headerlink" title="2 容器的属性"></a>2 容器的属性</h1><p>以下6个属性设置在容器上。</p><h2 id="2-1-flex-direction"><a href="#2-1-flex-direction" class="headerlink" title="2.1 flex-direction"></a>2.1 flex-direction</h2><p>主轴的方向,（即项目的排列方向）。</p><blockquote><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li></ul></blockquote><blockquote><ul><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529194849.png" style="zoom:33%;" /><blockquote><ul><li><code>column</code>：主轴为垂直方向，起点在上沿。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529194940.png" style="zoom:33%;" /><blockquote><ul><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195014.png" style="zoom:33%;" /><h2 id="2-2-flex-wrap"><a href="#2-2-flex-wrap" class="headerlink" title="2.2 flex-wrap"></a>2.2 flex-wrap</h2><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><blockquote><ul><li><code>nowrap</code>（默认）：不换行。</li><li><code>wrap</code>：换行，第一行在上方。</li><li><code>wrap-reverse</code>：换行，第一行在下方。</li></ul></blockquote><h2 id="2-3-flex-flow"><a href="#2-3-flex-flow" class="headerlink" title="2.3 flex-flow"></a>2.3 flex-flow</h2><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><h2 id="2-4-justify-content"><a href="#2-4-justify-content" class="headerlink" title="2.4 justify-content"></a>2.4 justify-content</h2><p>定义了项目在主轴上的对齐方式。</p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><blockquote><ul><li><code>flex-start</code>（默认值）：左对齐</li></ul></blockquote><blockquote><ul><li><code>flex-end</code>：右对齐</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195131.png" style="zoom:33%;" /><blockquote><ul><li><code>center</code>： 居中</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195153.png" style="zoom:33%;" /><blockquote><ul><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195227.png" style="zoom:33%;" /><blockquote><ul><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195340.png" style="zoom:33%;" /><h2 id="2-5-align-items"><a href="#2-5-align-items" class="headerlink" title="2.5 align-items"></a>2.5 align-items</h2><p>定义项目在交叉轴上如何对齐</p><blockquote><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195559.png" style="zoom:33%;" /><blockquote><ul><li><code>flex-end</code>：交叉轴的终点对齐。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195624.png" style="zoom:33%;" /><blockquote><ul><li><code>center</code>：交叉轴的中点对齐。</li></ul></blockquote><img src="/Users/yuroupan/Library/Application Support/typora-user-images/image-20220529195658432.png" alt="image-20220529195658432" style="zoom:33%;" /><p><strong>当把<code>justify-content</code>和<code>align-items</code> 都设置为<code>center</code>, 项目将会水平垂直居中</strong></p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529200655.png" style="zoom:33%;" /><blockquote><ul><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><h2 id="2-6-align-content"><a href="#2-6-align-content" class="headerlink" title="2.6 align-content"></a>2.6 align-content</h2><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><p>该属性可能取6个值。</p><blockquote><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul></blockquote><h1 id="3-项目的属性"><a href="#3-项目的属性" class="headerlink" title="3 项目的属性"></a>3 项目的属性</h1><h2 id="3-1-order"><a href="#3-1-order" class="headerlink" title="3.1 order"></a>3.1 order</h2><ul><li><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li></ul><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529201004.png" style="zoom:33%;" /><ul><li><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><blockquote><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p></blockquote></li><li><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><blockquote><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p></blockquote></li></ul><p>当把width改成了100，默认项目都会等比例缩小：</p><ul><li><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><blockquote><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库三大范式</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="第一范式-确保每列保持原子性"><a href="#第一范式-确保每列保持原子性" class="headerlink" title="第一范式(确保每列保持原子性)"></a>第一范式(确保每列保持原子性)</h2><p>数据库表中的所有字段值都是不可分解的原子值。</p><ul><li>比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。</li><li>但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。</li></ul><h2 id="第二范式-确保表中的每列都和主键相关"><a href="#第二范式-确保表中的每列都和主键相关" class="headerlink" title="第二范式(确保表中的每列都和主键相关)"></a>第二范式(确保表中的每列都和主键相关)</h2><p>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。比如：</p><ul><li>订单信息表：订单编号，商品编号，商品名称，商品数量，商品单位，商品价格。联合主键为（订单编号，商品编号）</li><li>存在问题：<br>在该表中，商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。就需要单独存在另一张表里。而不应该在订单信息表里。</li><li>修正：<br>订单：订单编号，商品编号<br>商品：商品名称，商品数量，商品单位，商品价格</li></ul><h2 id="第三范式-确保每列都和主键列直接相关-而不是间接相关"><a href="#第三范式-确保每列都和主键列直接相关-而不是间接相关" class="headerlink" title="第三范式(确保每列都和主键列直接相关,而不是间接相关)"></a>第三范式(确保每列都和主键列直接相关,而不是间接相关)</h2><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。比如：</p><ul><li>学生信息表：学号，姓名，年龄，所在学院，学院联系方式，学院地点。主键：学号</li><li>存在问题：<br>存在依赖传递：学号 → 学院 → (学院地点，学院联系方式)</li><li>修正：<br>学生信息表：学号，姓名，年龄，所在学院<br>学院信息表：学院，学院联系方式，学院地点<br><img src="/assets/16542362929459.jpg"></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hooks的使用</title>
    <link href="/hooks%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/hooks%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><p>案例效果：</p><ul><li>点击按钮，文本title修改</li><li>点击按钮，input聚焦<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useRef, PureComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>UseRefDemo<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UseRefDemo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> titleRef = useRef()<br>  <span class="hljs-keyword">const</span> inputRef = useRef()<br>  <span class="hljs-keyword">const</span> testChild = useRef()<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>UseRefDemo<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>= <span class="hljs-string">&#123;titleRef&#125;</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;inputRef&#125;</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> changeDom()&#125;&gt;按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">TestChild</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;testChild&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TestChild</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeDom</span>(<span class="hljs-params"></span>)</span>&#123;<br>    titleRef.current.innerHTML = <span class="hljs-string">&quot;改变后的title&quot;</span><br>    inputRef.current.focus()<br>    <span class="hljs-built_in">console</span>.log(testChild)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h261x90pltj20kc0cqmxn.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git修改指定的提交</title>
    <link href="/git%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E7%9A%84%E6%8F%90%E4%BA%A4/"/>
    <url>/git%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E7%9A%84%E6%8F%90%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-git修改指定的提交"><a href="#1-git修改指定的提交" class="headerlink" title="1.  git修改指定的提交"></a>1.  git修改指定的提交</h1><ul><li><code>git rebase --interactive &#39;cffa46f19811496d9165cf2c32250943f94f0099^&#39;</code></li><li>修改</li><li><code>git add .</code></li><li><code>git commit --amend</code></li><li><code>git rebase --continue</code></li></ul><h1 id="2-更新gitignore文件后，git删除仓库中的缓存"><a href="#2-更新gitignore文件后，git删除仓库中的缓存" class="headerlink" title="2. 更新gitignore文件后，git删除仓库中的缓存"></a>2. 更新gitignore文件后，git删除仓库中的缓存</h1><p><code>git rm -r --cached target/ </code></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react初体验</title>
    <link href="/react%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/react%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="React是什么？"><a href="#React是什么？" class="headerlink" title="React是什么？"></a>React是什么？</h1><p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。</p><blockquote><p>使用最原生的HTML、CSS、JavaScript可以构建完整的用户界面吗？当然可以，但是会存在很多问题</p><ul><li>操作DOM兼容性的问题；</li><li>过多兼容性代码的冗余问题；</li><li>代码组织和规范的问题；</li></ul></blockquote><h1 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h1><h2 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h2><ul><li>声明式编程是目前整个大前端开发的模式：Vue、React、Flutter、SwiftUI</li><li>它允许我们只需要维护自己的状态，当状态改变时，React可以根据最新的状态去渲染我们的UI界面；</li></ul><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><ul><li>组件化开发页面目前前端的流行趋势</li></ul><h2 id="多平台适配"><a href="#多平台适配" class="headerlink" title="多平台适配"></a>多平台适配</h2><ul><li>2013年，React发布之初主要是开发Web页面</li><li>2015年，Facebook推出了ReactNative，用于开发移动端跨平台（虽然目前Flutter非常火爆，但是还是有很多公司在使用ReactNative）</li><li>2017年，Facebook推出ReactVR，用于开发虚拟现实Web应用程序</li></ul><h2 id="react-开发依赖"><a href="#react-开发依赖" class="headerlink" title="react 开发依赖"></a>react 开发依赖</h2><h3 id="开发React必须依赖三个库："><a href="#开发React必须依赖三个库：" class="headerlink" title="开发React必须依赖三个库："></a>开发React必须依赖三个库：</h3><ul><li>react：包含react所必须的核心代码</li><li>react-dom：react渲染在不同平台所需要的核心代码</li><li>babel：将jsx转换成React代码的工具</li></ul><h2 id="如何引入"><a href="#如何引入" class="headerlink" title="如何引入"></a>如何引入</h2><ul><li>cdn引入</li><li>下载后，添加本地依赖</li><li>npm依赖（脚手架使用）</li></ul><h2 id="认识Babel"><a href="#认识Babel" class="headerlink" title="认识Babel"></a>认识Babel</h2><ul><li>babel是目前前端使用非常广泛的编辑器、转移器。</li><li>比如当下很多浏览器并不支持ES6的语法，但是确实ES6的语法非常的简洁和方便，我们开发时希望使用它。</li><li>那么编写源码时我们就可以使用ES6来编写，之后通过Babel工具，将ES6转成大多数浏览器都支持的ES5的语法。</li></ul><blockquote><p>React和Babel的关系：</p><ul><li>默认情况下开发React其实可以不使用babel。</li><li>但是前提是我们自己使用React.createElement来编写源代码，它编写的代码非常的繁琐和可读性差。</li><li>那么我们就可以直接编写jsx（JavaScriptXML）的语法，并且让babel帮助我们转换成React.createElement。</li></ul></blockquote><h1 id="Hello-world案例"><a href="#Hello-world案例" class="headerlink" title="Hello world案例"></a>Hello world案例</h1><ul><li>这里我们编写React的script代码中，必须添加type&#x3D;”text&#x2F;babel”，作用是可以让babel解析jsx的语法</li><li>ReactDOM.render函数：<ul><li>参数一：传递要渲染的内容，这个内容可以是HTML元素，也可以是React的组件</li><li>参数二：将渲染的内容，挂载到哪一个HTML元素上</li></ul></li><li>通过{}语法来引入外部的变量或者表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  &lt;!--添加react 依赖--&gt;<br>  &lt;!-- <span class="hljs-comment">// crossorigin 将远程js的一些错误，显示到本地 --&gt;</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>【内容会被覆盖】<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">// render（渲染的内容，挂载的位置）</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">// ReactDOM.render(&lt;h2&gt;hello World&lt;/h2&gt;,document.getElementById(&quot;app&quot;))</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;hello world&quot;</span></span></span><br><span class="javascript"><span class="xml">  ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>))</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228233834887.png" alt="image-20230228233834887"></p><h1 id="HelloReact–-组件化开发"><a href="#HelloReact–-组件化开发" class="headerlink" title="HelloReact– 组件化开发"></a>HelloReact– 组件化开发</h1><ul><li>这里我们暂时使用类的方式封装组件：<ul><li>1.定义一个类（类名大写，组件的名称是必须大写的，小写会被认为是HTML元素），继承自React.Component</li><li>2.实现当前组件的render函数。render当中返回的jsx内容，就是之后React会帮助我们渲染的内容</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>     )<br>   &#125;<br> &#125;<br> ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="组件化-数据依赖"><a href="#组件化-数据依赖" class="headerlink" title="组件化 - 数据依赖"></a>组件化 - 数据依赖</h2><ul><li>组件中的数据，我们可以分成两类：<ul><li>参与界面更新的数据：当数据变量时，需要更新组件渲染的内容</li><li>不参与界面更新的数据：当数据变量时，不需要更新将组建渲染的内容</li></ul></li><li>参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的state中<ul><li>我们可以通过在构造函数中this.state&#x3D;{定义的数据}</li><li>当我们的数据发生变化时，我们可以调用this.setState来更新数据，并且通知React进行update操作。</li><li>在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs react">class App extends React.Component &#123;<br>  constructor()&#123;<br>    super()<br>    this.state = &#123;<br>     message: &quot;hello world&quot;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组件化-–-事件绑定"><a href="#组件化-–-事件绑定" class="headerlink" title="组件化 – 事件绑定"></a>组件化 – 事件绑定</h2><ul><li><p>在类中直接定义一个函数，并且将这个函数绑定到html原生的onClick事件上，当前这个函数的this指向默认情况下是undefined</p><ul><li>因为在正常的DOM操作中，监听点击，监听函数中的this其实是节点对象（比如说是button对象）；</li><li>React并不是直接渲染成真实的DOM，我们所编写的button只是一个语法糖，它的本质React的Element对象；</li></ul></li><li><p>我们在绑定的函数中，可能想要使用当前对象，比如执行this.setState函数，就必须拿到当前对象的this</p><ul><li><p>我们就需要在传入函数时，给这个函数直接绑定this</p></li><li><p>类似于下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;button onClick=&#123;this.btnClick.bind(this)&#125;&gt;改变文本&lt;/button&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="电影列表案例"><a href="#电影列表案例" class="headerlink" title="电影列表案例"></a>电影列表案例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">super</span>()<br>     <span class="hljs-built_in">this</span>.state = &#123;<br>      <span class="hljs-attr">movies</span>: [<span class="hljs-string">&quot;大话西游&quot;</span>, <span class="hljs-string">&quot;开心农场&quot;</span>]<br>     &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-keyword">return</span> (<br>       <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>电影列表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">          &#123;</span><br><span class="xml">            this.state.movies.map((item, index)=&gt;&#123;</span><br><span class="xml">            return (<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)</span><br><span class="xml">            &#125;)</span><br><span class="xml">          &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>     )<br>   &#125;<br> &#125;<br> ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228233846219.png" alt="image-20230228233846219"></p><h1 id="计数器案例"><a href="#计数器案例" class="headerlink" title="计数器案例"></a>计数器案例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">super</span>()<br>     <span class="hljs-built_in">this</span>.state = &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>     &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-keyword">return</span> (<br>       <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前计数:&#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;this.incr.bind(this)&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;this.decr.bind(this)&#125;</span>&gt;</span>-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>     )<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-title">incr</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">this</span>.setState(&#123;<br>       <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br>     &#125;)<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-title">decr</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">this</span>.setState(&#123;<br>       <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count - <span class="hljs-number">1</span><br>     &#125;)<br>   &#125;<br><br> &#125;<br> ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228233857215.png" alt="image-20230228233857215"></p><p>2ED3-DF39</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构-改善代码已有的设计</title>
    <link href="/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E5%B7%B2%E6%9C%89%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E5%B7%B2%E6%9C%89%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如果没有单元测试和重构，我没办法写代码</p></blockquote><h1 id="1-重构的意义"><a href="#1-重构的意义" class="headerlink" title="1 重构的意义"></a>1 重构的意义</h1><ul><li>保持代码易读、易修改</li><li>避免代码太复杂，无法理解，无法调试。（或许一个修改只需要10分钟，但是你得花费1个小时去理解这段代码</li><li>如果没有良好设计，或许某一段时间内你的进展迅速，但恶劣的设计很快就让你的速度慢下来。你会把时间花在 调试上面，无法添加新功能。修改时间越来越长，因为你必须花越来越多的时间去理解系统。</li></ul><h1 id="2-重构的定义"><a href="#2-重构的定义" class="headerlink" title="2 重构的定义"></a>2 重构的定义</h1><p>在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。</p><h1 id="3-重构的前提"><a href="#3-重构的前提" class="headerlink" title="3 重构的前提"></a>3 重构的前提</h1><p><strong>为即将修改的代码建立一组可靠的测试环境。</strong></p><ul><li>因为尽管遵循重构手法可以使我避免绝大多数引入bug的情形，但我毕竟是人，毕竟有可能犯错。所以我需要可靠的测试。</li></ul><blockquote><p>好的测试是重构的根本。</p></blockquote><h1 id="4-何时重构"><a href="#4-何时重构" class="headerlink" title="4 何时重构"></a>4 何时重构</h1><h2 id="4-1-添加新功能时重构"><a href="#4-1-添加新功能时重构" class="headerlink" title="4.1 添加新功能时重构"></a>4.1 添加新功能时重构</h2><ul><li><p>此时，重构的直接原因往往是为了帮助我理解 需要修改的代码——这些代码可能是别人写的，也可能是我自己写的。</p></li><li><p>无论何时，只要我想理解代码所做的事，我就会问自己：是否能对这段代码进行重构，使我能更快地理解它。然后我就会重构。</p></li><li><p>之所以这么做，部分原因是为了让我下次再看这段代码时容易理解，但最主要的原因是：如果在前进过程中把代码结构理清，我就可以从中理解更多东西</p></li></ul><h2 id="4-2-复审代码时重构"><a href="#4-2-复审代码时重构" class="headerlink" title="4.2 复审代码时重构"></a>4.2 复审代码时重构</h2><p>这种活动有助于在开发团队中传 播知识，也有助于让较有经验的开发者把知识传递给比较欠缺经验的人，并帮助更多人理解大型软件系统中的更多部分。</p><h2 id="4-3-修补错误时重构"><a href="#4-3-修补错误时重构" class="headerlink" title="4.3 修补错误时重构"></a>4.3 修补错误时重构</h2><p>代码还够清晰——没有清晰到让你能一眼看出bug。</p><h1 id="5-代码坏味道"><a href="#5-代码坏味道" class="headerlink" title="5 代码坏味道"></a>5 代码坏味道</h1><h2 id="5-1-命名规范"><a href="#5-1-命名规范" class="headerlink" title="5.1 命名规范"></a>5.1 命名规范</h2><h3 id="错误方式"><a href="#错误方式" class="headerlink" title="错误方式"></a>错误方式</h3><ul><li><p>单词拼写错误</p></li><li><p>自己创造缩写   </p></li><li><p>使用技术术语命名</p><ul><li><p>如：userList , idList</p></li><li><p>编程的一个重要原则是面向接口编程。即接口是稳定的，实现是易变的。</p></li><li><p>假设这里我现在需要的是一个不重复的作品集合，也就是说这里需要把List改成Set，变量类型一定会改，但是你不一定会记得改变量名，一旦遗忘，就会出现一个bookList变量，它的类型是set,就会产生混淆。</p></li></ul></li><li><p>命名中的不一致。</p></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>命名要有业务含义</li><li>建立团队的词汇表，让团队成员有信息可以参考。</li><li>制定代码规范，比如，类名要用名词，函数名要用动词或动宾短语；</li><li>符合英语语法规则</li><li>类似含义的代码应该有一致的名字，一旦出现了不一致的名字，通常都表示不同的含义</li></ul><h2 id="5-2-Duplicated-Code（重复代码）"><a href="#5-2-Duplicated-Code（重复代码）" class="headerlink" title="5.2 Duplicated Code（重复代码）"></a>5.2 Duplicated Code（重复代码）</h2><ul><li>复制粘贴的代码</li><li>部分重复</li><li>if 和 else 代码块中的语句高度类似。</li></ul><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><ul><li><p>抽方法</p></li><li><p>Template Method（模版方法）： 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    check();<br>    calculate();<br>    pay();<br>    log();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>让 if 语句做真正的选择</li></ul><h2 id="5-3-Long-Method（过长函数）"><a href="#5-3-Long-Method（过长函数）" class="headerlink" title="5.3 Long Method（过长函数）"></a>5.3 <strong>Long Method</strong>（过长函数）</h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul><li><p>把代码平铺直叙地摊在那里</p></li><li><p>一次加一点</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>程序愈长愈难理解</p></li><li><p>把多个业务处理流程放在一个函数里实现；</p></li><li><p>把不同层面的细节放到一个函数里实现。</p></li></ul><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><ul><li>如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数去。</li><li>循环常常也是提炼的信号。你应该将循环和其内的代码提炼到一个独立函数中。</li><li>建议30 行，idea屏可以看得完</li></ul><h2 id="5-4-Large-Class（过大的类）"><a href="#5-4-Large-Class（过大的类）" class="headerlink" title="5.4 Large Class（过大的类）"></a>5.4 Large Class（过大的类）</h2><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>类内如果有太多代码，也是代码重复、混乱并最终走向死亡的源头</p><h3 id="优化-3"><a href="#优化-3" class="headerlink" title="优化"></a>优化</h3><ul><li>类的职责保证单一</li><li>字段未分组。比如，userId、name、nickname 几项，算是用户的基本信息，而 email、phoneNumber 这些则属于用户的联系方式</li></ul><h2 id="5-5-Long-Parameter-List（过长参数列）"><a href="#5-5-Long-Parameter-List（过长参数列）" class="headerlink" title="5.5 Long Parameter List（过长参数列）"></a>5.5 Long Parameter List（过长参数列）</h2><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>太长的参数列难以理解，太多参数会造成前后不一致、不易使用</li><li>如果有多个重载方法，参数很多的话，有时候你都不知道调哪个</li></ul><h3 id="优化-4"><a href="#优化-4" class="headerlink" title="优化"></a>优化</h3><ul><li>将参数封装成结构或者类</li></ul><h2 id="5-6-Shotgun-Surgery（霰弹式修改）"><a href="#5-6-Shotgun-Surgery（霰弹式修改）" class="headerlink" title="5.6 Shotgun Surgery（霰弹式修改）"></a>5.6 Shotgun Surgery（霰弹式修改）</h2><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li>每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你不但很难找到它们，也很容易忘记某个重要的修改。</li></ul><h3 id="优化-5"><a href="#优化-5" class="headerlink" title="优化"></a>优化</h3><ul><li>把所有需要修改的代码放进同一个类</li></ul><h3 id="5-7-Data-Clumps（数据泥团）"><a href="#5-7-Data-Clumps（数据泥团）" class="headerlink" title="5.7 Data Clumps（数据泥团）"></a>5.7 Data Clumps（数据泥团）</h3><p>数据泥团指的是经常一起出现的数据， 比如：</p><ul><li>两个类中相同的字段</li><li>多个函数签名中相同的参数</li></ul><h3 id="优化-6"><a href="#优化-6" class="headerlink" title="优化"></a>优化</h3><ul><li>提炼到一个独立对象</li></ul><h2 id="5-8-Switch-Statements（switch惊悚现身）"><a href="#5-8-Switch-Statements（switch惊悚现身）" class="headerlink" title="5.8  Switch Statements（switch惊悚现身）"></a>5.8  Switch Statements（switch惊悚现身）</h2><ul><li>少用switch（或case）语句</li></ul><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul><li>switch语句的问题在于重复。你常会发现同样的switch语句散布于不同地点。</li><li>如果要为它添加一个新的case子句，就必须找到所有switch语句并修改它们</li></ul><h3 id="优化-7"><a href="#优化-7" class="headerlink" title="优化"></a>优化</h3><ul><li><p>构建map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">function <span class="hljs-title">getDeliverResult</span><span class="hljs-params">(status)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (status) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;待发货&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;已发货&#x27;</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">const</span> orderStatus = <span class="hljs-keyword">new</span> Map()<br>    .set(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;待发货&#x27;</span>)<br>    .set(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;已发货&#x27;</span>)<br>    .set(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;已完成&#x27;</span>);<br> <br><span class="hljs-function">function <span class="hljs-title">getOrderStatus</span><span class="hljs-params">(statusCode)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> orderStatus.get(statusCode) || [];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ChargeFor</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span>(PriceCode)&#123;<br><span class="hljs-keyword">case</span> Movie.REGULAR:<br>result = (<span class="hljs-keyword">new</span> RegularPrice()).ChargeFor(daysRented)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> Movie.REGULAR:<br>result += daysRented * <span class="hljs-number">3</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> Movie.CHILDRENS:<br>result += <span class="hljs-number">1.5</span>;<br><span class="hljs-keyword">if</span> (daysRented &gt; <span class="hljs-number">3</span>)<br>result += (daysRented - <span class="hljs-number">3</span>) * <span class="hljs-number">1.5</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieBase</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ChargeFor</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegularMovie</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MovieBase</span></span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ChargeFor</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RegularPrice()).ChargeFor(daysRented);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-9-过深的if-else嵌套"><a href="#5-9-过深的if-else嵌套" class="headerlink" title="5.9 过深的if else嵌套"></a>5.9 过深的if else嵌套</h2><p>圈复杂度不能超过6，3个if else</p><h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ul><li>看起来很复杂</li></ul><h3 id="优化-8"><a href="#优化-8" class="headerlink" title="优化"></a>优化</h3><ul><li>抽方法</li><li>使用多态</li></ul><h2 id="5-10-过多的注释"><a href="#5-10-过多的注释" class="headerlink" title="5.10 过多的注释"></a>5.10 过多的注释</h2><h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><p>很多注释的存在是因为代码很糟糕</p><h3 id="优化-9"><a href="#优化-9" class="headerlink" title="优化"></a>优化</h3><ul><li><p>方法函数、变量的<strong>命名要规范、浅显易懂</strong>、避免用注释解释代码。</p></li><li><p><strong>关键、复杂的业务</strong>，使用<strong>清晰、简明</strong>的注释</p></li></ul><h2 id="5-11-magic变量"><a href="#5-11-magic变量" class="headerlink" title="5.11 magic变量"></a>5.11 magic变量</h2><h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><ul><li>看了令人迷惑</li></ul><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;3&quot;</span>.equals(emndVo.getStatus())) &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (allId.size() &lt;= <span class="hljs-number">500</span>) <br></code></pre></td></tr></table></figure><h3 id="优化-10"><a href="#优化-10" class="headerlink" title="优化"></a>优化</h3><ul><li><strong>新建个常量</strong></li><li><strong>建一个枚举类</strong>，把相关的魔法数字放到一起管理。</li></ul><h1 id="6-其他提升代码可读性的方式"><a href="#6-其他提升代码可读性的方式" class="headerlink" title="6 其他提升代码可读性的方式"></a>6 其他提升代码可读性的方式</h1><h3 id="6-1-Introduce-Explaining-Variable（引入解释性变量）"><a href="#6-1-Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="6.1 Introduce Explaining Variable（引入解释性变量）"></a>6.1 Introduce Explaining Variable（引入解释性变量）</h3><ul><li>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</li><li>表达式有可能非常复杂而难以阅读。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式。</li></ul><h3 id="6-2-使用pair"><a href="#6-2-使用pair" class="headerlink" title="6.2 使用pair"></a>6.2 使用pair</h3><h1 id="7-构建单元测试"><a href="#7-构建单元测试" class="headerlink" title="7 构建单元测试"></a>7 构建单元测试</h1>]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react基础</title>
    <link href="/react%E5%9F%BA%E7%A1%80/"/>
    <url>/react%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="react组件基础"><a href="#react组件基础" class="headerlink" title="react组件基础"></a>react组件基础</h1><h2 id="组件概念"><a href="#组件概念" class="headerlink" title="组件概念"></a>组件概念</h2><ul><li>使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。</li><li>所谓组件，即封装起来的具有独立功能的UI部件。组件就是页面上的一部分，大大小小的各种组件拼在一起就变成了一个完整的页面，就像我们玩的拼图，需要一块一块的拼接在一起才能变成一副完整的拼图。</li></ul><h2 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>使用 JS 的函数（或箭头函数）创建的组件，就叫做<code>函数组件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs react">function HelloComponent()&#123;<br>  return (<br>    &lt;div&gt;hello Componnet&lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>组件的名称<strong>必须首字母大写</strong>，react内部会根据这个来判断是组件还是普通的HTML标签</p></li><li><p>函数组件<strong>必须有返回值</strong>，表示该组件的 UI 结构；如果不需要渲染任何内容，则返回 null</p></li><li><p>组件就像 HTML 标签一样可以被渲染到页面中。组件表示的是一段结构内容，对于函数组件来说，渲染的内容是函数的<strong>返回值</strong>就是对应的内容</p></li><li><p>使用函数名称作为组件标签名称，可以成对出现也可以自闭合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs react">function App() &#123;<br>  return (<br>    &lt;div&gt;<br>    &lt;HelloComponent/&gt;<br>    &lt;HelloComponent&gt;&lt;/HelloComponent&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><p>使用 ES6 的 class 创建的组件，叫做类（class）组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">class HelloComponent2 extends React.Component&#123;<br>  //必须有一个render方法<br>  //在这个方法里有return UI 结构<br>  render()&#123;<br>    return (<br>      &lt;div&gt;hello Componnet2&lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>类名称也必须以大写字母开头</strong></li><li>类组件应该继承 React.Component 父类，从而使用父类中提供的方法或属性</li><li>类组件必须提供 render 方法<strong>render 方法必须有返回值，表示该组件的 UI 结构</strong></li></ul><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>react事件采用驼峰命名法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs react">// 事件触发函数组件<br>function EventDemoClass1()&#123;<br>  function handle()&#123;<br>    console.log(&quot;事件触发了EventDemoClass1&quot;)<br>  &#125;<br>  return (<br>    &lt;button onClick=&#123;handle&#125;&gt;事件触发函数组件&lt;/button&gt;<br>  )<br>&#125;<br><br><br>//事件触发类组件<br>class EventDemoClass2 extends React.Component&#123;<br>  clickHandler = () =&gt; &#123;<br>    console.log(&quot;事件触发了EventDemoClass2&quot;)<br>  &#125;<br>  render()&#123;<br>    return (<br>      &lt;div&gt;<br>        &lt;button onClick=&#123;this.clickHandler&#125;&gt;事件触发类组件&lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><br>// 根组件<br>function App() &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;EventDemoClass1&gt;&lt;/EventDemoClass1&gt;<br>     &lt;EventDemoClass2&gt;&lt;/EventDemoClass2&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>依赖混乱</title>
    <link href="/%E4%BE%9D%E8%B5%96%E6%B7%B7%E4%B9%B1/"/>
    <url>/%E4%BE%9D%E8%B5%96%E6%B7%B7%E4%B9%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖混乱"><a href="#依赖混乱" class="headerlink" title="依赖混乱"></a>依赖混乱</h1>]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量的初始化</title>
    <link href="/%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h1><blockquote><ul><li><p><strong>重构手法</strong></p><ul><li><p>变量初始化最好一次完成</p></li><li><blockquote><p>能用final的地方建议都用final，包括变量声明，参数声明，类声明，方法声明</p></blockquote></li></ul></li></ul></blockquote><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">EpubStatus status = <span class="hljs-keyword">null</span>;<br>CreateEpubResponse response = createEpub(request);<br><span class="hljs-keyword">if</span> (response.getCode() == <span class="hljs-number">201</span>) &#123;<br>  status = EpubStatus.CREATED;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  status = EpubStatus.TO_CREATE;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>问题：第一行的初始化没有意义，他真正有值是在第4行或者第6行。也就是说声明变量后很久才赋值。变量初始化和业务混在了一起，我们只有在一大堆逻辑中抽丝剥茧，才可以知道变量是如何初始化的。</li><li>修正：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> CreateEpubResponse response = createEpub(request);<br><span class="hljs-keyword">final</span> EpubStatus status = toEpubStatus(response);<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> EpubStatus <span class="hljs-title">toEpubStatus</span><span class="hljs-params">(<span class="hljs-keyword">final</span> CreateEpubResponse response)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (response.getCode() == <span class="hljs-number">201</span>) &#123;<br>    <span class="hljs-keyword">return</span> EpubStatus.CREATED;<br>  &#125;<br>  <span class="hljs-keyword">return</span> EpubStatus.TO_CREATE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例2（异常处理）"><a href="#案例2（异常处理）" class="headerlink" title="案例2（异常处理）"></a>案例2（异常处理）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream is = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>  is = <span class="hljs-keyword">new</span> FileInputStream(...);<br>  ...<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>  ...<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;<br>    is.close(); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里把is单独声明，是为了在finally里面可以访问到，在早期的版本只能写成这样，java7之后的版本，可以采用<code>try-with-resource</code></p><p>的写法，代码更加简洁。</p><p>修正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (InputStream is = <span class="hljs-keyword">new</span> FileInputStream(...)) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例3-集合初始化"><a href="#案例3-集合初始化" class="headerlink" title="案例3 集合初始化"></a>案例3 集合初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Locale, String&gt; CODE_MAPPING = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>...<br><br><br><span class="hljs-keyword">static</span> &#123;<br>  CODE_MAPPING.put(LOCALE.ENGLISH, <span class="hljs-string">&quot;EN&quot;</span>);<br>  CODE_MAPPING.put(LOCALE.CHINESE, <span class="hljs-string">&quot;CH&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>问题： 隔了很久后才向这个集合中添加元素，如果我们可以使用一次性声明的方式，这个static块是不需要的</p><p>修正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Locale, String&gt; CODE_MAPPING = ImmutableMap.of(<br>  LOCALE.ENGLISH, <span class="hljs-string">&quot;EN&quot;</span>,<br>  LOCALE.CHINESE, <span class="hljs-string">&quot;CH&quot;</span><br>);<br></code></pre></td></tr></table></figure><blockquote><p>前者是命令式的代码，告诉你“怎么做”，比如先创建一个集合，集合中添加一个元素，再添加一个元素。</p><p>后者是声明式代码，告诉你“做什么”，比如我要一个包含了这两个元素的集合。</p></blockquote><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0xl4gnkf5j20u011vn0m.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漫天飞的setter</title>
    <link href="/%E6%BC%AB%E5%A4%A9%E9%A3%9E%E7%9A%84setter/"/>
    <url>/%E6%BC%AB%E5%A4%A9%E9%A3%9E%E7%9A%84setter/</url>
    
    <content type="html"><![CDATA[<h1 id="漫天飞的setter"><a href="#漫天飞的setter" class="headerlink" title="漫天飞的setter"></a>漫天飞的setter</h1><blockquote><ul><li><strong>重构手法</strong>：<ul><li>方法封装在对应的模型中  </li><li>使用构造函数，移除设值函数。</li><li>编写不变类</li></ul></li></ul></blockquote><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">approve</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> bookId)</span> </span>&#123;<br>  ...<br>  book.setReviewStatus(ReviewStatus.APPROVED);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>问题：使用到了setter, setter往往是缺乏封装的一种做法。你不知道数据会在何时被哪里修改，造成结果是别人的改动可能会使你的代码崩溃，同时会有并发问题</li><li>修正：使用函数封装了setter方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">approve</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> bookId)</span> </span>&#123;<br>  ...<br>  book.approve();<br>  ...<br>&#125; <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">approve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.reviewStatus = ReviewStatus.APPROVED;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进一步重构</strong></p><blockquote><p>重构手法：编写不变类</p></blockquote><p>改造之前的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">approve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Book(..., ReviewStatus.APPROVED, ...);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Book book = <span class="hljs-keyword">new</span> Book();<br>book.setBookId(bookId);<br>book.setTitle(title);<br>book.setIntroduction(introduction);<br></code></pre></td></tr></table></figure><ul><li><p>问题：这种初始化的代码，压根没必要以setter的方式存在</p></li><li><p>修正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Book book = <span class="hljs-keyword">new</span> Book(bookId, title, introduction);<br></code></pre></td></tr></table></figure></li></ul><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0um32zjp7j20u01560x5.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过长的消息链和基本类型的偏执</title>
    <link href="/%E8%BF%87%E9%95%BF%E7%9A%84%E6%B6%88%E6%81%AF%E9%93%BE%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%81%8F%E6%89%A7/"/>
    <url>/%E8%BF%87%E9%95%BF%E7%9A%84%E6%B6%88%E6%81%AF%E9%93%BE%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%81%8F%E6%89%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="过长的消息链"><a href="#过长的消息链" class="headerlink" title="过长的消息链"></a>过长的消息链</h1><blockquote><p>想要摆脱初级程序员的水平，首先需要减少暴露细节</p></blockquote><blockquote><p>迪米特法则</p><ul><li>每个单元只能对与他有紧密关系的单元，拥有有限的知识</li><li>每个单元只能和朋友交谈，不与陌生人交谈</li><li>每个单元只能和自己最直接的朋友交谈</li></ul></blockquote><h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String name = book.getAuthor().getName();<br></code></pre></td></tr></table></figure><p>修正方式：隐藏委托关系，即把调用封装起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthorName</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.author.getName();<br>  &#125;<br>  ...<br>&#125;<br><br><br>String name = book.getAuthorName();<br></code></pre></td></tr></table></figure><h1 id="基本类型偏执"><a href="#基本类型偏执" class="headerlink" title="基本类型偏执"></a>基本类型偏执</h1><blockquote><p> <strong>重构手法：以对象取代基本类型</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> highQuality, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> chapterSequence)</span> </span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：虽然价格是用浮点数在存储，但是价格和浮点数本身并不是同一个概念。</p><p><strong>需求1</strong>: </p><p>价格大于0，如果使用了double来存储，你会怎么限制呢？通常会这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (price &lt;= <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Price should be positive&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种校验会是很多场景都需要的，因此类似的逻辑需要大量去重复的写。</p><p>假设这里引入了price模型会是怎样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Price</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> price;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Price</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> price)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (price &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Price should be positive&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">this</span>.price = price;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样校验就可以放在初始化的时候进行了。</p><blockquote><p>这种手法叫做对象取代基本模型。</p></blockquote><p><strong>需求2:</strong></p><p>假设我们希望价格对外只呈现2位。</p><p>没有price这个模型的话 ，依旧会是散布在代码的各个地方，一旦有了这个模型，代码就简单多了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getDisplayPrice</span><span class="hljs-params">()</span> </span>&#123;<br>  BigDecimal decimal = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-keyword">this</span>.price)；<br>  <span class="hljs-keyword">return</span> decimal.setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP).doubleValue();<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ulmqnc59j20u014cq73.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滥用控制语句</title>
    <link href="/%E6%BB%A5%E7%94%A8%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <url>/%E6%BB%A5%E7%94%A8%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="避免滥用控制语句"><a href="#避免滥用控制语句" class="headerlink" title="避免滥用控制语句"></a>避免滥用控制语句</h1><blockquote><p><strong>函数至多有一行锁进</strong></p></blockquote><blockquote><p>不要用else关键字</p></blockquote><h2 id="代码多层嵌套"><a href="#代码多层嵌套" class="headerlink" title="代码多层嵌套"></a>代码多层嵌套</h2><h3 id="if和else"><a href="#if和else" class="headerlink" title="if和else"></a>if和else</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> highQuality, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> chapterSequence)</span> </span>&#123;<br>  <span class="hljs-keyword">double</span> price = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (highQuality &amp;&amp; chapterSequence &gt; START_CHARGING_SEQUENCE) &#123;<br>    price = <span class="hljs-number">4.99</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &gt; START_CHARGING_SEQUENCE<br>        &amp;&amp; sequenceNumber &lt;= FURTHER_CHARGING_SEQUENCE) &#123;<br>    price = <span class="hljs-number">1.99</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &gt; FURTHER_CHARGING_SEQUENCE) &#123;<br>    price = <span class="hljs-number">2.99</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    price = <span class="hljs-number">0.99</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> price;<br>&#125;<br></code></pre></td></tr></table></figure><p>修正：消除else，一个简单的做法就是让逻辑提前返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> highQuality, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> chapterSequence)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (highQuality &amp;&amp; chapterSequence &gt; START_CHARGING_SEQUENCE) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4.99</span>;<br>  &#125; <br>  <br>  <span class="hljs-keyword">if</span> (sequenceNumber &gt; START_CHARGING_SEQUENCE<br>        &amp;&amp; sequenceNumber &lt;= FURTHER_CHARGING_SEQUENCE) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.99</span>;<br>  &#125; <br><br><br>  <span class="hljs-keyword">if</span> (sequenceNumber &gt; FURTHER_CHARGING_SEQUENCE) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2.99</span>;<br>  &#125; <br><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0.99</span>;<br></code></pre></td></tr></table></figure><h2 id="重复的switch"><a href="#重复的switch" class="headerlink" title="重复的switch"></a>重复的switch</h2><p>之所以出现重复的switch，通常是缺少了模型，重构的方式是：<strong>以多态取代表达式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> User user, <span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>  <span class="hljs-keyword">double</span> price = book.getPrice();<br>  <span class="hljs-keyword">switch</span> (user.getLevel()) &#123;<br>    <span class="hljs-keyword">case</span> UserLevel.SILVER:<br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.9</span>;<br>    <span class="hljs-keyword">case</span> UserLevel.GOLD: <br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.8</span>;<br>    <span class="hljs-keyword">case</span> UserLevel.PLATINUM:<br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.75</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> price;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> User user, <span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>  <span class="hljs-keyword">double</span> price = epub.getPrice();<br>  <span class="hljs-keyword">switch</span> (user.getLevel()) &#123;<br>    <span class="hljs-keyword">case</span> UserLevel.SILVER:<br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.95</span>;<br>    <span class="hljs-keyword">case</span> UserLevel.GOLD: <br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.85</span>;<br>    <span class="hljs-keyword">case</span> UserLevel.PLATINUM:<br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.8</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> price;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserLevel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(Book book)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(Epub epub)</span></span>;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegularUserLevel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserLevel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> book.getPrice();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> epub.getPrice();<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoldUserLevel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserLevel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> book.getPrice() * <span class="hljs-number">0.8</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> epub.getPrice() * <span class="hljs-number">0.85</span>;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SilverUserLevel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserLevel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> book.getPrice() * <span class="hljs-number">0.9</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> epub.getPrice() * <span class="hljs-number">0.85</span>;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlatinumUserLevel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserLevel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> book.getPrice() * <span class="hljs-number">0.75</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> epub.getPrice() * <span class="hljs-number">0.8</span>; <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> User user, <span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>  UserLevel level = user.getUserLevel()<br>  <span class="hljs-keyword">return</span> level.getBookPrice(book);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> User user, <span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>  UserLevel level = user.getUserLevel()<br>  <span class="hljs-keyword">return</span> level.getEpubPrice(epub);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0tg6oeum7j20u012242l.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长参数列表</title>
    <link href="/%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/"/>
    <url>/%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="消除长参数列表"><a href="#消除长参数列表" class="headerlink" title="消除长参数列表"></a>消除长参数列表</h1><ul><li><blockquote><p><strong>我们应该编写“短小”的代码</strong></p></blockquote></li><li><blockquote><p> <strong>参数列表越少，越好</strong></p></blockquote></li><li><blockquote><p>**一个方法的第一选择是没有参数，第二个选择是只有一个参数，稍次是两个参数。三个以上的参数简直无法忍受。 **– 代码整洁之道</p></blockquote></li></ul><h2 id="将参数列表封装成对象"><a href="#将参数列表封装成对象" class="headerlink" title="将参数列表封装成对象"></a>将参数列表封装成对象</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createBook</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String title, </span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> String introduction,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> URL coverUrl,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> BookType type,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> BookChannel channel,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> String protagonists,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> String tags,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> completed)</span> </span>&#123;<br>  ...<br>  Book book = Book.builder<br>    .title(title) <br>    .introduction(introduction)<br>    .coverUrl(coverUrl)<br>    .type(type)<br>    .channel(channel)<br>    .protagonists(protagonists)<br>    .tags(tags)<br>    .completed(completed)<br>    .build();<br>    <br>  <span class="hljs-keyword">this</span>.repository.save(book);<br>&#125;<br></code></pre></td></tr></table></figure><p>修正：</p><ul><li>增加一个封装类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewBookParamters</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String title;<br>  <span class="hljs-keyword">private</span> String introduction;<br>  <span class="hljs-keyword">private</span> URL coverUrl;<br>  <span class="hljs-keyword">private</span> BookType type;<br>  <span class="hljs-keyword">private</span> BookChannel channel;<br>  <span class="hljs-keyword">private</span> String protagonists;<br>  <span class="hljs-keyword">private</span> String tags;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> completed;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createBook</span><span class="hljs-params">(<span class="hljs-keyword">final</span> NewBookParamters parameters)</span> </span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移除标记参数"><a href="#移除标记参数" class="headerlink" title="移除标记参数"></a>移除标记参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">editChapter</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> chapterId, </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> String title, </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> String content, </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> apporved)</span> </span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：前几个参数都是章节的必要信息，后面apporved是标记是否审核通过，这个参数其实是一个标记，标记后面的流程可能不同。</p><p>修正：这里我们可以将参数列表代表的不同路径拆分出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 普通的编辑，需要审核</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">editChapter</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> chapterId, </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> String title, </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> String content)</span> </span>&#123;<br>  ...<br>&#125;<br><br><br><span class="hljs-comment">// 直接审核通过的编辑</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">editChapterWithApproval</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> chapterId,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">final</span> String title,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">final</span> String content)</span> </span>&#123;<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0tf9jp9lvj20u014kq7o.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>避免写出难以理解的大类</title>
    <link href="/%E9%81%BF%E5%85%8D%E5%86%99%E5%87%BA%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84%E5%A4%A7%E7%B1%BB%20/"/>
    <url>/%E9%81%BF%E5%85%8D%E5%86%99%E5%87%BA%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84%E5%A4%A7%E7%B1%BB%20/</url>
    
    <content type="html"><![CDATA[<h2 id="避免写出难以理解的大类"><a href="#避免写出难以理解的大类" class="headerlink" title="避免写出难以理解的大类"></a>避免写出难以理解的大类</h2><ul><li>原因：一个人理解的东西是有限的，没人能面对所有的细节</li><li>大类的产生：<ul><li>职责不单一 </li><li>字段未分组</li></ul></li><li>操作要点：<strong>把类写小，越小越好</strong></li></ul><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1:"></a>案例1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String nickname;<br>  <span class="hljs-keyword">private</span> String email;<br>  <span class="hljs-keyword">private</span> String phoneNumber;<br>  <span class="hljs-keyword">private</span> AuthorType authorType;<br>  <span class="hljs-keyword">private</span> ReviewStatus authorReviewStatus;<br>  <span class="hljs-keyword">private</span> EditorType editorType;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：userId,name这些是和用户关联的，后面的AuthorType，ReviewStatus，EditorType和用户信息无关</p><p>修正：AuthorType，ReviewStatus，EditorType和用户信息无关 拆成单独的类，通过userId去关联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;<br>  <span class="hljs-keyword">private</span> AuthorType authorType;<br>  <span class="hljs-keyword">private</span> ReviewStatus authorReviewStatus;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Editor</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;<br>  <span class="hljs-keyword">private</span> EditorType editorType;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String nickname;<br>  <span class="hljs-keyword">private</span> String email;<br>  <span class="hljs-keyword">private</span> String phoneNumber;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：这个类中userId，name，nickname是属于用户的基本信息，而email，phoneNumber其实是属于用户的联系方式</p><p>修正：对字段进行分组，把email，phoneNumber放在单独的contact类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String nickname;<br>  <span class="hljs-keyword">private</span> Contact contact;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contact</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String email;<br>  <span class="hljs-keyword">private</span> String phoneNumber;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0tekaz2v6j20u0144gow.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何精准命名</title>
    <link href="/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="如何精准命名"><a href="#如何精准命名" class="headerlink" title="如何精准命名"></a>如何精准命名</h1><h2 id="避免命名过于宽泛"><a href="#避免命名过于宽泛" class="headerlink" title="避免命名过于宽泛"></a>避免命名过于宽泛</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processChapter</span><span class="hljs-params">(<span class="hljs-keyword">long</span> chapterId)</span> </span>&#123;<br>  Chapter chapter = <span class="hljs-keyword">this</span>.repository.findByChapterId(chapterId);<br>  <span class="hljs-keyword">if</span> (chapter == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unknown chapter [&quot;</span> + chapterId + <span class="hljs-string">&quot;]&quot;</span>);  <br>  &#125;<br>  <br>  chapter.setTranslationState(TranslationState.TRANSLATING);<br>  <span class="hljs-keyword">this</span>.repository.save(chapter);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>问题：命名过于宽泛，不能精准描述，只有阅读这段代码，才可以知道这段代码做了什么。</p></li><li><p>修正：具体到这里的业务，其实是把翻译状态改为了翻译中，是因为我们在这里开启了一个翻译过程，所以这段代码应该命名为satrtTranslation</p></li></ul><blockquote><p> 类似的：data,info,handle,build,maintain,modify等等，都是过于宽泛的名词</p></blockquote><blockquote><p>一个好的名字，应该描述意图，而不是细节。</p></blockquote><h2 id="避免使用技术术语命名"><a href="#避免使用技术术语命名" class="headerlink" title="避免使用技术术语命名"></a>避免使用技术术语命名</h2><h3 id="案例1-1"><a href="#案例1-1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Book&gt; bookList = service.getBooks();<br></code></pre></td></tr></table></figure><ul><li>问题：这是一种基于实现的命名，编程的一个重要原则是面向接口编程。即接口是稳定的，实现是易变的。假设这里我现在需要的是一个不重复的作品集合，也就是说这里需要把List改成Set，变量类型一定会改，但是你不一定会记得改变量名，一旦遗忘，就会出现一个bookList变量，它的类型是set,就会产生混淆。</li><li>修正：这里要表达的是拿到一堆书，所以这个命名改为books。</li></ul><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getByIsbn</span><span class="hljs-params">(String isbn)</span> </span>&#123;<br>  Book cachedBook = redisBookStore.get(isbn);<br>  <span class="hljs-keyword">if</span> (cachedBook != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> cachedBook;<br>  &#125;<br>  <br>  Book book = doGetByIsbn(isbn);<br>  redisBookStore.put(isbn, book);<br>  <span class="hljs-keyword">return</span> book;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>问题：这段代码里直接出现了redis，通常来说这里真正需要的只是一个缓存，redi s只是一种实现</li></ul><blockquote><p>缓存只是一种技术术语，不应该出现在业务代码中</p></blockquote><blockquote><p>程序猿之所以喜欢用技术语言去命名，是因为程序员写代码很大程度上会参考别人写的代码，而行业里比较优秀的一些代码，往往是一些开源的技术项目。</p></blockquote><blockquote><p>在一个技术类项目里，这些技术术语其实就是他们的业务语言，但是在业务项目里，这个说法就要另当别论了。</p></blockquote><h2 id="避免违反语法规则的命名"><a href="#避免违反语法规则的命名" class="headerlink" title="避免违反语法规则的命名"></a>避免违反语法规则的命名</h2><h3 id="案例1-2"><a href="#案例1-2" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completedTranslate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> List&lt;ChapterId&gt; chapterIds)</span> </span>&#123;<br>  List&lt;Chapter&gt; chapters = repository.findByChapterIdIn(chapterIds);<br>  chapters.forEach(Chapter::completedTranslate);<br>  repository.saveAll(chapters); <br>&#125;<br></code></pre></td></tr></table></figure><p>问题：completedTranslate不是一个正常的英语函数名</p><p>修正: completeTranslation</p><blockquote><p>常见的命名规则是：类是一个名词，表示一个对象。方法名是一个动词或者是动宾短语，表示一个动作。</p></blockquote><p>另外还有两个常见的坏味道这里就不举例了。</p><ul><li>不准确的英语词汇（对于业务上会用到的一些名词，可以整个团队一起，建立一个业务词汇表，用集体的智慧）</li><li>单词拼写错误</li></ul><h2 id="用业务语言写代码"><a href="#用业务语言写代码" class="headerlink" title="用业务语言写代码"></a>用业务语言写代码</h2><h3 id="案例1-3"><a href="#案例1-3" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">approveChapter</span><span class="hljs-params">(<span class="hljs-keyword">long</span> chapterId, <span class="hljs-keyword">long</span> userId)</span> </span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：这个函数的意图是确认章节通过，chapterId是章节id，但是userId是什么？了解了背景才知道这里是需要记录下审核人的信息，这个userId就是审核人的userId，</p><p>修正：因为用户在这个场景下的身份是审核人，所以修改userId为reviewerUserId</p><blockquote><p>好的命名，是体现业务含义的命名。</p></blockquote><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oruapf6nj20u012ggpo.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>excel读取操作</title>
    <link href="/excel%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C/"/>
    <url>/excel%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="excel-读取"><a href="#excel-读取" class="headerlink" title="excel 读取"></a>excel 读取</h1><h2 id="HSSF-03"><a href="#HSSF-03" class="headerlink" title="HSSF(03)"></a>HSSF(03)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRead03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(PATH+<span class="hljs-string">&quot;/excel写入.xls&quot;</span>);<br>  <span class="hljs-keyword">final</span> HSSFWorkbook workbook = <span class="hljs-keyword">new</span> HSSFWorkbook(inputStream);<br>  <span class="hljs-keyword">final</span> HSSFSheet sheet = workbook.getSheetAt(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">final</span> HSSFRow row = sheet.getRow(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">final</span> HSSFCell cell = row.getCell(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 读取值的时候，一定要注意类型！！</span><br>  <span class="hljs-keyword">final</span> String cellValue = cell.getStringCellValue();<br>  System.out.println(cellValue);<br>  inputStream.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="XSSF-07"><a href="#XSSF-07" class="headerlink" title="XSSF(07)"></a>XSSF(07)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRead07</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(PATH+<span class="hljs-string">&quot;/excel写入.xlsx&quot;</span>);<br>  <span class="hljs-keyword">final</span> XSSFWorkbook workbook = <span class="hljs-keyword">new</span> XSSFWorkbook(inputStream);<br>  <span class="hljs-keyword">final</span> XSSFSheet sheet = workbook.getSheetAt(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">final</span> XSSFRow row = sheet.getRow(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">final</span> XSSFCell cell = row.getCell(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">final</span> String cellValue = cell.getStringCellValue();<br>  System.out.println(cellValue);<br>  inputStream.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读取不同类型的数据"><a href="#读取不同类型的数据" class="headerlink" title="读取不同类型的数据"></a>读取不同类型的数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCellType</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/Users/panyurou/IdeaProjects/exceldemo/src/test/resources/明细表.xlsx&quot;</span>);<br>    <span class="hljs-keyword">final</span> XSSFWorkbook workbook = <span class="hljs-keyword">new</span> XSSFWorkbook(inputStream);<br>    <span class="hljs-comment">// 读取标题行</span><br>    <span class="hljs-keyword">final</span> XSSFSheet sheet = workbook.getSheetAt(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">final</span> XSSFRow headerRow = sheet.getRow(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> colCount = headerRow.getPhysicalNumberOfCells();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; colCount; i++) &#123;<br>      <span class="hljs-keyword">final</span> XSSFCell cell = headerRow.getCell(i);<br>      <span class="hljs-keyword">if</span>(cell != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">final</span> String cellValue = cell.getStringCellValue();<br>        System.out.print(cellValue + <span class="hljs-string">&quot;|&quot;</span>);<br>      &#125;<br>    &#125;<br>    System.out.println();<br>    <span class="hljs-comment">// 读取内容</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rowsCount = sheet.getPhysicalNumberOfRows();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rowsCount; i++) &#123;<br>      <span class="hljs-keyword">final</span> XSSFRow row = sheet.getRow(i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; colCount; j++) &#123;<br>        <span class="hljs-keyword">final</span> XSSFCell cell = row.getCell(j);<br>        <span class="hljs-keyword">if</span>(cell != <span class="hljs-keyword">null</span>)&#123;<br>          <span class="hljs-keyword">final</span> CellType cellType = cell.getCellType();<br>          String cellValue = getCellValue(cell, cellType);<br>          System.out.print(cellValue + <span class="hljs-string">&quot;|&quot;</span>);<br>        &#125;<br>      &#125;<br>      System.out.println();<br>    &#125;<br>    inputStream.close();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getCellValue</span><span class="hljs-params">(XSSFCell cell, CellType cellType)</span> </span>&#123;<br>    String cellValue = <span class="hljs-string">&quot;&quot;</span>;<br>     <span class="hljs-keyword">switch</span> (cellType)&#123;<br>      <span class="hljs-keyword">case</span> STRING:<br>        cellValue = cell.getStringCellValue();<br>         <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> NUMERIC:<br>         <span class="hljs-keyword">if</span>(DateUtil.isCellDateFormatted(cell))&#123;<br>           <span class="hljs-keyword">final</span> Date date = cell.getDateCellValue();<br>           cellValue = <span class="hljs-keyword">new</span> DateTime(date).toString(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>           cellValue = String.valueOf(cell.getNumericCellValue());<br>         &#125;<br>         <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> FORMULA:<br>        cellValue = cell.getCellFormula();<br>         <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> BOOLEAN:<br>        cellValue = String.valueOf(cell.getBooleanCellValue());<br>         <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> ERROR:<br>         System.out.println(<span class="hljs-string">&quot;类型错误&quot;</span>);<br>         <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cellValue;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>excel大数据量的写入</title>
    <link href="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%86%99%E5%85%A5/"/>
    <url>/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%86%99%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="大数据量的写入"><a href="#大数据量的写入" class="headerlink" title="大数据量的写入"></a>大数据量的写入</h1><h2 id="HSSF-03版"><a href="#HSSF-03版" class="headerlink" title="HSSF(03版)"></a>HSSF(03版)</h2><ul><li><p>优点：过程中数据全部写入缓存，不操作磁盘，最后一次写入缓存，速度快</p></li><li><p>缺点：最多只能处理65536行，否则会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Invalid row <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">65536</span>)</span> outside allowable <span class="hljs-title">range</span> <span class="hljs-params">(<span class="hljs-number">0.</span><span class="hljs-number">.65535</span>)</span></span><br><span class="hljs-function">java.lang.IllegalArgumentException: Invalid row <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">65536</span>)</span> outside allowable <span class="hljs-title">range</span> <span class="hljs-params">(<span class="hljs-number">0.</span><span class="hljs-number">.65535</span>)</span></span><br></code></pre></td></tr></table></figure></li></ul><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p><strong>抛出异常测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelBigData</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String PATH = <span class="hljs-string">&quot;/Users/panyurou/IdeaProjects/exceldemo&quot;</span>;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excelWrite03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Workbook workbook = <span class="hljs-keyword">new</span> HSSFWorkbook();<br>    <span class="hljs-keyword">final</span> Sheet sheet = workbook.createSheet(<span class="hljs-string">&quot;测试大数据量&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">65537</span>; i++) &#123;<br>      <span class="hljs-keyword">final</span> Row row = sheet.createRow(i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>        <span class="hljs-keyword">final</span> Cell cell = row.createCell(j);<br>        cell.setCellValue(<span class="hljs-string">&quot;$&#123;i,j&#125;&quot;</span>);<br>      &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;over!&quot;</span>);<br>    FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(PATH + <span class="hljs-string">&quot;/excel大数据写入01.xls&quot;</span>);<br>    workbook.write(outputStream);<br>    outputStream.close();<br>    System.out.println(<span class="hljs-string">&quot;excel 写入完毕！&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;写入时间：&quot;</span>+(<span class="hljs-keyword">double</span>) ((end - begin) / <span class="hljs-number">1000</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232505454.png" alt="image-20230228232505454"></p><p>将上面的65537改成65536，输出写入时长，可看出花费了1秒</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232512748.png" alt="image-20230228232512748"></p><h2 id="SXSSFWorkbook"><a href="#SXSSFWorkbook" class="headerlink" title="SXSSFWorkbook"></a>SXSSFWorkbook</h2><ul><li>优点：可以写非常大的数据量，写速度更快，占用更少的内存</li><li>注意：<ul><li>过程中会产生临时文件，需要清理临时文件</li><li>默认100条数据会被保留在内存中，如果超过这数量，则数据会被写入临时文件<ul><li>如果想自定义内存中的数量，可以使用<code>new SXSSFWorkbook(数量);</code></li></ul></li></ul></li></ul><h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excelWriteSXSSF</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SXSSFWorkbook workbook = <span class="hljs-keyword">new</span> SXSSFWorkbook();<br>    <span class="hljs-keyword">final</span> Sheet sheet = workbook.createSheet(<span class="hljs-string">&quot;测试大数据量&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">65537</span>; i++) &#123;<br>      <span class="hljs-keyword">final</span> Row row = sheet.createRow(i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">120</span>; j++) &#123;<br>        <span class="hljs-keyword">final</span> Cell cell = row.createCell(j);<br>        cell.setCellValue(<span class="hljs-string">&quot;$&#123;i,j&#125;&quot;</span>);<br>      &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;over!&quot;</span>);<br>    FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(PATH + <span class="hljs-string">&quot;/excel大数据写入09s.xlsx&quot;</span>);<br>    workbook.write(outputStream);<br>    outputStream.close();<br>    <span class="hljs-comment">// 清除临时文件！！！</span><br>    workbook.dispose();<br>    System.out.println(<span class="hljs-string">&quot;excel 写入完毕！&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;写入时间：&quot;</span>+(<span class="hljs-keyword">double</span>) ((end - begin) / <span class="hljs-number">1000</span>));<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看出即使现在有120列，也只需要10秒，速度很快。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228232535340.png" alt="image-20230228232535340"></p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Excel基本写操作</title>
    <link href="/excel%E6%93%8D%E4%BD%9C/"/>
    <url>/excel%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Excel基本写操作"><a href="#Excel基本写操作" class="headerlink" title="Excel基本写操作"></a>Excel基本写操作</h1><ul><li>引入依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.apache.poi:poi:5.2.0&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelWrite</span> </span>&#123;<br>  <span class="hljs-comment">// 项目目录</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String PATH = <span class="hljs-string">&quot;/Users/panyurou/IdeaProjects/exceldemo&quot;</span>;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excelWrite</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//1.创建一个工作簿</span><br>    Workbook workbook = <span class="hljs-keyword">new</span> HSSFWorkbook();<br>    <span class="hljs-comment">//2.创建一个工作表</span><br>    Sheet sheet = workbook.createSheet(<span class="hljs-string">&quot;测试excel写入&quot;</span>);<br>    <span class="hljs-comment">//3.创建一行,第0行</span><br>    Row row1 = sheet.createRow(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//4.创建一个单元格</span><br>    Cell cell11 = row1.createCell(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//5.给单元格写入值</span><br>    cell11.setCellValue(<span class="hljs-string">&quot;我是单元格（1，1）&quot;</span>);<br><br>    <span class="hljs-comment">//6.创建新的一行,第1行</span><br>    Row row2 = sheet.createRow(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//7.创建一个单元格</span><br>    Cell cell21 = row2.createCell(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//8.给单元格写入值</span><br>    String time = <span class="hljs-keyword">new</span> DateTime().toString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    cell21.setCellValue(time);<br><br>    <span class="hljs-comment">//9.将创建好的工作簿写出</span><br>    FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(PATH + <span class="hljs-string">&quot;/excel写入.xlsx&quot;</span>);<br>    workbook.write(outputStream);<br>    outputStream.close();<br>    System.out.println(<span class="hljs-string">&quot;excel 写入完毕！&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gpje9k7lj20os0r6jt6.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch乐观并发控制</title>
    <link href="/ElasticSearch%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/ElasticSearch%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch乐观并发控制"><a href="#Elasticsearch乐观并发控制" class="headerlink" title="Elasticsearch乐观并发控制"></a>Elasticsearch乐观并发控制</h1><p>Elasticsearch 中使用的这种乐观的方式假定冲突是不可能发生的，并且不会阻塞正在 尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。 </p><blockquote><p>在数据库领域中，有两种方法来确保并发更新，不会丢失数据： 分别为乐观和悲观</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>以创建一个文档为例 </p><p>step1: 创建文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /test1/_doc/<span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-string">&quot;Id&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三丰&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;_index&quot;</span> : <span class="hljs-string">&quot;test1&quot;</span>,<br>  <span class="hljs-string">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>  <span class="hljs-string">&quot;_id&quot;</span> : <span class="hljs-string">&quot;1&quot;</span>,<br>  <span class="hljs-string">&quot;_version&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;result&quot;</span> : <span class="hljs-string">&quot;created&quot;</span>,<br>  <span class="hljs-string">&quot;_shards&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;total&quot;</span> : <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;successful&quot;</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;failed&quot;</span> : <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-string">&quot;_seq_no&quot;</span> : <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;_primary_term&quot;</span> : <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用if_seq_no&#x3D;版本值 &amp;if_primary_term&#x3D;文档位置进行并发版本控制</strong></p><ul><li><p>_seq_no：文档版本号，<strong>version属于当个文档，而seq_no属于整个index</strong></p></li><li><p>_primary_term：_primary_term也和_seq_no一样都是整数，每当Primary Shard发生重新分配时，比如重启，Primary选举等，_primary_term会递增1</p></li></ul><p>step2: 更新文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /test1/_update/<span class="hljs-number">1</span>/?if_seq_no=<span class="hljs-number">0</span>&amp;if_primary_term=<span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-string">&quot;doc&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三丰666&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;_index&quot;</span> : <span class="hljs-string">&quot;test1&quot;</span>,<br>  <span class="hljs-string">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>  <span class="hljs-string">&quot;_id&quot;</span> : <span class="hljs-string">&quot;1&quot;</span>,<br>  <span class="hljs-string">&quot;_version&quot;</span> : <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;result&quot;</span> : <span class="hljs-string">&quot;updated&quot;</span>,<br>  <span class="hljs-string">&quot;_shards&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;total&quot;</span> : <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;successful&quot;</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;failed&quot;</span> : <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-string">&quot;_seq_no&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;_primary_term&quot;</span> : <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch文档映射</title>
    <link href="/ElasticSearch%E6%96%87%E6%A1%A3%E6%98%A0%E5%B0%84/"/>
    <url>/ElasticSearch%E6%96%87%E6%A1%A3%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="文档映射"><a href="#文档映射" class="headerlink" title="文档映射"></a>文档映射</h1><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>ES中映射可以分为动态映射和静态映射 </p><h3 id="动态映射："><a href="#动态映射：" class="headerlink" title="动态映射："></a>动态映射：</h3><p>在关系数据库中，需要事先创建数据库，然后在该数据库下创建数据表，并创建 表字段、类型、长度、主键等，最后才能基于表插入数据。而Elasticsearch中不需要定义Mapping映射（即关系型数据库的表、字段等），在文档写入Elasticsearch时，会根据文档字段自动识别类型，这种机制称之为动态映射。 </p><p>动态映射规则如下： </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228233355466.png" alt="image-20230228233355466"></p><p><strong>操作示例</strong></p><ul><li>创建文档(ES根据数据类型, 会自动创建映射)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db1/_doc/<span class="hljs-number">32</span><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王武&quot;</span>,<br>  <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">28</span>,<br>  <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;remark&quot;</span>: <span class="hljs-string">&quot;java developer&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>获取文档映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">GET /es_db1/_mapping<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;es_db1&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;mappings&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;properties&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;address&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-string">&quot;fields&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;keyword&quot;</span> : &#123;<br>              <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;keyword&quot;</span>,<br>              <span class="hljs-string">&quot;ignore_above&quot;</span> : <span class="hljs-number">256</span><br>            &#125;<br>          &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;age&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;long&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;name&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-string">&quot;fields&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;keyword&quot;</span> : &#123;<br>              <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;keyword&quot;</span>,<br>              <span class="hljs-string">&quot;ignore_above&quot;</span> : <span class="hljs-number">256</span><br>            &#125;<br>          &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;remark&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-string">&quot;fields&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;keyword&quot;</span> : &#123;<br>              <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;keyword&quot;</span>,<br>              <span class="hljs-string">&quot;ignore_above&quot;</span> : <span class="hljs-number">256</span><br>            &#125;<br>          &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;sex&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;long&quot;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态映射："><a href="#静态映射：" class="headerlink" title="静态映射："></a>静态映射：</h3><p>静态映射是在Elasticsearch中也可以事先定义好映射，包含文档的各字段类型、分词器等，这种方式称之为静态映射。 </p><p><strong>操作示例</strong></p><ul><li>创建索引和设置文档映射 <ul><li>index: 是否分词存储</li><li>store: 是否存储在库里</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">PUT /es_db4<br>&#123;<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-keyword">true</span>,<br>        <span class="hljs-string">&quot;store&quot;</span>: <span class="hljs-keyword">true</span><br>      &#125;,<br>      <span class="hljs-string">&quot;sex&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-keyword">true</span>,<br>        <span class="hljs-string">&quot;store&quot;</span>: <span class="hljs-keyword">true</span><br>      &#125;,<br>      <span class="hljs-string">&quot;age&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-keyword">true</span>,<br>        <span class="hljs-string">&quot;store&quot;</span>: <span class="hljs-keyword">true</span><br>      &#125;,<br>      <span class="hljs-string">&quot;book&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-keyword">true</span>,<br>        <span class="hljs-string">&quot;store&quot;</span>: <span class="hljs-keyword">true</span><br>      &#125;,<br>      <span class="hljs-string">&quot;address&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-keyword">true</span>,<br>        <span class="hljs-string">&quot;store&quot;</span>: <span class="hljs-keyword">true</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;es_db4&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;mappings&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;properties&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;address&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-string">&quot;store&quot;</span> : <span class="hljs-keyword">true</span><br>        &#125;,<br>        <span class="hljs-string">&quot;age&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;integer&quot;</span>,<br>          <span class="hljs-string">&quot;store&quot;</span> : <span class="hljs-keyword">true</span><br>        &#125;,<br>        <span class="hljs-string">&quot;book&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-string">&quot;store&quot;</span> : <span class="hljs-keyword">true</span><br>        &#125;,<br>        <span class="hljs-string">&quot;name&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;keyword&quot;</span>,<br>          <span class="hljs-string">&quot;store&quot;</span> : <span class="hljs-keyword">true</span><br>        &#125;,<br>        <span class="hljs-string">&quot;sex&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;integer&quot;</span>,<br>          <span class="hljs-string">&quot;store&quot;</span> : <span class="hljs-keyword">true</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据静态映射创建文档</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">PUT /es_db/_doc/<span class="hljs-number">4</span><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jack&quot;</span>,<br>  <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-string">&quot;book&quot;</span>: <span class="hljs-string">&quot;elasticSearch入门至精通&quot;</span>,<br>  <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;广州车陂&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>获取文档映射</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET <span class="hljs-regexp">/es_db4/</span>_mapping<br></code></pre></td></tr></table></figure><h2 id="文档核心类型（Core-datatype）"><a href="#文档核心类型（Core-datatype）" class="headerlink" title="文档核心类型（Core datatype）"></a>文档核心类型（Core datatype）</h2><h3 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h3><ul><li>字符串：string，string类型包含 text 和 keyword。 </li><li>text：该类型被用来索引长文本，在创建索引前会将这些文本进行分词，转化为词的组合，建立索引；允许es来检索这些词，text类型不能用来排序和聚合。</li><li>keyword：该类型不能分词，可以被用来检索过滤、排序和聚合，keyword类型不可用text进行分词模糊检索。</li><li>数值型：long、integer、short、byte、double、float </li><li>日期型：date </li><li>布尔型：boolean</li></ul><p><strong>通过term 和 match查询数据时细节点以及数据类型keyword与text区别</strong></p><ul><li><strong>term查询</strong><ul><li>term查询keyword字段: term不会分词。而keyword字段也不分词。需要完全匹配才可</li><li>term查询text字段: 因为text字段会分词，而term不分词，所以term查询的条件必须是text字段分词后的某一个</li></ul></li><li><strong>match查询</strong><ul><li>match会被分词，而keyword不会被分词，match的需要跟keyword的完全匹配可以。</li><li>match分词，text也分词，只要match的分词结果和text的分词结果有相同的就匹配</li></ul></li></ul><h2 id="对已存在的mapping映射进行修改"><a href="#对已存在的mapping映射进行修改" class="headerlink" title="对已存在的mapping映射进行修改"></a>对已存在的mapping映射进行修改</h2><ul><li>重新建立一个静态索引 ,把之前索引里的数据导入到新的索引里</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">POST _reindex<br>&#123;<br>  <span class="hljs-string">&quot;source&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;es_db&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;dest&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;es_db_2&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：_reindex 会同时把之前索引里的数据导入到新的索引里 </p></blockquote><ul><li>删除原创建的索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hava">DELETE /es_db<br></code></pre></td></tr></table></figure><ul><li>为新索引起个别名, 为原索引名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PUT /es_db_2/_alias/es_db<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch-DSL语言高级查询</title>
    <link href="/ElasticSearch-DSL%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/"/>
    <url>/ElasticSearch-DSL%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="DSL语言高级查询"><a href="#DSL语言高级查询" class="headerlink" title="DSL语言高级查询"></a>DSL语言高级查询</h1><ul><li>Elasticsearch提供了基于JSON的DSL来定义查询。 </li><li>DSL由叶子查询子句和复合查询子句两种子句组成</li></ul><blockquote><p>DSL(Domain Specific Language)领域专用语言 </p></blockquote><h2 id="无查询条件"><a href="#无查询条件" class="headerlink" title="无查询条件"></a>无查询条件</h2><p>无查询条件是查询所有，默认是查询所有的，或者使用match_all表示所有 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">GET /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有查询条件"><a href="#有查询条件" class="headerlink" title="有查询条件"></a>有查询条件</h2><h3 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h3><ul><li><p>模糊匹配主要是针对文本类型的字段</p></li><li><p>文本类型的字段会对内容进行分词，对查询时，也会对搜索条件进行分词，然后通过倒排索引查找到匹配的数据</p></li><li><p>模糊匹配主要通过match等参数来实现 </p><ul><li>match : 通过match关键词模糊匹配条件内容,match会根据该字段的分词器，进行分词查询</li><li>prefix : 前缀匹配</li><li>regexp : 通过正则表达式来匹配数据</li></ul></li></ul><p> <strong>举例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;广州&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SQL: select * from user where address like ‘%广州%’ limit 0, 2 </p></blockquote><ul><li>多字段模糊匹配查询 multi_match</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;广州公园&quot;</span>,<br>      <span class="hljs-string">&quot;fields&quot;</span>: [<br>        <span class="hljs-string">&quot;address&quot;</span>,<br>        <span class="hljs-string">&quot;name&quot;</span><br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SQL: select * from student where name like ‘%广州公园%’ or address like ‘%广州公园%’ </p></blockquote><ul><li>未指定字段条件查询 query_string , 含 AND 与 OR 条件</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;query_string&quot;: &#123;<br>      &quot;query&quot;: &quot;(广州) OR 长沙&quot;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>指定字段条件查询 query_string , 含 AND 与 OR 条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;query_string&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;(广州) OR 长沙&quot;</span>,<br>      <span class="hljs-string">&quot;fields&quot;</span>:[<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>范围查询<ul><li>range：范围关键字 </li><li>gte 大于等于</li><li>lte 小于等于 </li><li>gt 大于 </li><li>lt 小于</li><li>now 当前时间</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>:&#123;<br>    <span class="hljs-string">&quot;range&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;age&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;gte&quot;</span>:<span class="hljs-number">25</span>,<br>        <span class="hljs-string">&quot;lte&quot;</span>:<span class="hljs-number">28</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SQL: select * from user where age between 25 and 28 </p></blockquote><ul><li>分页、输出字段、排序综合查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>:&#123;<br>    <span class="hljs-string">&quot;range&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;age&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;gte&quot;</span>:<span class="hljs-number">25</span>,<br>        <span class="hljs-string">&quot;lte&quot;</span>:<span class="hljs-number">28</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;_source&quot;</span>: [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;book&quot;</span>],<br>  <span class="hljs-string">&quot;sort&quot;</span>: &#123;<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-string">&quot;desc&quot;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Filter过滤器方式查询"><a href="#Filter过滤器方式查询" class="headerlink" title="Filter过滤器方式查询"></a>Filter过滤器方式查询</h2><p>它的查询不会计算相关性分值，也不会对结果进行排序, 因此效率会高一点，查询的结果可以被缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;term&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>match: 模糊匹配，需要指定字段名，但是输入会进行分词，比如”hello world”会进行拆分为hello和world，然后匹配，如果字段中包含hello或者 world，或者都包含的结果都会被查询出来，也就是说match是一个部分匹配的模糊查询。查询条件相对来说比较宽松。 </p></li><li><p>term：这种查询和match在有些时候是等价的，比如我们查询单个的词hello，那么会和match查询结果一样，但是如果查询”hello world”，结果就相差很大，因为这个输入不会进行分词，就是说查询的时候，是查询字段分词结果中是否有”hello world”的字样，而不是查询字段中包含”hello world”的字样。当保存 </p><p>数据”hello world”时，elasticsearch会对字段内容进行分词，”hello world”会被分成hello和world，不存在”hello world”，因此这里的查询结果会为空。这也是term查询和match的区别。</p></li><li><p>query_string：和match类似，但是match需要指定字段名，query_string是在所 </p><p>有字段中搜索，范围更广泛。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch文档批量操作</title>
    <link href="/ElasticSearch%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/"/>
    <url>/ElasticSearch%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="文档批量操作"><a href="#文档批量操作" class="headerlink" title="文档批量操作"></a><strong>文档批量操作</strong></h1><h2 id="批量获取文档数据"><a href="#批量获取文档数据" class="headerlink" title="批量获取文档数据"></a>批量获取文档数据</h2><blockquote><p>批量获取文档数据是通过_mget的API来实现的 </p></blockquote><h3 id="在URL中不指定index和type"><a href="#在URL中不指定index和type" class="headerlink" title="在URL中不指定index和type"></a>在URL中不指定index和type</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> _mget<br>&#123;<br>  &quot;docs&quot;: [<br>    &#123;<br>      &quot;_index&quot;: &quot;es_db&quot;,<br>      &quot;_type&quot;: &quot;_doc&quot;,<br>      &quot;_id&quot;: <span class="hljs-number">1</span><br>    &#125;,<br>    &#123;<br>      &quot;_index&quot;: &quot;es_db&quot;,<br>      &quot;_type&quot;: &quot;_doc&quot;,<br>      &quot;_id&quot;: <span class="hljs-number">2</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在URL中指定index"><a href="#在URL中指定index" class="headerlink" title="在URL中指定index"></a>在URL中指定index</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_mget<br>&#123;<br>  &quot;docs&quot;: [<br>    &#123;<br>      &quot;_type&quot;: &quot;_doc&quot;,<br>      &quot;_id&quot;: <span class="hljs-number">1</span><br>    &#125;,<br>    &#123;<br>      &quot;_type&quot;: &quot;_doc&quot;,<br>      &quot;_id&quot;: <span class="hljs-number">2</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在URL中指定index和type"><a href="#在URL中指定index和type" class="headerlink" title="在URL中指定index和type"></a>在URL中指定index和type</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_mget<br>&#123;<br>  &quot;docs&quot;: [<br>    &#123;<br>      &quot;_id&quot;: <span class="hljs-number">1</span><br>    &#125;,<br>    &#123;<br>      &quot;_id&quot;: <span class="hljs-number">2</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="批量操作文档数据"><a href="#批量操作文档数据" class="headerlink" title="批量操作文档数据"></a>批量操作文档数据</h2><ul><li><p>批量对文档进行写操作是通过_bulk的API来实现的 </p></li><li><p>通过_bulk操作文档，一般至少有两行参数(或偶数行参数) </p><ul><li>第一行参数为指定操作的类型及操作的对象 (index,type和id) </li><li>第二行参数才是操作的数据</li></ul><p>参数类似于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-string">&quot;actionName&quot;</span>:&#123;<span class="hljs-string">&quot;_index&quot;</span>:<span class="hljs-string">&quot;indexName&quot;</span>, <span class="hljs-string">&quot;_type&quot;</span>:<span class="hljs-string">&quot;typeName&quot;</span>,<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;id&quot;</span>&#125;&#125;<br>&#123;<span class="hljs-string">&quot;field1&quot;</span>:<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;field2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="批量创建文档create"><a href="#批量创建文档create" class="headerlink" title="批量创建文档create"></a>批量创建文档create</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _bulk<br>&#123;<br>  &quot;create&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">3</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;id&quot;: <span class="hljs-number">3</span>,<br>  &quot;title&quot;: &quot;文章1&quot;,<br>  &quot;content&quot;: &quot;内容1&quot;,<br>  &quot;tags&quot;: [<br>    &quot;tag1&quot;,<br>    &quot;tag2&quot;<br>  ],<br>  &quot;create_time&quot;: <span class="hljs-number">1554015482530</span><br>&#125;<br>&#123;<br>  &quot;create&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">4</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;id&quot;: <span class="hljs-number">4</span>,<br>  &quot;title&quot;: &quot;文章2&quot;,<br>  &quot;content&quot;: &quot;内容2&quot;,<br>  &quot;tags&quot;: [<br>    &quot;tag3&quot;,<br>    &quot;tag4&quot;<br>  ],<br>  &quot;create_time&quot;: <span class="hljs-number">1554015482530</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="普通创建或全量替换index"><a href="#普通创建或全量替换index" class="headerlink" title="普通创建或全量替换index"></a>普通创建或全量替换index</h3><ul><li>如果原文档不存在，则是创建 </li><li>如果原文档存在，则是替换(全量修改原文档)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _bulk<br>&#123;<br>  &quot;index&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">3</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;id&quot;: <span class="hljs-number">3</span>,<br>  &quot;title&quot;: &quot;更新后的文章1&quot;,<br>  &quot;content&quot;: &quot;更新后的内容1&quot;,<br>  &quot;tags&quot;: [<br>    &quot;tag1&quot;,<br>    &quot;tag2&quot;<br>  ],<br>  &quot;create_time&quot;: <span class="hljs-number">1554015482530</span><br>&#125;<br>&#123;<br>  &quot;index&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">5</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;id&quot;: <span class="hljs-number">5</span>,<br>  &quot;title&quot;: &quot;文章5&quot;,<br>  &quot;content&quot;: &quot;内容5&quot;,<br>  &quot;tags&quot;: [<br>    &quot;tag5&quot;,<br>    &quot;tag14&quot;<br>  ],<br>  &quot;create_time&quot;: <span class="hljs-number">1554015482530</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="批量修改update"><a href="#批量修改update" class="headerlink" title="批量修改update"></a>批量修改update</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _bulk<br>&#123;<br>  &quot;update&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">3</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;doc&quot;: &#123;<br>    &quot;title&quot;: &quot;更新后的文章11&quot;,<br>    &quot;content&quot;: &quot;更新后的内容11&quot;<br>  &#125;<br>&#125;<br>&#123;<br>  &quot;update&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">5</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;doc&quot;: &#123;<br>    &quot;title&quot;: &quot;文章51&quot;,<br>    &quot;content&quot;: &quot;内容51&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="批量删除delete"><a href="#批量删除delete" class="headerlink" title="批量删除delete"></a>批量删除delete</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _bulk<br>&#123;<br>  &quot;delete&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">3</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;delete&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">4</span><br>  &#125;<br>&#125;s<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch数据管理</title>
    <link href="/ES%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    <url>/ES%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="ES数据管理"><a href="#ES数据管理" class="headerlink" title="ES数据管理"></a>ES数据管理</h1><h2 id="ES数据管理概述"><a href="#ES数据管理概述" class="headerlink" title="ES数据管理概述"></a>ES数据管理概述</h2><ul><li>ES是面向文档(document oriented)的，这意味着它可以存储整个对象或文档 (document)。</li><li>然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。</li><li>在ES中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。</li><li>ES使用JSON作为文档序列化格式。</li></ul><p><strong>ES存储的一个员工文档的格式示例：</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123; <br> &quot;email&quot;: &quot;584614151@qq.com&quot;,<br> &quot;name&quot;: &quot;张三&quot;, <br> &quot;age&quot;: <span class="hljs-number">30</span>,<br> &quot;interests&quot;: [ &quot;篮球&quot;, &quot;健身&quot; ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>JSON现在已经被大多语言所支持，而且已经成为NoSQL领域的标准格式。 </p></blockquote><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>格式: PUT &#x2F;索引名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">PUT <span class="hljs-operator">/</span>es_db<br></code></pre></td></tr></table></figure><h3 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h3><p>格式: GET &#x2F;索引名称 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<br></code></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>格式: DELETE &#x2F;索引名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-operator">/</span>es_db<br></code></pre></td></tr></table></figure><h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><ul><li>格式: POST &#x2F;索引名称&#x2F;类型&#x2F;id(可选，不传会创建默认的id)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<br>&#123;<br>  &quot;name&quot;: &quot;张三&quot;,<br>  &quot;sex&quot;: <span class="hljs-number">1</span>,<br>  &quot;age&quot;: <span class="hljs-number">25</span>,<br>  &quot;address&quot;: &quot;广州天河公园&quot;,<br>  &quot;remark&quot;: &quot;java developer&quot;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>格式: PUT &#x2F;索引名称&#x2F;类型&#x2F;id</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">PUT <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span><span class="hljs-number">1</span><br>&#123;<br>  &quot;name&quot;: &quot;张三&quot;,<br>  &quot;sex&quot;: <span class="hljs-number">1</span>,<br>  &quot;age&quot;: <span class="hljs-number">25</span>,<br>  &quot;address&quot;: &quot;广州天河公园&quot;,<br>  &quot;remark&quot;: &quot;java developer&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><ul><li>格式: PUT &#x2F;索引名称&#x2F;类型&#x2F;id</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">PUT <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span><span class="hljs-number">1</span><br>&#123;<br>  &quot;name&quot;: &quot;张三&quot;,<br>  &quot;sex&quot;: <span class="hljs-number">1</span>,<br>  &quot;age&quot;: <span class="hljs-number">25</span>,<br>  &quot;address&quot;: &quot;广州天河公园&quot;,<br>  &quot;remark&quot;: &quot;java developer&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><p>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;id </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>格式: DELETE &#x2F;索引名称&#x2F;类型&#x2F;id </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><h4 id="查询当前类型中的所有文档-search"><a href="#查询当前类型中的所有文档-search" class="headerlink" title="查询当前类型中的所有文档 _search"></a>查询当前类型中的所有文档 _search</h4><p> 格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search </p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search <br></code></pre></td></tr></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul><li><p>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?q&#x3D;<em>:</em>** </p></li><li><p>SQL: select * from student where age &#x3D; 28</p></li></ul><p>举例：如要查询age等于28岁的 _search?q&#x3D;<em>:</em>** </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?q<span class="hljs-operator">=</span>age:<span class="hljs-number">28</span> <br></code></pre></td></tr></table></figure><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><ul><li>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?q&#x3D;***[25 TO 26] </li><li>SQL: select * from student where age between 25 and 26</li></ul><p>举例：如要查询age在25至26岁之间的 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?q<span class="hljs-operator">=</span>age[<span class="hljs-number">25</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">26</span>] <br></code></pre></td></tr></table></figure><p><strong>注意: TO 必须为大写</strong> </p><h5 id="大于"><a href="#大于" class="headerlink" title="大于"></a>大于</h5><ul><li>格式:  GET &#x2F;索引名称&#x2F;类型&#x2F;_search?q&#x3D;age:&gt;** </li><li>SQL: select * from student where age &gt; 28</li></ul><p>举例：查询年龄大于28的 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?q<span class="hljs-operator">=</span>age:<span class="hljs-operator">&gt;</span><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h5 id="小于等于"><a href="#小于等于" class="headerlink" title="小于等于"></a>小于等于</h5><ul><li>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?q&#x3D;age:&lt;&#x3D;** </li><li>SQL: select * from student where age &lt;&#x3D; 28</li></ul><p>举例：查询年龄小于等于28岁的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?q<span class="hljs-operator">=</span>age:<span class="hljs-operator">&lt;=</span><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h4 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h4><ul><li>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_mget </li><li>SQL: select * from student where id in (1,2)</li></ul><p>举例：根据多个ID进行批量查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_mget<br>&#123;<br>  &quot;ids&quot;:[&quot;3&quot;,&quot;2&quot;]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul><li><p>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?q&#x3D;age[25 TO 26]&amp;from&#x3D;0&amp;size&#x3D;1 </p></li><li><p>SQL: select * from student where age between 25 and 26 limit 0, 1</p></li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?q<span class="hljs-operator">=</span>age[<span class="hljs-number">25</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">26</span>]<span class="hljs-operator">&amp;</span><span class="hljs-keyword">from</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-operator">&amp;</span>size<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="查询结果只输出某些字段"><a href="#查询结果只输出某些字段" class="headerlink" title="查询结果只输出某些字段"></a>查询结果只输出某些字段</h4><ul><li>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?_source&#x3D;字段,字段</li><li>SQL: select name,age from student</li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?_source<span class="hljs-operator">=</span>name,age<br></code></pre></td></tr></table></figure><h4 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h4><ul><li>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?sort&#x3D;字段 desc </li><li>SQL: select * from student order by age desc</li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?sort<span class="hljs-operator">=</span>age:<span class="hljs-keyword">desc</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch安装</title>
    <link href="/Elasticsearch%E5%AE%89%E8%A3%85/"/>
    <url>/Elasticsearch%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch安装"><a href="#Elasticsearch安装" class="headerlink" title="Elasticsearch安装"></a>Elasticsearch安装</h1><p>1.下载es.  Es 下载链接： <a href="https://www.elastic.co/cn/downloads/elasticsearch">Download Elasticsearch | Elastic</a></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230445183.png" alt="image-20230228230445183"></p><p>2.解压后在bin路径下，运行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  bin .<span class="hljs-operator">/</span>elasticsearch <span class="hljs-operator">-</span>d<br></code></pre></td></tr></table></figure><p>3.访问<a href="http://localhost:9200/">localhost:9200</a>,看到下面的页面即启动成功</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230454065.png" alt="image-20230228230454065"></p><h1 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h1><ol><li>Kibana 下载链接：<a href="https://www.elastic.co/cn/downloads/kibana">Download Kibana Free | Get Started Now | Elastic</a></li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230502701.png" alt="image-20230228230502701"></p><ol start="2"><li>修改 kibana.yml</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">server.port: <span class="hljs-number">5601</span><br>server.host: &quot;localhost&quot;<br>elasticsearch.hosts: [&quot;http://localhost:9200&quot;]<br></code></pre></td></tr></table></figure><p>3.访问<a href="http://localhost:5601/app/kibana">http://localhost:5601/app/kibana</a>, 看到下面的页面即启动成功</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230512243.png" alt="image-20230228230512243"></p><h1 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h1><p>我们后续也需要使用Elasticsearch来进行中文分词，所以需要单独给Elasticsearch安装IK分词器插件。以下为具体安装步骤：</p><ol><li><p>下载ElasticsearchIK分词器 <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p></li><li><p>在es的安装目录下&#x2F;plugins创建ik，将下载的ik分词器上传并解压到该目录</p></li><li><p>重启Elasticsearch</p></li></ol>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">查找进程命令 ps <span class="hljs-operator">-</span>ef <span class="hljs-operator">|</span> grep elastic<br>杀掉进程 kill <span class="hljs-number">-9</span> <span class="hljs-number">2382</span>（进程号）<br></code></pre></td></tr></table></figure><ol start="4"><li>测试分词效果，访问<a href="http://localhost:5601/app/dev_tools#/console">Dev Tools - Elastic</a></li></ol>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _analyze<br>&#123;<br>&quot;analyzer&quot;:&quot;standard&quot;,<br>&quot;text&quot;:&quot;我爱你中国&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>   <img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230530722.png" alt="image-20230228230530722"></p><ul><li>ik_smart:会做最粗粒度的拆分</li></ul>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _analyze<br>&#123;<br>&quot;analyzer&quot;:&quot;ik_smart&quot;,<br>&quot;text&quot;:&quot;我爱你中国&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>   <img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230546771.png" alt="image-20230228230546771"></p><ul><li>k_max_word:会将文本做最细粒度的拆分</li></ul>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _analyze<br>&#123;<br>&quot;analyzer&quot;:&quot;ik_max_word&quot;,<br>&quot;text&quot;:&quot;我爱你中国&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>   <img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230556755.png" alt="image-20230228230556755"></p><h1 id="指定IK分词器作为默认分词器"><a href="#指定IK分词器作为默认分词器" class="headerlink" title="指定IK分词器作为默认分词器"></a>指定IK分词器作为默认分词器</h1><p>​        ES的默认分词设置是standard，这个在中文分词时就比较尴尬了，会单字拆分，比如我搜索关键词“清华大学”，这时候会按“清”，“华”，“大”，“学”去分词，然后搜出来的都是些“清清的河水”，“中华儿女”，“地大物博”，“学而不思则罔”之类的莫名其妙的结果，</p><p>​        这里我们就想把这个分词方式修改一下，于是呢，就想到了ik分词器，有两种ik_smart和ik_max_word。ik_smart会将“清华大学”整个分为一个词，而ik_max_word会将“清华大学”分为“清华大学”，“清华”和“大学”，按需选其中之一就可以了。修改默认分词方法(这里修改school_index索引的默认分词为：ik_max_word)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">PUT <span class="hljs-operator">/</span>school_index<br>&#123;<br>  &quot;settings&quot;:&#123;<br>    &quot;index&quot;:&#123;<br>      &quot;analysis.analyzer.default.type&quot;:&quot;ik_max_word&quot;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230604782.png" alt="image-20230228230604782"></p>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch集群搭建</title>
    <link href="/ElasticSearch%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/ElasticSearch%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch集群搭建"><a href="#ElasticSearch集群搭建" class="headerlink" title="ElasticSearch集群搭建"></a>ElasticSearch集群搭建</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="集群cluster"><a href="#集群cluster" class="headerlink" title="集群cluster"></a>集群cluster</h3><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能</p><h3 id="节点node"><a href="#节点node" class="headerlink" title="节点node"></a>节点node</h3><ul><li>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据。参与集群的索引和搜索功能。</li><li>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中。这意味着，如果在网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</li><li>在一个集群里，可以拥有任意多个节点。而且，如果当前网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</li></ul><h3 id="分片和副本shards-amp-replicas"><a href="#分片和副本shards-amp-replicas" class="headerlink" title="分片和副本shards&amp;replicas"></a>分片和副本shards&amp;replicas</h3>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickHouse的SQL操作</title>
    <link href="/clickHouse%E7%9A%84SQL%E6%93%8D%E4%BD%9C-1/"/>
    <url>/clickHouse%E7%9A%84SQL%E6%93%8D%E4%BD%9C-1/</url>
    
    <content type="html"><![CDATA[<h1 id="ClickHouse的SQL操作"><a href="#ClickHouse的SQL操作" class="headerlink" title="ClickHouse的SQL操作"></a>ClickHouse的SQL操作</h1><p>基本上来说传统关系型数据库（以 MySQL 为例）的 SQL 语句，ClickHouse 基本都支持，这里不会从头讲解 SQL 语法只介绍 ClickHouse 与标准 SQL（MySQL）不一致的地方</p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>基本与标准 SQL（MySQL）基本一致</p><p>（1）标准</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> [table_name] <span class="hljs-keyword">values</span>(…),(….)<br></code></pre></td></tr></table></figure><p>（2）从表到表的插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> [table_name] <span class="hljs-keyword">select</span> a,b,c <span class="hljs-keyword">from</span> [table_name_2]<br></code></pre></td></tr></table></figure><h2 id="Update-和Delete"><a href="#Update-和Delete" class="headerlink" title="Update 和Delete"></a>Update 和Delete</h2><ul><li><p>ClickHouse 提供了 Delete 和 Update 的能力，这类操作被称为 Mutation 查询，它可以看做 Alter 的一种。</p></li><li><p>虽然可以实现修改和删除，但是和一般的 OLTP 数据库不一样，<strong>Mutation</strong> 语句是一种很重的操作，而且不支持事务。</p><blockquote><p>“重”的原因主要是每次修改或者删除都会导致放弃目标数据的原有分区，重建新分区。合并的时候才会删除原有分区，所以尽量做批量的变更，不要进行频繁小数据的操作。</p></blockquote></li></ul><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_order_smt <span class="hljs-keyword">delete</span> <span class="hljs-keyword">where</span> sku_id <span class="hljs-operator">=</span><span class="hljs-string">&#x27;sku_001&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_order_smt update total_amount<span class="hljs-operator">=</span>toDecimal32(<span class="hljs-number">2000.00</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">102</span>;<br></code></pre></td></tr></table></figure><h3 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h3><p>clickhouse虽然支持 Delete 和 Update 的能力，但是这类操作很重，一般建议不要使用，如果要使用，都可以采用增加数据的方式来实现，如更新的话，可以给列新加版本号；删除的话，可以增加一列删除标记为：delete_at，但这样会造成数据膨胀，可以定期删除失效的数据。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>ClickHouse 基本上与标准 SQL 差别不大</p><p>➢ 支持子查询</p><p>➢ 支持 CTE(Common Table Expression 公用表表达式 with 子句) </p><p>➢ 支持各种 JOIN，但是 JOIN 操作无法使用缓存，所以即使是两次相同的 JOIN 语句，ClickHouse 也会视为两条新 SQL</p><p>➢ 窗口函数</p><p>➢ 不支持自定义函数</p><p>➢ GROUP BY 操作增加了 with rollup\with cube\with total 用来计算小计和总计。</p><p><strong>演示</strong></p><p>（1）插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">bfdf602492c9 :)  <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_order_mt <span class="hljs-keyword">delete</span> <span class="hljs-keyword">where</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>bfdf602492c9 :) <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt <span class="hljs-keyword">values</span><br>                (<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">103</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">104</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">105</span>,<span class="hljs-string">&#x27;sku_003&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">106</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-04 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">107</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-04 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">108</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-04 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">109</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-04 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">110</span>,<span class="hljs-string">&#x27;sku_003&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（2）with rollup：从右至左去掉维度进行小计</p><p>可以看出分别根据  【id,sku_id】【id】【(空)】 进行了分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">bfdf602492c9 :) <span class="hljs-keyword">select</span> id , sku_id,<span class="hljs-built_in">sum</span>(total_amount) <span class="hljs-keyword">from</span> t_order_mt <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id,sku_id <span class="hljs-keyword">with</span> <span class="hljs-keyword">rollup</span>;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222258542.png" alt="image-20230228222258542"></p><p>（3）with cube : 从右至左去掉维度进行小计，再从左至右去掉维度进行小计</p><p>可以看出分别根据  【id,sku_id】【id】【sku_id】【(空)】 进行了分组</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222316833.png" alt="image-20230228222316833"></p><p>（4）with totals: 只计算合计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">bfdf602492c9 :)  <span class="hljs-keyword">select</span> id , sku_id,<span class="hljs-built_in">sum</span>(total_amount) <span class="hljs-keyword">from</span> t_order_mt <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>                id,sku_id <span class="hljs-keyword">with</span> totals;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222331141.png" alt="image-20230228222331141"></p><h2 id="alter操作"><a href="#alter操作" class="headerlink" title="alter操作"></a>alter操作</h2><p>同 MySQL 的修改字段基本一致</p><p>1）新增字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tableName <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> newcolname String after col1; <br></code></pre></td></tr></table></figure><p>2）修改字段类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tableName modify <span class="hljs-keyword">column</span> newcolname String; <br></code></pre></td></tr></table></figure><p>3）删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tableName <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> newcolname; <br></code></pre></td></tr></table></figure><blockquote><p>更多语法参考：<a href="https://clickhouse.com/docs/en/sql-reference/">ClickHouse Documentation</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse表引擎</title>
    <link href="/clickhouse%E8%A1%A8%E5%BC%95%E6%93%8E/"/>
    <url>/clickhouse%E8%A1%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="表引擎介绍"><a href="#表引擎介绍" class="headerlink" title="表引擎介绍"></a>表引擎介绍</h1><p>表引擎是 ClickHouse 的一大特色。不同的引擎有不同的作用，可以说， 表引擎决定了如何存储表的数据。包括：</p><p>➢ 数据的存储方式和位置，写到哪里以及从哪里读取数据。 （一般的引擎都存在磁盘中，但是存在与其他数据库继承的场景，比如和mysql集成，数据放在mysql服务端。）</p><p>➢ 支持哪些查询以及如何支持。（有些语法只有在特定的引擎才可以使用，比如不能在 MergeTree 表中存储多维数组）</p><p>➢ 并发数据访问。（可以多线程执行同一条sql）</p><p>➢ 索引的使用（如果存在）。</p><p>➢ 是否可以执行多线程请求。</p><p>➢ 数据复制参数。</p><blockquote><p>表引擎的使用方式就是必须显式在创建表时定义该表使用的引擎，以及引擎使用的相关参数。</p></blockquote><p><strong>特别注意：引擎的名称大小写敏感</strong></p><h1 id="合并树家族"><a href="#合并树家族" class="headerlink" title="合并树家族"></a>合并树家族</h1><h2 id="MergeTree"><a href="#MergeTree" class="headerlink" title="MergeTree"></a><strong>MergeTree</strong></h2><ul><li>ClickHouse 中最强大的表引擎当属 MergeTree（合并树）引擎及该系列（*MergeTree）</li></ul><p>中的其他引擎，支持索引和分区，地位可以相当于 innodb 之于 Mysql。而且基于 MergeTree，</p><ul><li>还衍生除了很多小弟，也是非常有特色的引擎。</li></ul><ol><li><p>建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_mt(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>),<br>create_time Datetime<br>) engine <span class="hljs-operator">=</span>MergeTree<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id,sku_id);<br></code></pre></td></tr></table></figure></li><li><p><strong>插入数据</strong></p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><h4 id="partition-by-分区"><a href="#partition-by-分区" class="headerlink" title="partition by 分区"></a><strong>partition by</strong> 分区</h4><h5 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h5><p>分区的目的主要是降低扫描的范围，优化查询速度</p><h5 id="2-可选"><a href="#2-可选" class="headerlink" title="2. 可选"></a>2. 可选</h5><p>可选的，如果不填，只会使用一个分区。</p><h5 id="3-分区目录"><a href="#3-分区目录" class="headerlink" title="3.分区目录"></a>3.<strong>分区目录</strong></h5><p>MergeTree 是以列文件+索引文件+表定义文件组成的，但是如果设定了分区那么这些文</p><p>件就会保存到不同的分区目录中。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225811773.png" alt="image-20230228225811773"></p><h5 id="4-并行"><a href="#4-并行" class="headerlink" title="4.并行"></a>4.<strong>并行</strong></h5><p>分区后，面对涉及跨分区的查询统计，ClickHouse 会以分区为单位并行处理。</p><h5 id="5-数据写入与分区合并"><a href="#5-数据写入与分区合并" class="headerlink" title="5.数据写入与分区合并"></a>5.<strong>数据写入与分区合并</strong></h5><ul><li><p>任何一个批次的数据写入都会产生一个临时分区，不会纳入任何一个已有的分区。</p></li><li><p>写入后的某个时刻（大概 10-15 分钟后），ClickHouse 会自动执行合并操作。</p></li><li><p>也可以手动通过 optimize 执行，把临时分区的数据，合并到已有分区中。语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">optimize <span class="hljs-keyword">table</span> xxxx <span class="hljs-keyword">final</span>;<br></code></pre></td></tr></table></figure><p>如：</p><ul><li>再次执行上面的插入操作</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>查看数据并没有纳入任何分区</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225822725.png" alt="image-20230228225822725"></p></li><li><p>手动 optimize 之后，再次查询</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225836780.png" alt="image-20230228225836780"></p></li></ul><h4 id="primary-key-主键"><a href="#primary-key-主键" class="headerlink" title="primary key 主键"></a><strong>primary key</strong> <strong>主键</strong></h4><ul><li>ClickHouse 中的主键，和其他数据库不太一样，<strong>它只提供了数据的一级索引，但是却不</strong></li></ul><p><strong>是唯一约束。</strong>这就意味着是可以存在相同 primary key 的数据的。</p><ul><li><p>主键的设定主要依据是查询语句中的 where 条件。</p></li><li><p>根据条件通过对主键进行某种形式的二分查找，能够定位到对应的 index granularity（粒度）,避免了全表扫描。</p><blockquote><p>index granularity： 直接翻译的话就是索引粒度，指在稀疏索引中两个相邻索引对应数据的间隔。ClickHouse 中的 MergeTree 默认是 8192。官方不建议修改这个值，除非该列存在大量重复值，比如在一个分区中几万行才有一个不同数据。</p></blockquote><p><strong>稀疏索引：</strong></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225859455.png" alt="image-20230228225859455"></p><p>稀疏索引的好处就是可以用很少的索引数据，定位更多的数据，代价就是只能定位到索引粒度的第一行，然后再进行进行一点扫描。</p><blockquote><p>比如要查找id为15151的数据，可以判断出他大于10101 小于32343 ，因此会在这个区域内进行查找，类似的根据二分查找定位到具体的值。</p></blockquote></li></ul><h4 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a><strong>order by</strong></h4><ul><li><p>order by 设定了分区内的数据按照哪些字段顺序进行有序保存。</p></li><li><p>order by 是 MergeTree 中唯一一个必填项，甚至比 primary key 还重要，因为当用户不</p><p>设置主键的情况，很多处理会依照 order by 的字段进行处理（比如后面会讲的去重和汇总）。</p></li><li><p><strong>要求：主键必须是 order by 字段的前缀字段</strong>。比如 order by 字段是 (id,sku_id) 那么主键必须是 id 或者(id,sku_id)</p></li></ul><h3 id="跳数索引"><a href="#跳数索引" class="headerlink" title="跳数索引"></a>跳数索引</h3><ul><li><p>MergeTree支持二级索引，又称之为跳数索引，是由数据的聚合信息构建而成。跳数索引的目录也是帮助查询，减少数据扫描的范围。</p></li><li><p>此索引在 <code>CREATE</code> 语句的列部分里定义。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">INDEX index_name expr TYPE type(...) GRANULARITY granularity_value<br></code></pre></td></tr></table></figure><ul><li><p><code>*MergeTree</code> 系列的表可以指定跳数索引。</p></li><li><p>跳数索引是指数据片段按照粒度(建表时指定的<code>index_granularity</code>)分割成小块后，将上述SQL的granularity_value数量的小块组合成一个大的块，对这些大块写入索引信息。</p></li><li><p>这样有助于使用<code>where</code>筛选时跳过大量不必要的数据，减少<code>SELECT</code>需要读取的数据量。</p></li><li><p>如：创建测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_mt2(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>),<br>create_time Datetime,<br>INDEX a total_amount TYPE minmax GRANULARITY <span class="hljs-number">5</span><br>) engine <span class="hljs-operator">=</span>MergeTree<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id, sku_id);<br></code></pre></td></tr></table></figure><blockquote><p>其中 GRANULARITY N 是设定二级索引对于一级索引粒度的粒度。</p><p>即一级索引为[1,3],[3,6],[6,9] ，对应的二级索引范围为[1,9]，将3个一级索引进行了合并，这样查找时就不需要根据一级索引去进行比较，直接根据二级索引就可以。</p></blockquote></li></ul></li></ul><blockquote><p> 目前在 ClickHouse 的官网上二级索引的功能在 v20.1.2.4 之前是被标注为实验性的，在这个版本之后默认是开启的。 </p></blockquote><h3 id="数据-TTL"><a href="#数据-TTL" class="headerlink" title="数据 TTL"></a><strong>数据</strong> <strong>TTL</strong></h3><ul><li><p>TTL 即 Time To Live，TTL用于设置值的生命周期，它既可以为整张表设置，也可以为每个列字段单独设置。表级别的 TTL 还会指定数据在磁盘和卷上自动转移的逻辑（也就是数据过期后可以移动到指定磁盘上）。</p></li><li><p>TTL 表达式的计算结果必须是 <a href="https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/mergetree/">日期</a> 或 <a href="https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/mergetree/">日期时间</a> 类型的字段。</p></li><li><p><code>TTL</code>子句不能被用于主键字段。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">TTL time_column<br>TTL time_column <span class="hljs-operator">+</span> <span class="hljs-type">interval</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1-列级别-TTL"><a href="#1-列级别-TTL" class="headerlink" title="1.列级别 TTL"></a>1.<strong>列级别</strong> <strong>TTL</strong></h4><p>当列中的值过期时, ClickHouse会将它们替换成该列数据类型的默认值。如果数据片段中列的所有值均已过期，则ClickHouse 会从文件系统中的数据片段中删除此列。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>创建表时指定 <code>TTL</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> example_table<br>(<br>    d DateTime,<br>    a <span class="hljs-type">Int</span> TTL d <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">MONTH</span>,<br>    b <span class="hljs-type">Int</span> TTL d <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">MONTH</span>,<br>    c String<br>)<br>ENGINE <span class="hljs-operator">=</span> MergeTree<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(d)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> d;<br></code></pre></td></tr></table></figure><p>为表中已存在的列字段添加 <code>TTL</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> example_table<br>    MODIFY <span class="hljs-keyword">COLUMN</span><br>    c String TTL d <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DAY</span>;<br></code></pre></td></tr></table></figure><p><strong>案例演示</strong></p><ul><li><p>创建测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_mt7(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>) TTL create_time<span class="hljs-operator">+</span><span class="hljs-type">interval</span> <span class="hljs-number">10</span> <span class="hljs-keyword">SECOND</span>,<br>create_time Datetime <br>) engine <span class="hljs-operator">=</span>MergeTree<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id, sku_id);<br></code></pre></td></tr></table></figure></li><li><p>插入数据（注意：根据实际时间改变）</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt7 <span class="hljs-keyword">values</span><br>(<span class="hljs-number">106</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2022-02-03 10:44:32&#x27;</span>),<br>(<span class="hljs-number">107</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2022-02-03 10:44:32&#x27;</span>),<br>(<span class="hljs-number">110</span>,<span class="hljs-string">&#x27;sku_003&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2022-02-04 19:20:30&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225917132.png" alt="image-20230228225917132"></p><ul><li><p>手动合并，查看效果 到期后，指定的字段数据归 0</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">optimize <span class="hljs-keyword">table</span> t_order_mt7 <span class="hljs-keyword">final</span>;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225930135.png" alt="image-20230228225930135"></p><h4 id="2-表-TTL"><a href="#2-表-TTL" class="headerlink" title="2.表 TTL"></a>2.表 TTL</h4><ul><li><p>表可以设置一个用于移除过期行的表达式，以及多个用于在磁盘或卷上自动转移数据片段的表达式。当表中的行过期时，ClickHouse 会删除所有对应的行。对于数据片段的转移特性，必须所有的行都满足转移条件。</p></li><li><p>下面的这条语句是数据会在 create_time 之后 10 秒丢失</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_order_mt3 MODIFY TTL create_time <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">10</span> <span class="hljs-keyword">SECOND</span>;<br></code></pre></td></tr></table></figure></li></ul><h5 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h5><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225939573.png" alt="image-20230228225939573"></p><h2 id="ReplacingMergeTree"><a href="#ReplacingMergeTree" class="headerlink" title="ReplacingMergeTree"></a>ReplacingMergeTree</h2><ul><li><p>ReplacingMergeTree 是 MergeTree 的一个变种，它存储特性完全继承 MergeTree，只是多了一个去重的功能。 </p></li><li><p>尽管 MergeTree 可以设置主键，但是 primary key 其实没有唯一约束的功能。如果你想处理掉重复的数据，可以借助这个 ReplacingMergeTree。</p></li></ul><h3 id="去重时机"><a href="#去重时机" class="headerlink" title="去重时机"></a><strong>去重时机</strong></h3><p>数据的去重只会在同一批插入（新版本）或合并的过程中出现。合并会在未知的时间在后台进行，所以你无法预</p><p>先作出计划。有一些数据可能仍未被处理。</p><h3 id="去重范围"><a href="#去重范围" class="headerlink" title="去重范围"></a><strong>去重范围</strong></h3><ul><li><p>如果表经过了分区，去重只会在分区内部进行去重，不能执行跨分区的去重。</p></li><li><p>所以 ReplacingMergeTree 能力有限， ReplacingMergeTree 适用于在后台清除重复的数据以节省空间，但是它不保证没有重复的数据出现。</p></li></ul><h3 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a><strong>案例演示</strong></h3><p>（1）创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_rmt(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>) ,<br>create_time Datetime <br>) engine <span class="hljs-operator">=</span>ReplacingMergeTree(create_time)<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id, sku_id);<br></code></pre></td></tr></table></figure><ul><li><p>ReplacingMergeTree() 填入的参数为版本字段，重复数据保留版本字段值最大的。</p></li><li><p>如果不填版本字段，默认按照插入顺序保留最后一条。</p></li></ul><p>（2）向表中插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_rmt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">12000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（3）执行第一次查询</p><p>可以看到插入的数据是根据id和sku_id 去重过的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_order_rmt;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225956910.png"></p><p>（4）再次插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_rmt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">12000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>(5) 再次查询，可以看到这次依旧只插入了4条数据，但是和第一次插入的数据没有进行去重，依旧存在重复数据。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230010636.png" alt="image-20230228230010636"></p><p>（6）手动合并</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">OPTIMIZE <span class="hljs-keyword">TABLE</span> t_order_rmt <span class="hljs-keyword">FINAL</span>;<br></code></pre></td></tr></table></figure><p>  (7) 再执行一次查询，此时数据已经根据分区进行了最终去重。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230022485.png" alt="image-20230228230022485"></p><h3 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h3><p>➢ 实际上是使用 order by 字段作为唯一键</p><p>➢ 去重不能跨分区</p><p>➢ 只有同一批插入（新版本）或合并分区时才会进行去重</p><p>➢ 认定重复的数据保留，版本字段值最大的</p><p>➢ 如果版本字段相同则按插入顺序保留最后一笔</p><h2 id="SummingMergeTree"><a href="#SummingMergeTree" class="headerlink" title="SummingMergeTree"></a><strong>SummingMergeTree</strong></h2><ul><li><p>对于不查询明细，只关心以维度进行汇总聚合结果的场景。如果只使用普通的MergeTree的话，无论是存储空间的开销，还是查询时临时聚合的开销都比较大。</p></li><li><p>ClickHouse 为了这种场景，提供了一种能够“预聚合”的引擎 SummingMergeTree</p></li><li><p>不支持幂等性，当写入100条，写了50条后挂了，后面再次同步100条数据时，会把前50条的数据聚合两次。</p></li></ul><h3 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a><strong>案例演示</strong></h3><p>（1）创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_smt(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>) ,<br>create_time Datetime <br>) engine <span class="hljs-operator">=</span>SummingMergeTree(total_amount)<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id,sku_id );<br></code></pre></td></tr></table></figure><p>（2）插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_smt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">12000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（3）执行第一次查询，可以看到已经做了一次聚合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_order_smt;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230039985.png" alt="image-20230228230039985"></p><p>（4）再次插入一条重复数据，并查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_smt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230047812.png" alt="image-20230228230047812"></p><p>（5）手动合并,并再次执行查询，可以看到数据已经全部聚合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">OPTIMIZE <span class="hljs-keyword">TABLE</span> t_order_smt <span class="hljs-keyword">FINAL</span>;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230057295.png" alt="image-20230228230057295"></p><h3 id="案例结论-1"><a href="#案例结论-1" class="headerlink" title="案例结论"></a>案例结论</h3><p>➢ 以 SummingMergeTree（）中指定的列作为汇总数据列 </p><p>➢ 以 order by 的列为准，作为维度列</p><p>➢ 可以填写多列必须数字列，如果不填，以所有非维度列且为数字列的字段为汇总数据列</p><p>➢ 其他的列按插入顺序保留第一行</p><p>➢ 不在一个分区的数据不会被聚合</p><p>➢ 只有在同一批次插入(新版本)或分片合并时才会进行聚合</p><h3 id="能不能直接执行查询-SQL-得到汇总值？"><a href="#能不能直接执行查询-SQL-得到汇总值？" class="headerlink" title="能不能直接执行查询 SQL 得到汇总值？"></a>能不能直接执行查询 SQL 得到汇总值？</h3><p>不行，可能会包含一些还没来得及聚合的临时明细如果要是获取汇总值，还是需要使用 sum 进行聚合，这样效率会有一定的提高，但本身 ClickHouse 是列式存储的，效率提升有限，不会特别明显。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> total_amount <span class="hljs-keyword">from</span> XXX <span class="hljs-keyword">where</span> province_name<span class="hljs-operator">=</span>’’ <span class="hljs-keyword">and</span> create_date<span class="hljs-operator">=</span>’xxx’<br></code></pre></td></tr></table></figure><p>改写为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(total_amount) <span class="hljs-keyword">from</span> province_name<span class="hljs-operator">=</span>’’ <span class="hljs-keyword">and</span> create_date<span class="hljs-operator">=</span>‘xxx’<br></code></pre></td></tr></table></figure><h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL 引擎可以对存储在远程 MySQL 服务器上的数据执行 <code>SELECT</code> 查询和<code>insert</code>插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] [db.]table_name [<span class="hljs-keyword">ON</span> CLUSTER cluster]<br>(<br>    name1 [type1] [<span class="hljs-keyword">DEFAULT</span><span class="hljs-operator">|</span>MATERIALIZED<span class="hljs-operator">|</span>ALIAS expr1] [TTL expr1],<br>    name2 [type2] [<span class="hljs-keyword">DEFAULT</span><span class="hljs-operator">|</span>MATERIALIZED<span class="hljs-operator">|</span>ALIAS expr2] [TTL expr2],<br>    ...<br>) ENGINE <span class="hljs-operator">=</span> MySQL(<span class="hljs-string">&#x27;host:port&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;table&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>[, replace_query, <span class="hljs-string">&#x27;on_duplicate_clause&#x27;</span>])<br>SETTINGS<br>    [connection_pool_size<span class="hljs-operator">=</span><span class="hljs-number">16</span>, ]<br>    [connection_max_tries<span class="hljs-operator">=</span><span class="hljs-number">3</span>, ]<br>    [connection_wait_timeout<span class="hljs-operator">=</span><span class="hljs-number">5</span>, ] <span class="hljs-comment">/* 0 -- do not wait */</span><br>    [connection_auto_close<span class="hljs-operator">=</span><span class="hljs-literal">true</span> ]<br>;<br></code></pre></td></tr></table></figure><p>更多见：<a href="https://clickhouse.com/docs/en/engines/table-engines/integrations/mysql/">MySQL | ClickHouse Documentation</a></p><h1 id="日志系列"><a href="#日志系列" class="headerlink" title="日志系列"></a>日志系列</h1><ul><li>这些引擎是为了需要写入许多小数据量（少于一百万行）的表的场景而开发的。</li><li>这系列的引擎有：<ul><li><a href="https://clickhouse.com/docs/zh/engines/table-engines/log-family/stripelog/">StripeLog</a></li><li><a href="https://clickhouse.com/docs/zh/engines/table-engines/log-family/log/">日志</a></li><li><a href="https://clickhouse.com/docs/zh/engines/table-engines/log-family/tinylog/">TinyLog</a></li></ul></li></ul><h2 id="TinyLog"><a href="#TinyLog" class="headerlink" title="TinyLog"></a>TinyLog</h2><p>以列文件的形式保存在磁盘上，不支持索引，没有并发控制。一般保存少量数据的小表，</p><p>生产环境上作用有限。可以用于平时练习测试用。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>Clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse基本数据类型</title>
    <link href="/clickhouse%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/clickhouse%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="clickhouse基本数据类型"><a href="#clickhouse基本数据类型" class="headerlink" title="clickhouse基本数据类型"></a>clickhouse基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a><strong>整型</strong></h2><p>固定长度的整型，包括有符号整型或无符号整型。</p><p>整型范围（-2n-1~2n-1-1）：</p><p>Int8 - [-128 : 127]</p><p>Int16 - [-32768 : 32767]</p><p>Int32 - [-2147483648 : 2147483647]</p><p>Int64 - [-9223372036854775808 : 9223372036854775807]</p><p>无符号整型范围（0~2n-1）：</p><p>UInt8 - [0 : 255]</p><p>UInt16 - [0 : 65535]</p><p>UInt32 - [0 : 4294967295]</p><p>UInt64 - [0 : 18446744073709551615]</p><blockquote><p>使用场景： 个数、数量、也可以存储型id</p></blockquote><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a><strong>浮点型</strong></h2><p>Float32 - float</p><p>Float64 – double</p><p>建议尽可能以整数形式存储数据。例如，将固定精度的数字转换为整数值，如时间用毫秒为单位表示，因为浮点型进行计算时可能引起四舍五入的误差。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">select</span> <span class="hljs-number">1.0</span><span class="hljs-number">-0.9</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1.</span> <span class="hljs-operator">-</span> <span class="hljs-number">0.9</span><br><br>Query id: <span class="hljs-number">82</span>a9fb29<span class="hljs-number">-9</span>ac3<span class="hljs-number">-41</span>a1<span class="hljs-number">-918</span>d<span class="hljs-operator">-</span>a37ec7bff333<br><br>┌──────minus(<span class="hljs-number">1.</span>, <span class="hljs-number">0.9</span>)─┐<br>│ <span class="hljs-number">0.09999999999999998</span> │<br>└─────────────────────┘<br><br><span class="hljs-number">1</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> set. Elapsed: <span class="hljs-number">0.010</span> sec.<br></code></pre></td></tr></table></figure><blockquote><p>使用场景：一般数据值比较小，不涉及大量的统计计算，精度要求不高的时候。比如保存商品的重量。</p></blockquote><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>没有单独的类型来存储布尔值。可以使用 UInt8 类型，取值限制为 0 或 1。</p><h2 id="Decimal-型"><a href="#Decimal-型" class="headerlink" title="Decimal 型"></a><strong>Decimal</strong> <strong>型</strong></h2><p>有符号的浮点数，可在加、减和乘法运算过程中保持精度。对于除法，最低有效数字会</p><p>被丢弃（不舍入）。</p><p>有三种声明：</p><p>➢ Decimal32(s)，相当于 Decimal(9-s,s)，有效位数为 1~9</p><p>➢ Decimal64(s)，相当于 Decimal(18-s,s)，有效位数为 1~18</p><p>➢ Decimal128(s)，相当于 Decimal(38-s,s)，有效位数为 1~38</p><p><strong>s 标识小数位</strong></p><blockquote><p>使用场景： 一般金额字段、汇率、利率等字段为了保证小数点精度，都使用 Decimal</p><p>进行存储。</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h2><ul><li>String</li></ul><p>字符串可以任意长度的。它可以包含任意的字节集，包含空字节。</p><ul><li>FixedString(N)</li></ul><p>固定长度 N 的字符串，N 必须是严格的正自然数。当服务端读取长度小于 N 的字符</p><p>串时候，通过在字符串末尾添加空字节来达到 N 字节长度。 当服务端读取长度大于 N 的</p><p>字符串时候，将返回错误消息。</p><p>与 String 相比，极少会使用 FixedString，因为使用起来不是很方便。</p><blockquote><p>使用场景：名称、文字描述、字符型编码。 固定长度的可以保存一些定长的内容，比</p><p>如一些编码，性别等但是考虑到一定的变化风险，带来收益不够明显，所以定长字符串使用意义有限。</p></blockquote><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a><strong>枚举类型</strong></h2><p>包括 Enum8 和 Enum16 类型。Enum 保存 ‘string’&#x3D; integer 的对应关系。</p><ul><li><p>Enum8 用 ‘String’&#x3D; Int8 对描述。</p></li><li><p>Enum16 用 ‘String’&#x3D; Int16 对描述。</p></li></ul><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><ul><li><p>创建一个带有一个枚举 Enum8(‘hello’ &#x3D; 1, ‘world’ &#x3D; 2) 类型的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_enum<br>                (<br>                x Enum8(<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>)<br>                )<br>                ENGINE <span class="hljs-operator">=</span> TinyLog;<br></code></pre></td></tr></table></figure></li><li><p><strong>这个</strong> <strong>x</strong> 列只能存储类型定义中列出的值：hello或world</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_enum <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;hello&#x27;</span>), (<span class="hljs-string">&#x27;world&#x27;</span>), (<span class="hljs-string">&#x27;hello&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225239055.png" alt="image-20230228225239055"></p><ul><li><strong>如果需要看到对应行的数值，则必须将</strong> <strong>Enum</strong> <strong>值转换为整数类型</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :)  <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CAST</span>(x, <span class="hljs-string">&#x27;Int8&#x27;</span>) <span class="hljs-keyword">FROM</span> t_enum;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225247973.png" alt="image-20230228225247973"></p><blockquote><p>使用场景：对一些状态、类型的字段算是一种空间优化，也算是一种数据约束。但是实</p><p>际使用中往往因为一些数据内容的变化增加一定的维护成本，甚至是数据丢失问题。所以谨慎使用。</p></blockquote><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a><strong>时间类型</strong></h2><p>目前 ClickHouse 有三种时间类型</p><p>➢ Date 接受<code>年-月-日</code>的字符串比如 ‘2019-12-16’ </p><p>➢ Datetime 接受<code>年-月-日 时:分:秒</code>的字符串比如 ‘2019-12-16 20:50:10’ </p><p>➢ Datetime64 接受<code>年-月-日 时:分:秒.亚秒</code>的字符串比如‘2019-12-16 20:50:10.66’</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p>Array(T)：由 T 类型元素组成的数组。</p><p>T 可以是任意类型，包含数组类型。 但不推荐使用多维数组，ClickHouse 对多维数组</p><p>的支持有限。例如，不能在 MergeTree 表中存储多维数组。</p><ul><li>创建数组方式 1，使用 array 函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> x, toTypeName(x) ;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225259859.png" alt="image-20230228225259859"></p><ul><li>创建数组方式 2：使用方括号</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-keyword">AS</span> x, toTypeName(x);<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225307055.png" alt="image-20230228225307055"></p><p>还有很多数据结构，可以参考官方文档：<a href="https://clickhouse.com/docs/zh/sql-reference/data-types/">简介 | ClickHouse文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker安装clickhouse</title>
    <link href="/docker-%E5%AE%89%E8%A3%85clickhouse/"/>
    <url>/docker-%E5%AE%89%E8%A3%85clickhouse/</url>
    
    <content type="html"><![CDATA[<p>1.启动容器服务，加载镜像</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> docker run <span class="hljs-operator">-</span>d <span class="hljs-comment">--name ch-server --ulimit nofile=262144:262144 -p 8123:8123 -p 9000:9000 -p 9009:9009 yandex/clickhouse-server</span><br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225548754.png" alt="image-20230228225548754"></p><p>2.查看服务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> docker ps<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225555839.png" alt="image-20230228225555839"></p><p>3.进入docker容器内，使用用户名和密码连接数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> docker <span class="hljs-keyword">exec</span> <span class="hljs-operator">-</span>it <span class="hljs-number">46</span>bb792f7762 <span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>bash<br>root<span class="hljs-variable">@46bb792f7762</span>:<span class="hljs-operator">/</span># clickhouse<span class="hljs-operator">-</span>client<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225603858.png" alt="image-20230228225603858"></p><blockquote><p>如果有密码，输入下面命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span>root<span class="hljs-variable">@46bb792f7762</span>:<span class="hljs-operator">/</span># clickhouse<span class="hljs-operator">-</span>client <span class="hljs-operator">-</span>u <span class="hljs-keyword">default</span> <span class="hljs-comment">--password test</span><br></code></pre></td></tr></table></figure></blockquote><p>4.查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225615339.png" alt="image-20230228225615339"></p><p>5.dbeaver 查看</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225624031.png" alt="image-20230228225624031"></p>]]></content>
    
    
    <categories>
      
      <category>Clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse入门</title>
    <link href="/clickhouse%E5%85%A5%E9%97%A8/"/>
    <url>/clickhouse%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ClickHouse-是什么？"><a href="#ClickHouse-是什么？" class="headerlink" title="ClickHouse 是什么？"></a><strong>ClickHouse</strong> 是什么？</h1><p>ClickHouse 是俄罗斯的 Yandex 于 2016 年开源的列式存储数据库（DBMS），使用 C++</p><p>语言编写，主要用于在线分析处理查询（OLAP），能够使用 SQL 查询实时生成分析数据报</p><p>告。</p><blockquote><ul><li>OLTP:   联机事务处理（Online Transaction Processing)。是mysql，oracle这种传统的关系型数据库的主要应用，适合做基本的日常的事务处理，增删改查等操作。</li><li>OLAP：联机分析处理（Online Analytical Processing)，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。适合做一次插入多次查询，适合分析，聚合的场景，但是对更新，删除不擅长。</li></ul></blockquote><h1 id="ClickHouse-的特点"><a href="#ClickHouse-的特点" class="headerlink" title="ClickHouse 的特点"></a>ClickHouse <strong>的特点</strong></h1><h2 id="1-列式存储"><a href="#1-列式存储" class="headerlink" title="1.列式存储"></a>1.<strong>列式存储</strong></h2><h3 id="行式存储和列式存储的对比"><a href="#行式存储和列式存储的对比" class="headerlink" title="行式存储和列式存储的对比"></a>行式存储和列式存储的对比</h3><ul><li><p>行式存储的好处是想查某个人所有的属性时，可以通过一次磁盘查找加顺序读取就可以。但是当想查所有人的年龄时，需要不停的查找，或者全表扫描才行，遍历的很多数据都是不需要的。</p></li><li><p>列式存储，想查所有人的年龄只需把年龄那一列拿出来就可以了</p></li></ul><p>以下面的表为例：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230156414.png" alt="image-20230228230156414"></p><ul><li><p>采用行式存储时，数据在磁盘上的组织结构为：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230204375.png"></p></li><li><p>采用列式存储时，数据在磁盘上的组织结构为：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230212410.png"></p></li></ul><h3 id="列式储存的好处："><a href="#列式储存的好处：" class="headerlink" title="列式储存的好处："></a><strong>列式储存的好处：</strong></h3><ul><li><p>对于列的聚合，计数，求和等统计操作原因优于行式存储。</p></li><li><p>由于某一列的数据类型都是相同的，针对于数据存储更容易进行数据压缩，每一列</p><p>选择更优的数据压缩算法，大大提高了数据的压缩比重。</p></li><li><p>由于数据压缩比更好，一方面节省了磁盘空间，另一方面对于 cache 也有了更大的</p></li></ul><p>发挥空间</p><h2 id="DBMS-的功能"><a href="#DBMS-的功能" class="headerlink" title="DBMS 的功能"></a><strong>DBMS</strong> <strong>的功能</strong></h2><p>几乎覆盖了标准 SQL 的大部分语法，包括 DDL 和 DML，以及配套的各种函数，用户管</p><p>理及权限管理，数据的备份与恢复。 </p><blockquote><p>数据库管理系统（英语：database management system，缩写：DBMS）即数据库管理软件，是一种针对对象数据库，为管理数据库而设计的大型计算机软件管理系统。</p><p>具有代表性的数据管理系统有：Oracle、Microsoft SQL Server、Access、MySQL及PostgreSQL等。通常数据库管理师会使用数据库管理系统来创建数据库系统。</p></blockquote><h2 id="多样化引擎"><a href="#多样化引擎" class="headerlink" title="多样化引擎"></a><strong>多样化引擎</strong></h2><p>ClickHouse 和 MySQL 类似，把表级的存储引擎插件化，根据表的不同需求可以设定不同</p><p>的存储引擎。目前包括合并树、日志、接口和其他四大类 20 多种引擎。</p><h2 id="高吞吐写入能力"><a href="#高吞吐写入能力" class="headerlink" title="高吞吐写入能力"></a>高吞吐写入能力</h2><ul><li><p>ClickHouse 采用类 LSM Tree的结构，数据写入后定期在后台 Compaction。通过类 LSM tree的结构，ClickHouse 在数据导入时全部是顺序 append 写，写入后数据段不可更改，在后台compaction 时也是多个段 merge sort 后顺序写回磁盘。顺序写的特性，充分利用了磁盘的吞吐能力，即便在 HDD 上也有着优异的写入性能。</p></li><li><p>官方公开 benchmark 测试显示能够达到 50MB-200MB&#x2F;s 的写入吞吐能力，按照每行</p></li></ul><p>100Byte 估算，大约相当于 50W-200W 条&#x2F;s 的写入速度。</p><p><a href="https://zhuanlan.zhihu.com/p/415799237">深入浅出分析LSM树（日志结构合并树） - 知乎 (zhihu.com)</a></p><blockquote><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230231533.png"></p></blockquote><h3 id="数据分区与线程级并行"><a href="#数据分区与线程级并行" class="headerlink" title="数据分区与线程级并行"></a><strong>数据分区与线程级并行</strong></h3><ul><li>ClickHouse 将数据划分为多个 partition，每个 partition 再进一步划分为多个 index</li></ul><p>granularity(索引粒度)，然后通过多个 CPU核心分别处理其中的一部分来实现并行数据处理。</p><p>在这种设计下，<strong>单条 Query 就能利用整机所有 CPU</strong>。极致的并行处理能力，极大的降低了查</p><p>询延时。</p><ul><li>所以，ClickHouse 即使对于大量数据的查询也能够化整为零平行处理。但是有一个弊端</li></ul><p>就是对于单条查询使用多 cpu，就不利于同时并发多条查询。所以对于高 qps 的查询业务，</p><p>ClickHouse 并不是强项。</p><blockquote><p>QPS（<strong>Query Per Second</strong>）：每秒请求数，就是说服务器在一秒的时间内处理了多少个请求。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/zookeeper%E5%85%A5%E9%97%A8/"/>
    <url>/zookeeper%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<hr><p>title: zookeeper特性与节点介绍<br>date: 2021-09-22 22:43:51<br>tags:  分布式框架</p><p>categories:  zookeeper</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="1-产生背景"><a href="#1-产生背景" class="headerlink" title="1 产生背景"></a>1 产生背景</h2><ol><li><p>单体向分布式服务转变，会产生多个节点间协同问题，如：</p><blockquote><ul><li><p>假设有3个节点，1个job，该job该由哪个节点执行？</p></li><li><p>若该job由节点1执行，要是1挂了，现在该2还是3执行？</p></li></ul></blockquote></li><li><p>上游和下游服务的发现，如：</p><blockquote><ul><li>上游挂了，下游怎么知道？</li><li>下游服务新增，上游怎么知道？</li></ul></blockquote></li><li><p>多节点的协调问题，如：并发产生了请求，该怎么保证请求的幂等性？</p></li></ol><blockquote><p><strong>由于节点自身协调不可靠，性能不高，故需要一个独立服务来做协调，他必须可靠且保证性能。</strong></p></blockquote><h2 id="2-概要"><a href="#2-概要" class="headerlink" title="2 概要"></a>2 概要</h2><ol><li>zookeeper是用于分布式服务的协调服务。</li><li>它对外公布了一组简单的API，分布式应用程序可以基于这些API，用于同步节点状态，节点配置，服务注册等信息</li><li>它支持java和c两种语言。</li></ol><h2 id="3-工作机制"><a href="#3-工作机制" class="headerlink" title="3 工作机制"></a>3 工作机制</h2><p>从设计模式的角度理解，zookeeper基于观察者模式。他负责存储和管路大家都关心的数据，然后接受观察，一旦数据状态发生变化，zookeeper就通知注册者。</p><h2 id="4-特点"><a href="#4-特点" class="headerlink" title="4 特点"></a>4 特点</h2><ol><li>zookeeper是由一个leader和多个follower组成的集群</li><li>半数以上节点存活，zookeeper 即可以正常服务</li><li>每个server的数据一致</li><li>来自同一个client的请求依次执行</li><li>原子性，数据更新要么成功，要么失败</li><li>zookeeper数据量少，故同步快，一定时间内，client可以读到最新数据</li></ol><h2 id="5-zookeeper-启动"><a href="#5-zookeeper-启动" class="headerlink" title="5 zookeeper 启动"></a>5 zookeeper 启动</h2><ul><li>官网下载最新版本 <a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz">Apache Downloads</a>，并解压</li><li>进入conf目录，拷贝默认配置  <code>cp zoo_sample.cfg   zoo.cfg</code></li><li>进入bin目录，启动服务端<code>./zkServer.sh start</code></li><li>进入bin目录，进入客户端<code>./zkCli.sh</code></li></ul><h2 id="6-常规配置文件说明"><a href="#6-常规配置文件说明" class="headerlink" title="6 常规配置文件说明"></a>6 常规配置文件说明</h2><blockquote><p>tickTime&#x3D;2000   #zookeeper时间配置中的基本单位 (毫秒) </p></blockquote><blockquote><p>initLimit&#x3D;10     #允许follower初始化连接到leader最大时长，它表示tickTime时间倍数 即:initLimit*tickTime</p></blockquote><blockquote><p>syncLimit&#x3D;5 #允许follower与leader数据同步最大时长,它表示tickTime时间倍数</p></blockquote><blockquote><p>dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper  #zookeper 数据存储目录</p></blockquote><blockquote><p>clientPort&#x3D;2181  #对客户端提供的端口号</p></blockquote><blockquote><p>maxClientCnxns&#x3D;60  #单个客户端与zookeeper最大并发连接数</p></blockquote><blockquote><p>autopurge.snapRetainCount&#x3D;3. #保存的数据快照数量，之外的将会被清除</p></blockquote><blockquote><p>autopurge.purgeInterval&#x3D;1  #自动触发清除任务时间间隔，小时为单位。默认为0，表示不自动清除。</p></blockquote><h2 id="7-客户端命令"><a href="#7-客户端命令" class="headerlink" title="7 客户端命令"></a>7 客户端命令</h2><ul><li><p>close     关闭当前会话</p></li><li><p>connect host:port        重新连接指定Zookeeper服务</p></li><li><p>create [-s] [-e] [-c] [-t ttl] path [data] [acl]          创建节点</p></li><li><p>delete [-v version] path             删除节点，(不能存在子节点） </p></li><li><p>deleteall path [-b batch size]      删除路径及所有子节点</p></li><li><p>get [-s] [-w] path.        查看节点数据 -s 包含节点状态 -w 添加监听 </p></li><li><p>getAcl [-s] path.      列出子节点 -s状态 -R 递归查看所有子节点 -w 添加监听</p></li><li><p>history     查看执行的历史记录</p></li><li><p>redo cmdno  重复 执行命令，history 中命令编号确定</p></li><li><p>quit  退出客户端</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">1</span>] ls <span class="hljs-operator">/</span><br>[zookeeper]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">2</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>node1<br>Created <span class="hljs-operator">/</span>node1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">3</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-keyword">null</span><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">4</span>] <span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>node1 &quot;node1 value&quot;<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">5</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br>node1 <span class="hljs-keyword">value</span><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">6</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>Created <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">7</span>] <span class="hljs-keyword">set</span>  <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">8</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br><span class="hljs-string">&#x27;get path [watch]&#x27;</span> has been deprecated. Please use <span class="hljs-string">&#x27;get [-s] [-w] path&#x27;</span> instead.<br>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">9</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">10</span>] <span class="hljs-keyword">delete</span> <span class="hljs-operator">/</span>node1<br>Node <span class="hljs-keyword">not</span> <span class="hljs-keyword">empty</span>: <span class="hljs-operator">/</span>node1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">11</span>] deleteall <span class="hljs-operator">/</span>node1<br>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeDeleted path:<span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">12</span>] ls <span class="hljs-operator">/</span><br>[zookeeper]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">13</span>] history<br><span class="hljs-number">3</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-number">4</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>node1 &quot;node1 value&quot;<br><span class="hljs-number">5</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-number">6</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br><span class="hljs-number">7</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">set</span>  <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br><span class="hljs-number">8</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br><span class="hljs-number">9</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br><span class="hljs-number">10</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">delete</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-number">11</span> <span class="hljs-operator">-</span> deleteall <span class="hljs-operator">/</span>node1<br><span class="hljs-number">12</span> <span class="hljs-operator">-</span> ls <span class="hljs-operator">/</span><br><span class="hljs-number">13</span> <span class="hljs-operator">-</span> history<br><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">16</span>] redo <span class="hljs-number">2</span><br>Created <span class="hljs-operator">/</span>node1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">17</span>] ls <span class="hljs-operator">/</span><br>[node1, zookeeper]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">18</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>node1<br><span class="hljs-keyword">null</span><br>cZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x8</span><br>ctime <span class="hljs-operator">=</span> Thu Jan <span class="hljs-number">13</span> <span class="hljs-number">22</span>:<span class="hljs-number">49</span>:<span class="hljs-number">37</span> CST <span class="hljs-number">2022</span><br>mZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x8</span><br>mtime <span class="hljs-operator">=</span> Thu Jan <span class="hljs-number">13</span> <span class="hljs-number">22</span>:<span class="hljs-number">49</span>:<span class="hljs-number">37</span> CST <span class="hljs-number">2022</span><br>pZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x8</span><br>cversion <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>dataVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>aclVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>ephemeralOwner <span class="hljs-operator">=</span> <span class="hljs-number">0x0</span><br>dataLength <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>numChildren <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库实现分布式锁</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是分布式锁"><a href="#1-什么是分布式锁" class="headerlink" title="1 什么是分布式锁"></a>1 什么是分布式锁</h1><ul><li>在单体的应用开发场景中涉及并发同步的时候，大家往往采用Synchronized（同步）或者其他同一个JVM内Lock机制来解决多线程间的同步问题。</li><li>在分布式集群工作的开发场景中，就需要一种更加高级的锁机制来处理跨机器的进程之间的数据同步问题，这种跨机器的锁就是分布式锁</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222616394.png" alt="image-20230228222616394"></p><h1 id="2-基于数据库实现分布式锁"><a href="#2-基于数据库实现分布式锁" class="headerlink" title="2 基于数据库实现分布式锁"></a>2 基于数据库实现分布式锁</h1><p>基于数据库实现分布式锁主要是利用数据库的唯一索引来实现，唯一索引天然具有排他性，这刚好符合我们对锁的要求</p><h2 id="2-1-设计原理"><a href="#2-1-设计原理" class="headerlink" title="2.1 设计原理"></a>2.1 设计原理</h2><ul><li>同一时刻只能允许一个竞争者获取锁。加锁时我们在数据库中插入一条记录，利用唯一键进行防重。</li><li>当竞争者A加锁成功后，第竞争者B再来加锁就会抛出唯一索引冲突，如果抛出这个异常，我们就判定竞争者B加锁失败</li><li>竞争者B加锁失败后，会阻塞等待，一直到竞争者A释放锁（也就是删除记录后），再去获取锁</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228222626149.png" alt="image-20230228222626149"></p><h2 id="2-2-实现注意事项"><a href="#2-2-实现注意事项" class="headerlink" title="2.2 实现注意事项"></a>2.2 实现注意事项</h2><ul><li>没有锁超时机制。如果程序发生了异常，将无法删除数据，也就是锁无法被释放掉，需要自己写一套锁超时机制，比如：在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；</li><li>基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，可以考虑实现数据库的高可用方案</li><li>自旋实现阻塞效果。当获取锁失败时自旋转</li><li>如果使用数据库自增 id ,<strong>规律太明显</strong></li><li><strong>受单表数据量的限制</strong> 在高并发场景下，我们都知道 MySQL 的单张表根本不可能容纳大量数据（性能等原因的限制）；如果是将单表拆成多表，还是用数据库自增 id 的话，就存在了 id 重复的情况了，很显然这是业务不允许的。</li></ul><blockquote><p>db操作性能较差，并且有锁表的风险，一般不考虑。</p></blockquote><h2 id="2-3-代码示例"><a href="#2-3-代码示例" class="headerlink" title="2.3 代码示例"></a>2.3 代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"> */<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span></span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加锁，增加重试逻辑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//尝试获取锁</span><br>        <span class="hljs-keyword">if</span>(tryLock())&#123;<br>            System.out.println(<span class="hljs-string">&quot;---------获取锁---------&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//等待锁 阻塞</span><br>            waitLock();<br>            <span class="hljs-comment">//重试</span><br>            lock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlDistributedLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLock</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MethodlockMapper baseMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//插入一条数据   insert into</span><br>            baseMapper.insert(<span class="hljs-keyword">new</span> Methodlock(<span class="hljs-string">&quot;lock&quot;</span>));<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <span class="hljs-comment">//插入失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//删除数据   delete</span><br>        baseMapper.deleteByMethodlock(<span class="hljs-string">&quot;lock&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-------释放锁------&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
      <tag>zookeeper</tag>
      
      <tag>mysql</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis缓存问题</title>
    <link href="/Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <url>/Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1 缓存穿透"></a>1 <strong>缓存穿透</strong></h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 导致不存在的数据每次请求都要到存储层去查询， 失去了缓存保护后端存储的意义。 </p><h2 id="1-2-产生原因"><a href="#1-2-产生原因" class="headerlink" title="1.2 产生原因"></a>1.2 产生原因</h2><ul><li>自身业务代码或者数据出现问题。 </li><li>一些恶意攻击、 爬虫等造成大量空命中。</li></ul><h2 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3 解决方案"></a>1.3 解决方案</h2><h3 id="1-3-1-缓存空对象"><a href="#1-3-1-缓存空对象" class="headerlink" title="1.3.1 缓存空对象"></a>1.3.1 缓存空对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    String cacheValue = cache.get(key);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;<br>        <span class="hljs-comment">// 从存储中获取</span><br>        String storageValue = storage.get(key);<br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span><br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-keyword">null</span>) &#123;<br>            cache.expire(key, <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 缓存非空</span><br>        <span class="hljs-keyword">return</span> cacheValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-布隆过滤器"><a href="#1-3-2-布隆过滤器" class="headerlink" title="1.3.2 布隆过滤器"></a>1.3.2 布隆过滤器</h3><p>在访问缓存前，先用布隆过滤器先做一次过滤。对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。</p><p>布隆过滤器底层就是实现了一个大型的二进制数组，我们需要在使用前将所有的数据放入布隆过滤器，并且在增加数据时也要往布隆过滤器里放，布隆过滤器可以根据多个hash算法对key进行hash+数组长度取模的方式，给每一条数据计算出多个位置。</p><p>所以在访问数据是否存在时，他也会把这几个位置算出来，如果这几个位置有一个为0，那么就说明这个数据一定不存在。因为存在hash碰撞，所以如果所有位都为1，不能说明这个key一定存在。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225351935.png" alt="image-20230228225351935"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.redisson;<br><br><span class="hljs-keyword">import</span> org.redisson.Redisson;<br><span class="hljs-keyword">import</span> org.redisson.api.RBloomFilter;<br><span class="hljs-keyword">import</span> org.redisson.api.RedissonClient;<br><span class="hljs-keyword">import</span> org.redisson.config.Config;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedissonBloomFilter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Config config = <span class="hljs-keyword">new</span> Config();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://localhost:6379&quot;</span>);<br>        <span class="hljs-comment">//构造Redisson</span><br>        RedissonClient redisson = Redisson.create(config);<br><br>        RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="hljs-string">&quot;nameList&quot;</span>);<br>        <span class="hljs-comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%,根据这两个参数会计算出底层的bit数组大小</span><br>        bloomFilter.tryInit(<span class="hljs-number">100000000L</span>,<span class="hljs-number">0.03</span>);<br>      <br>        <span class="hljs-comment">//把所有数据存入布隆过滤器</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">for</span> (String key: keys) &#123;<br>                bloomFilter.put(key);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>            <span class="hljs-comment">// 从布隆过滤器这一级缓存判断下key是否存在</span><br>            Boolean exist = bloomFilter.contains(key);<br>            <span class="hljs-keyword">if</span>(!exist)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br>            <span class="hljs-comment">// 从缓存中获取数据</span><br>            String cacheValue = cache.get(key);<br>            <span class="hljs-comment">// 缓存为空</span><br>            <span class="hljs-keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;<br>                <span class="hljs-comment">// 从存储中获取</span><br>                String storageValue = storage.get(key);<br>                cache.set(key, storageValue);<br>                <span class="hljs-comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span><br>                <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-keyword">null</span>) &#123;<br>                    cache.expire(key, <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);<br>                &#125;<br>                <span class="hljs-keyword">return</span> storageValue;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 缓存非空</span><br>                <span class="hljs-keyword">return</span> cacheValue;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-缓存失效-击穿"><a href="#2-缓存失效-击穿" class="headerlink" title="2 缓存失效(击穿)"></a>2 <strong>缓存失效(击穿)</strong></h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>由于大批量缓存在同一时间失效可能导致大量请求同时穿透缓存直达数据库，可能会造成数据库瞬间压力过大 甚至挂掉。</p><h2 id="2-2-产生原因"><a href="#2-2-产生原因" class="headerlink" title="2.2 产生原因"></a>2.2 产生原因</h2><p>大批量缓存在同一时间失效</p><h2 id="2-3-解决方案"><a href="#2-3-解决方案" class="headerlink" title="2.3 解决方案"></a>2.3 解决方案</h2><h3 id="2-3-1-将这一批数据的缓存过期时间设置为一个时间段内的不同时间。"><a href="#2-3-1-将这一批数据的缓存过期时间设置为一个时间段内的不同时间。" class="headerlink" title="2.3.1 将这一批数据的缓存过期时间设置为一个时间段内的不同时间。"></a>2.3.1 将这一批数据的缓存过期时间设置为一个时间段内的不同时间。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    String cacheValue = cache.get(key);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;<br>        <span class="hljs-comment">// 从存储中获取</span><br>        String storageValue = storage.get(key);<br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">//设置一个过期时间(300到600之间的一个随机数)</span><br>        <span class="hljs-keyword">int</span> expireTime = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">300</span>)  + <span class="hljs-number">300</span>;<br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-keyword">null</span>) &#123;<br>            cache.expire(key, expireTime);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 缓存非空</span><br>        <span class="hljs-keyword">return</span> cacheValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3 缓存雪崩"></a>3 <strong>缓存雪崩</strong></h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h2><p>缓存雪崩指的是缓存层支撑不住或宕掉后， 流量打向后端存储层 ，存储层的调用量会暴增， 造成存储层也会级联宕机的情况。</p><h2 id="3-2-产生原因"><a href="#3-2-产生原因" class="headerlink" title="3.2 产生原因"></a>3.2 产生原因</h2><ul><li>redis集群挂了</li><li>请求数量大于redis可承受的最大数量</li></ul><h2 id="3-3-解决方案"><a href="#3-3-解决方案" class="headerlink" title="3.3 解决方案"></a>3.3 解决方案</h2><h3 id="3-3-1-保证缓存层服务高可用性"><a href="#3-3-1-保证缓存层服务高可用性" class="headerlink" title="3.3.1 保证缓存层服务高可用性"></a>3.3.1 保证缓存层服务高可用性</h3><p>比如使用Redis Sentinel或Redis Cluster。 </p><h3 id="3-3-2-后端限流熔断并降级。"><a href="#3-3-2-后端限流熔断并降级。" class="headerlink" title="3.3.2 后端限流熔断并降级。"></a>3.3.2 后端限流熔断并降级。</h3><p>比如使用Sentinel或Hystrix限流降级组件。 </p><ul><li>比如服务降级，我们可以针对不同的数据采取不同的处理方式。<ul><li>当业务应用访问的是非核心数据（例如电商商 品属性，用户信息等）时，暂时停止从缓存中查询这些数据，而是直接返回预定义的默认降级信息、空值或是错误提示信息；</li><li>当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失， 也可以继续通过数据库读取。</li></ul></li></ul><h1 id="4-热点缓存key重建优化"><a href="#4-热点缓存key重建优化" class="headerlink" title="4 热点缓存key重建优化"></a>4 <strong>热点缓存key重建优化</strong></h1><h2 id="4-1定义"><a href="#4-1定义" class="headerlink" title="4.1定义"></a>4.1定义</h2><p>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。 重建缓存不能在短时间完成， 可能是一个复杂计算， 例如复杂的SQL、 多次IO、 多个依赖等。 </p><h2 id="4-2-产生原因"><a href="#4-2-产生原因" class="headerlink" title="4.2 产生原因"></a>4.2 产生原因</h2><p>在缓存失效的瞬间， 有大量线程来重建缓存， 造成后端负载加大， 甚至可能会让应用崩溃。</p><h2 id="4-3-解决方案"><a href="#4-3-解决方案" class="headerlink" title="4.3 解决方案"></a>4.3 解决方案</h2><h3 id="4-3-1-互斥锁"><a href="#4-3-1-互斥锁" class="headerlink" title="4.3.1 互斥锁"></a>4.3.1 互斥锁</h3><p>利用互斥锁来解决，此方法只允许一个线程重建缓存， 其他线程等待重建缓存的线程执行完， 重新从缓存获取数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从Redis中获取数据</span><br>    String value = redis.get(key);<br>    <span class="hljs-comment">// 如果value为空， 则开始重构缓存</span><br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 只允许一个线程重建缓存， 使用nx， 并设置过期时间ex</span><br>        String mutexKey = <span class="hljs-string">&quot;mutext:key:&quot;</span> + key;<br>        <span class="hljs-keyword">if</span> (redis.set(mutexKey, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;ex 180&quot;</span>, <span class="hljs-string">&quot;nx&quot;</span>)) &#123;<br>             <span class="hljs-comment">// 从数据源获取数据</span><br>            value = db.get(key);<br>            <span class="hljs-comment">// 回写Redis， 并设置过期时间</span><br>            redis.setex(key, timeout, value);<br>            <span class="hljs-comment">// 删除key_mutex</span><br>            redis.delete(mutexKey);<br>        &#125;<span class="hljs-comment">// 其他线程休息50毫秒后重试</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            get(key);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-缓存与数据库不一致"><a href="#5-缓存与数据库不一致" class="headerlink" title="5 缓存与数据库不一致"></a>5 <strong>缓存与数据库不一致</strong></h1><h2 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h2><p>在大并发下，同时操作数据库与缓存会存在数据不一致性问题</p><h2 id="5-2-产生原因"><a href="#5-2-产生原因" class="headerlink" title="5.2 产生原因"></a>5.2 产生原因</h2><ul><li><p>双写不一致情况 。</p><p>我们去写redis的时候，基本都是先写入数据库，然后再写入redis。出现问题的场景如下：</p><ol><li>线程1写入数据库后，一些原因卡住了</li><li>线程2也去写数据库，更新缓存</li><li>线程1再去更新缓存的时候，是有问题的，因为他的数据不是最新的。</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225410250.png" alt="image-20230228225410250"></p></li><li><p>读写并发不一致 </p><p>我们还有种写入redis的方式是，写完数据库后删除缓存，查询数据的时候，再去更新缓存。出现问题的场景如下：</p><ol><li><p>线程1更新数据库为10，删除缓存</p></li><li><p>线程3查询缓存，此时数据库的值为10</p></li><li><p>线程2更新数据库为6，删除缓存</p></li><li><p>线程3更新缓存为10</p></li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225417391.png" alt="image-20230228225417391"></p></li></ul><h2 id="5-3-解决方案"><a href="#5-3-解决方案" class="headerlink" title="5.3 解决方案"></a>5.3 解决方案</h2><h3 id="5-3-1-分布式读写锁"><a href="#5-3-1-分布式读写锁" class="headerlink" title="5.3.1 分布式读写锁"></a>5.3.1 分布式读写锁</h3><ul><li><p>对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</p></li><li><p>如果不能容忍缓存数据不一致，可以通过加<strong>分布式读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读的时候相当于无锁</strong>，redsion就支持。</p></li><li><p><strong>放入缓存的数据应该是对实时性、一致性要求不是很高的数据。</strong>如果<strong>写多读多</strong>的情况又不能容忍缓存数据不一致，那就没必要加缓存了，可以直接操作数据库。如果数据库抗不住压力，还可以把缓存作为数据读写的主存储，异步将数据同步到数据库，数据库只是作为数据的备份。</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225427756.png" alt="image-20230228225427756"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis集群三种方式</title>
    <link href="/Redis%E9%9B%86%E7%BE%A4%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/Redis%E9%9B%86%E7%BE%A4%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要有集群"><a href="#为什么要有集群" class="headerlink" title="为什么要有集群"></a>为什么要有集群</h1><ul><li>单个Redis存在不稳定性，当Redis服务宕机或硬盘故障，系统崩溃之后，就没有可用的服务了，还会造成数据的丢失</li><li>单个Redis的读写能力也是有限的</li><li>还由于互联网的三高<a href="https://so.csdn.net/so/search?q=%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">架构</a>，高并发，高性能，高可用</li></ul><blockquote><p>通过添加服务器的数量，提供相同的服务，从而让服务器达到一个稳定，高效的状态</p></blockquote><h1 id="Redis集群的三种模式"><a href="#Redis集群的三种模式" class="headerlink" title="Redis集群的三种模式"></a>Redis集群的三种模式</h1><h2 id="1-主从模式"><a href="#1-主从模式" class="headerlink" title="1. 主从模式"></a>1. 主从模式</h2><h3 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h3><ul><li>避免单点Redis服务器故障。数据丢失，可能对业务造成灾难性打击</li><li>容量瓶颈。内存不足，一台redis内存是有限的</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p>一个master可以拥有多个slave，一个slave只对应一个master</p></li><li><p><strong>一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读</strong>。</p></li><li><p>所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑<strong>读高并发</strong>。</p></li><li><p>slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来。可以使用全量复制和部分复制</p></li><li><p>master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务</p></li><li><p>master挂了以后，不会在slave节点中重新选一个master，只能手动的一个一个改，不合适，就有了之后的哨兵</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224935732.png" alt="image-20230228224935732"></p><h3 id="Redis主从复制工作原理"><a href="#Redis主从复制工作原理" class="headerlink" title="Redis主从复制工作原理"></a><strong>Redis主从复制工作原理</strong></h3><h4 id="1-全量复制流程："><a href="#1-全量复制流程：" class="headerlink" title="1. 全量复制流程："></a>1. 全量复制流程：</h4><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份，具体步骤如下：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224944541.png" alt="image-20230228224944541"></p><ol><li>如果你为master配置了一个slave，不管这个slave是否是第一次连接上Master，它都会发送一个<strong>SYNC</strong>命令(redis2.8版本之前的命令)master请求复制数据。</li><li>master收到SYNC命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件。</li><li>master将生成的rdb数据发给slave。</li><li>Master由于从执行bgsave到生成rdb数据存在时间，在此时间间隔内，可能有新的客户端请求，master会把这些最近的请求缓存在内存中。（也就是一个最近数据的缓冲区，默认大小为1M）</li><li>当第3步的rdb数据发完后，他会把这些缓存的数据也发给slave</li><li>当slave有老的rdb数据，就会先把老的数据清掉。重新生成包含缓存的rd b数据，并加载到内存中。</li><li>之后，master和slave通过socket长连接，持续进行命令同步，从而保证主从数据一致。</li></ol><blockquote><p>当master与slave之间的连接由于某些原因而断开时，slave能够自动重连Master。</p></blockquote><blockquote><p>如果master收到了多个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的slave。  </p></blockquote><p><strong>当master和slave断开重连后，一般都会对整份数据进行复制。但从redis2.8版本开始，master和slave断开重连后支持部分复制</strong>。</p><h4 id="2-部分复制流程"><a href="#2-部分复制流程" class="headerlink" title="2. 部分复制流程"></a>2. 部分复制流程</h4><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224955344.png" alt="image-20230228224955344"></p><ol><li>从2.8版本开始，slave与master能够在网络连接断开<strong>重连后只进行部分数据复制。</strong> </li><li>master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据。master和它所有的slave都维护了复制的数据下标offset和master的进程id。</li><li>当网络连接断开后，slave会请求master继续进行未完成的复制。<ul><li>从节点数据下标 offset还在缓存队列里，那么将会从slave记录的数据下标开始从缓存区复制。</li><li>如果master进程id变化了，或者从节点数据下标 offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制</li></ul></li></ol><h4 id="3-增量复制"><a href="#3-增量复制" class="headerlink" title="3 增量复制"></a>3 增量复制</h4><ul><li><p>是指在初始化的全量复制并开始正常工作之后，master服务器将发生的写操作同步到slave服务器的过程</p></li><li><p>增量复制的过程主要是master服务器每执行一个写命令就会向slave服务器发送相同的写命令，slave服务器接收并执行收到的写命令。</p></li></ul><h2 id="2-哨兵模式"><a href="#2-哨兵模式" class="headerlink" title="2. 哨兵模式"></a>2. 哨兵模式</h2><h3 id="产生的原因-1"><a href="#产生的原因-1" class="headerlink" title="产生的原因"></a>产生的原因</h3><p>主从模式下，主机宕机，需要人为去设置master，哨兵模式就是解决：不用人为进行干预，高可用的恢复正常。</p><blockquote><p>哨兵（sentinel）是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master</p></blockquote><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><ul><li>监控：sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来不断地检查master和slave是否正常运行。 </li><li>自动故障转移：当master出现问题时，选取一个slave作为master，将其他slave连接到新地master，并告知客户端新地服务器地址</li><li>通知：当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</li></ul><p><strong>注⚠️：</strong></p><ul><li>哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过sentinel代理访问redis的主节点。</li><li>哨兵也是一台redis服务器，只是不提供数据服务</li><li>为了高可用一般都推荐至少部署三个哨兵节点</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225006830.png" alt="image-20230228225006830"></p><h3 id="哨兵leader选举流程"><a href="#哨兵leader选举流程" class="headerlink" title="哨兵leader选举流程"></a><strong>哨兵leader选举流程</strong></h3><p>当一个master服务器被某sentinel视为下线状态后，该sentinel会与其他sentinel协商选出sentinel的leader进行故障转移工作。</p><ol><li>每个发现master服务器进入下线的sentinel都可以要求其他sentinel选自己为sentinel的 leader，选举是先到先得。</li><li>超过一半的sentinel选举某sentinel作为leader。之后该sentinel进行故障转移操作，从存活的slave中选举出新的master</li></ol><h2 id="3-Cluster模式"><a href="#3-Cluster模式" class="headerlink" title="3. Cluster模式"></a>3. Cluster模式</h2><h3 id="产生的原因-2"><a href="#产生的原因-2" class="headerlink" title="产生的原因"></a>产生的原因</h3><ul><li>哨兵模式，如果master节点异常，在主从切换的瞬间，存在不可用的情况。</li><li>哨兵模式只有单个主节点可以用来写，没法支持很高的并发。</li><li>哨兵模式单个节点的内存也不宜设的太大，会导致持久化文件过大，影响数据恢复主从效率。</li></ul><h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><ul><li>Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态。</li><li>提供多个master节点提供写服务，每个master节点中存储的数据都不一样，这些数据通过数据分片的方式被自动分割到不同的master节点上。</li><li>每个master节点下面还需要添加至少1个slave节点，这样当某个master节点发生故障后，可以从它的slave节点中选举一个作为新的master节点继续提供服务</li><li>Redis Cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每 个节点中。当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228225016550.png" alt="image-20230228225016550"></p><h3 id="槽位定位算法"><a href="#槽位定位算法" class="headerlink" title="槽位定位算法"></a><strong>槽位定位算法</strong></h3><p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模 来得到具体槽位。 </p><p><code>HASH_SLOT = CRC16(key) mod 16384</code> </p><h3 id="网络抖动"><a href="#网络抖动" class="headerlink" title="网络抖动"></a><strong>网络抖动</strong></h3><ul><li><p>Redis Cluster 提供了一种选项<code>cluster-­node-­timeout</code>，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。</p></li><li><p>如果没有这个选项，网络抖动会导致主从频 繁切换 (数据的重新复制)。</p></li></ul><h3 id="Redis集群选举原理分析"><a href="#Redis集群选举原理分析" class="headerlink" title="Redis集群选举原理分析"></a><strong>Redis集群选举原理分析</strong></h3><p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下： </p><ol><li><p>slave发现自己的master变为FAIL </p></li><li><p>将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST 信息</p></li><li><p>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个 slaver只发送一次ack </p></li><li><p>slave收到超过半数master的ack后变成新Master</p></li><li><p>.slave广播Pong消息通知其他集群节点。</p></li></ol><p>注意⚠️：</p><ul><li>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟。一定的延迟确保我们等待 FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票</li><li>延迟计算公式： DELAY &#x3D; 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</li></ul><p>​       SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。</p><h3 id="集群脑裂数据丢失问题"><a href="#集群脑裂数据丢失问题" class="headerlink" title="集群脑裂数据丢失问题"></a><strong>集群脑裂数据丢失问题</strong></h3><p>网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复， 会将其中一个主节点变为从节点，这时会有大量数据丢失。</p><p>规避方法可以在redis配置里加上参数(这种方法不可能百分百避免数据丢失，参考集群leader选举机制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">min‐replicas‐to‐write <span class="hljs-number">1</span> <span class="hljs-comment">//写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如 集群总共三个节点可以配置1，加上leader就是2，超过了半数</span><br></code></pre></td></tr></table></figure><p>这个配置在一定程度上会影响集群的可用性，比如slave要是少于1个，这个集群就算leader正常也不能提供服务了，需要具体场景权衡选择。 </p><h3 id="Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数"><a href="#Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数" class="headerlink" title="Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数"></a><strong>Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数</strong></h3><ul><li>因为新master的选举需要大于半数的集群master节点同意才能选举成功</li><li>奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，都只允许挂一个节点，否则集群不可用。所以奇数的master节点更多的是<strong>从节省机器资源角度出发</strong>说的。</li></ul><h3 id="Redis集群对批量操作命令的支持"><a href="#Redis集群对批量操作命令的支持" class="headerlink" title="Redis集群对批量操作命令的支持"></a><strong>Redis集群对批量操作命令的支持</strong></h3><p>对于类似mset，mget这样的多个key的原生批量操作命令，redis集群只支持所有key落在同一slot的情况，如 果有多个key一定要用mset命令在redis集群上操作，则可以在key的前面加上{XX}，这样参数数据分片hash计算的只会是大括号里的值，这样能确保不同的key能落到同一slot里去，示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mset &#123;user1&#125;:<span class="hljs-number">1</span>:name zhuge &#123;user1&#125;:<span class="hljs-number">1</span>:age <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>假设name和age计算的hash slot值不一样，但是这条命令在集群下执行，redis只会用大括号里的 user1 做 hash slot计算，所以算出来的slot值肯定相同，最后都能落在同一slot</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis主从架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis持久化</title>
    <link href="/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>redis 持久化主要有2种方式：RDB 和AOF</p></blockquote><h1 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h1><h2 id="什么是RDB快照"><a href="#什么是RDB快照" class="headerlink" title="什么是RDB快照"></a>什么是RDB快照</h2><ul><li>rdb就是快照，是redis默认的持久化方式，就是把所有的数据持久化到磁盘，隔一段时间持久化一次到 dump.rdb 的二进制文件中，在服务器重启后只需要把文件中的数据恢复即可。 </li><li>你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。 比如说， <code>save 60 1000</code>会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集</li></ul><h2 id="RDB-文件的创建"><a href="#RDB-文件的创建" class="headerlink" title="RDB 文件的创建"></a>RDB 文件的创建</h2><blockquote><p>有两种方式：手动触发和自动触发</p></blockquote><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><ul><li>save命令会阻塞当前Redis服务器，直到RDB过程完成为止。在服务器进程阻塞期间，服务器不能处理任何命令请求。因此，当save命令正在执行时，客户端发送的所有命令都会被拒绝，知道save命令执行完毕。（不建议使用）</li><li>bgsave 命令会fork出一个子进程(而不是线程)，由子进程进行RDB文件创建，而父进程继续处理命令。</li></ul><blockquote><p>进入redis客户端执行命令<strong>save</strong>或<strong>bgsave</strong>可以生成dump.rdb文件， 每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。 </p></blockquote><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>redis通过配置文件进行配置，redis可以通过设置服务器配置的save选项，服务器每隔一段时间自动执行一次bgsave命令。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>适合大规模的数据恢复，恢复速度快！</li><li>体积小，相较于aof他只是保存了结果，不需要保存每一次命令操作。</li></ul><p><strong>缺点：</strong></p><ul><li>数据需要一定的时间间隔进程操作！ 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据就没有了。</li></ul><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><ul><li>以独立日志的方式记录每次写命令，每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 appendonly.aof文 件的末尾，并在 Redis 重启时在重新执行 AOF 文件中的命令以达到恢复数据的目的。</li><li>AOF 的主要作用是解决数据持久化的实时性。</li><li>你可以通过修改配置文件来打开 AOF 功能：  <code>appendonly yes </code></li><li>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。 <ul><li><strong>appendfsync always</strong>：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</li><li><strong>appendfsync everysec</strong>：每秒 fsync 一次，足够快（和使用 RDB 持久化差不多），并且在 故障时只会丢失 1 秒钟的数据。</li><li><strong>appendfsync no</strong>：：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。因为你不清楚不同的操作系统底层是怎么去刷磁盘的。</li></ul></li></ul><h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><ul><li><p>AOF文件里可能有太多没用指令，比如3次递增readcount, 重写后直接会变成readcount:3，AOF会定期根据<strong>内存的最新数据</strong>生成aof文件</p></li><li><p>进入redis客户端执行命令<strong>bgrewriteaof</strong>重写AOF </p></li><li><p>AOF重写redis会fork出一个子进程去做，不会对redis正常命令处理有太多影响</p></li><li><p>如下两个配置可以控制AOF自动重写频率 </p><ul><li>auto-aof-rewrite-min-size 64mb &#x2F;&#x2F;aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</li><li>auto-aof-rewrite-percentage 100 &#x2F;&#x2F;aof文件自上一次重写后文件大小增长了100%则再次触发重写</li></ul></li></ul><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p><ul><li>每一次修改都同步，文件的完整性会更加好！</li></ul><p><strong>缺点：</strong></p><ul><li>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</li></ul><h1 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a><strong>Redis 4.0 混合持久化</strong></h1><blockquote><p>重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志存放，但是存放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p><p>Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。 通过配置 <code> aof-use-rdb-preamble yes</code>可以开启混合持久化。   </p></blockquote><h2 id="混合持久化流程"><a href="#混合持久化流程" class="headerlink" title="混合持久化流程"></a>混合持久化流程</h2><ul><li>如果开启了混合持久化。<strong>AOF在重写时</strong>，不再是单纯将内存数据转换为命令写入AOF文件，而是根据aof命令重写<strong>这一刻之前</strong>的内存做RDB快照处理，并且将RDB快照内容和<strong>增量的</strong>AOF修改内存数据的命令存在一起，都写入新的AOF文件。</li><li>新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换。</li><li>于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再加载增量 AOF 日志就可以完全替代之前的 AOF 全量文件的加载，因此重启效率大幅得到提升。</li></ul><h2 id="混合持久化AOF文件结构"><a href="#混合持久化AOF文件结构" class="headerlink" title="混合持久化AOF文件结构"></a>混合持久化AOF文件结构</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxtx3e8tbhj30r40i23zd.jpg" style="zoom:50%;" /><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxtx4ka5e8j31ey0q6myv.jpg" style="zoom: 33%;" /></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis持久化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 核心数据结构</title>
    <link href="/redis/"/>
    <url>/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="redis-是什么？"><a href="#redis-是什么？" class="headerlink" title="redis 是什么？"></a>redis 是什么？</h1><blockquote><p>redis是一个高性能的key-value 数据库，它可以用来存储字符串，哈希，列表，集合，有序集合。</p></blockquote><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxrgdfb02gj30tq0v2whf.jpg" style="zoom:50%;" /><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String 是redis中最基础的数据结构，主要用在常规计数，如：统计网站访问数据量，当前在线人数等</p><p><strong>应用场景</strong></p><ul><li><p>单值缓存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> key1 &quot;zhangsan&quot;<br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> key1<br>&quot;zhangsan&quot;<br></code></pre></td></tr></table></figure></li><li><p>计数器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> article:readcount:mysql<span class="hljs-operator">-</span>tutorial <span class="hljs-number">12</span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> article:readcount:mysql<span class="hljs-operator">-</span>tutorial<br>&quot;12&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> incr article:readcount:mysql<span class="hljs-operator">-</span>tutorial<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">13</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> article:readcount:mysql<span class="hljs-operator">-</span>tutorial<br>&quot;13&quot;<br></code></pre></td></tr></table></figure></li><li><p>分布式系统全局序列号<br>INCRBY  orderId  1000&#x2F;&#x2F;redis批量生成序列号提升性能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> orderId<br>&quot;99&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> incrby orderId  <span class="hljs-number">1000</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1099</span><br></code></pre></td></tr></table></figure></li><li><p>分布式锁</p><ul><li>SETNX  product:10001   </li><li>执行业务操作。。。</li><li>DEL  product:10001。                                     &#x2F;&#x2F;执行完业务释放锁</li><li>SET product:10001 true  ex  10  nx          &#x2F;&#x2F;防止程序意外终止导致死</li></ul></li></ul><blockquote><p>SETNX（ <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists ）</p><ul><li><p>在指定的 key 不存在时，为 key 设置指定的值，这种情况下等同 <a href="https://www.redis.com.cn/commands/set.html">SET</a> 命令。当 <code>key</code>存在时，什么也不做。</p></li><li><p>返回值</p><ul><li><code>1</code> 如果key被设置了</li><li><code>0</code> 如果key没有被设置</li></ul></li></ul></blockquote><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><ul><li>定义：Hash是一个field 和value 的映射表，特别适合存储对象，比如存储用户信息，商品信息等。</li><li>优缺点：<ul><li>优点<ul><li>同类数据归类整合储存，方便数据管理</li><li>相比string操作消耗内存与cpu更小</li><li>相比string储存更节省空间</li></ul></li><li>缺点<ul><li>过期功能不能使用在field上，只能用在key上</li></ul></li></ul></li></ul><p><strong>应用场景</strong></p><ul><li>对象缓存</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> HMSET  <span class="hljs-keyword">user</span>  <span class="hljs-number">1</span>:name  zhuge <span class="hljs-number">1</span>:balance  <span class="hljs-number">1888</span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> HMGET  <span class="hljs-keyword">user</span>  <span class="hljs-number">1</span>:name  <span class="hljs-number">1</span>:balance<br><span class="hljs-number">1</span>) &quot;zhuge&quot;<br><span class="hljs-number">2</span>) &quot;1888&quot;<br></code></pre></td></tr></table></figure><ul><li>电商购物车<ul><li>以用户id为key；     商品id为field；    商品数量为value；</li><li>购物车操作<ul><li>添加商品 <code> hset cart:user2 &quot;apple&quot; 1</code></li><li>增加数量  <code> hincrby cart:user2 &quot;apple&quot; 3</code></li><li>商品总数 <code>hlen cart:user2</code></li><li>删除商品 <code>hdel cart:user2 &quot;apple&quot;</code></li><li>获取购物车所有商品 <code>hgetall cart:user2</code></li></ul></li></ul></li></ul><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>list是一个链表结构，主要功能是push和pop（添加和弹出集合元素），获取一个范围的值等。常用于：粉丝列表，最新消息排行。</p><p><strong>应用场景</strong></p><ul><li><p>微博消息和微信公号消息<br>张三关注了2 个订阅号，美食专栏和娱乐周边</p><ul><li><p>美食专栏发推送</p><p> <code>lpush msg:zhangSan &quot;apple is yammy!&quot;</code></p></li><li><p>娱乐周边发推送.</p><p><code>lpush msg:zhangSan &quot;YangMi is beautiful!&quot;</code></p></li><li><p>查看张三关注的最新订阅号消息.</p><p> <code>lrange msg:zhangSan 0 5</code></p></li></ul></li></ul><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>Redis 中的set集合是无序且不可重复的，它最大的优势可以进行交集，丙级，差集等，常用来求共同好友等。</p><p><strong>应用场景</strong></p><ul><li><p>微信抽奖小程序</p><ul><li>点击参与抽奖加入集合</li></ul><p>​      <code>sadd iphone13 zhangsan</code></p><ul><li>查看参与抽奖所有用户</li></ul><p>​      <code>smembers iphone13</code>  </p><ul><li><p>抽取count名中奖者  </p><ul><li><p>返回集合中2个随机数.</p><p><code>srandmember iphone13 2</code></p></li><li><p>移除并返回集合中的2个随机元素 </p><p> <code>spop iphone13 2</code></p></li></ul></li></ul></li><li><p>微信微博点赞，收藏，标签</p><ul><li>点赞<br>SADD  like:{消息ID}  {用户ID}</li><li>取消点赞<br>SREM like:{消息ID}  {用户ID}</li><li>检查用户是否点过赞<br>SISMEMBER  like:{消息ID}  {用户ID}</li><li>获取点赞的用户列表<br>SMEMBERS like:{消息ID}</li><li>获取点赞用户数<br>SCARD like:{消息ID}</li></ul></li><li><p>集合操作</p><ul><li>交集：SINTER set1 set2 set3 </li><li>并集：SUNION set1 set2 set3</li><li>差集：SDIFF set1 set2 set3</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd set1 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd set2 <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sinter set1 set2<br><span class="hljs-number">1</span>) &quot;1&quot;<br><span class="hljs-number">2</span>) &quot;3&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sunion set1 set2<br><span class="hljs-number">1</span>) &quot;1&quot;<br><span class="hljs-number">2</span>) &quot;2&quot;<br><span class="hljs-number">3</span>) &quot;3&quot;<br><span class="hljs-number">4</span>) &quot;4&quot;<br><span class="hljs-number">5</span>) &quot;5&quot;<br><span class="hljs-number">6</span>) &quot;6&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sdiff set1 set2<br><span class="hljs-number">1</span>) &quot;2&quot;<br><span class="hljs-number">2</span>) &quot;4&quot;<br></code></pre></td></tr></table></figure></li></ul><h1 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h1><p>在set的基础上，增加了一个权重系数score，使集合中的元素可以按照score进行有序排列，常用于实现排行榜。</p><p><strong>应用场景</strong></p><ul><li><p>Zset集合操作实现排行榜</p><ul><li><p>点击新闻   </p><p>ZINCRBY  hotNews:20190819  1  守护香港</p></li><li><p>展示当日排行前十 </p><p> ZREVRANGE  hotNews:20190819  0  10  WITHSCORES </p></li><li><p>七日搜索榜单计算<br>ZUNIONSTORE  hotNews:20190813-20190819  7<br>hotNews:20190813  hotNews:20190814… hotNews:20190819</p><blockquote><p>[ZUNIONSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">key …]</a><br>计算给定的一个或多个有序集的并集，并存储在新的 key 中</p></blockquote></li><li><p>展示七日排行前十<br>ZREVRANGE hotNews:20190813-20190819  0  10  WITHSCORES</p><blockquote><p>[ ZREVRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到低</p></blockquote></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis 核心数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个SpringBoot项目</title>
    <link href="/%E7%AC%AC%E4%B8%80%E4%B8%AAspringboot%E9%A1%B9%E7%9B%AE/"/>
    <url>/%E7%AC%AC%E4%B8%80%E4%B8%AAspringboot%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><ul><li>进入官网 <a href="https://start.spring.io/">Spring Initializr</a> 初始化项目</li><li>编写控制HelloController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">helloController</span> </span>&#123;<br><br>  <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello World!&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.http.MediaType;<br><span class="hljs-keyword">import</span> org.springframework.test.web.servlet.MockMvc;<br><span class="hljs-keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.hamcrest.Matchers.equalTo;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;<br><br><span class="hljs-meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-meta">@AutoConfigureMockMvc</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">helloControllerTest</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    mockMvc.perform(MockMvcRequestBuilders.get(<span class="hljs-string">&quot;/hello&quot;</span>).accept(MediaType.APPLICATION_JSON))<br>      .andExpect(status().isOk())<br>      .andExpect(content().string(equalTo(<span class="hljs-string">&quot;hello World!&quot;</span>)));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><ul><li>idea 里面右击项目</li><li>build&#x2F;libs下运行 <code>Java -jar xxx</code></li><li>项目目录下运行：<code>gradle bootRun</code></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxr8m9n86ij30sq08ujrx.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql锁</title>
    <link href="/mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="锁是什么？"><a href="#锁是什么？" class="headerlink" title="锁是什么？"></a>锁是什么？</h1><ul><li>锁是计算机协调多个线程或进程并发访问同一资源的机制。</li><li>在数据库中，数据是一种共享的资源，因此也需要保证数据并发访问的一致性和有效性。</li></ul><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><ul><li><p>从性能上来分为：<code>乐观锁</code>和<code>悲观锁</code></p><ul><li><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><blockquote><p>乐观锁一般通过版本比对的方式来实现的：</p><ul><li><p>当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。</p></li><li><p>当我们提交更新的时候，判断数据库表对应记录的当前版本信息与我们第一次取出的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。那么更新操作就会失败。</p></li></ul></blockquote></li><li><p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p></li></ul></li><li><p>从操作类型来分为：<code>读锁</code>和<code>写锁</code></p><ul><li>读锁：也称为共享锁，多个读操作可以同时进行，且互不影响。</li><li>写锁：也称为拍他锁，他可以阻断其他读操作或者写操作。</li></ul></li><li><p>从可操作的粒度来分为：<code>表锁</code>和<code>行锁</code></p><ul><li><p>表锁：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲 </p><p>突的概率最高，并发度最低；</p></li><li><p>行锁：每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁 </p><p>冲突的概率最低，并发度最高。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见sql优化(二)</title>
    <link href="/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96-%E4%BA%8C/"/>
    <url>/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="一-分页查询优化"><a href="#一-分页查询优化" class="headerlink" title="一  分页查询优化"></a>一  <strong>分页查询优化</strong></h2><h3 id="1-根据自增且连续的主键排序的分页查询"><a href="#1-根据自增且连续的主键排序的分页查询" class="headerlink" title="1. 根据自增且连续的主键排序的分页查询"></a>1. 根据自增且连续的主键排序的分页查询</h3><blockquote><p>原则：按照主键去查询</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees limit <span class="hljs-number">90000</span>,<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 90001开始的五行数据，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">90000</span> limit <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。 </p><p>但是，这条改写的SQL 在很多场景并不实用，因为表中可能某些记录被删后，主键空缺，导致结果不一致，如：先删除一条前面的记录，然后再测试原 SQL 和优化后的 SQL</p><h3 id="2-根据非主键字段排序的分页查询"><a href="#2-根据非主键字段排序的分页查询" class="headerlink" title="2.根据非主键字段排序的分页查询"></a>2.根据非主键字段排序的分页查询</h3><blockquote><p>原则： 让排序和分页操作先查出主键，然后根据主键查到对应的记录，这样排序时返回的字段会少很多，从而会执行索引排序。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> name limit <span class="hljs-number">90000</span>,<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>表示根据非主键字段name排序的分页查询，发现并没有使用 name 字段的索引（key 字段对应的值为 null），具体原因为：扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引。</p><p>改写后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees e <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name limit <span class="hljs-number">90000</span>,<span class="hljs-number">5</span>) ed <span class="hljs-keyword">on</span> e.id <span class="hljs-operator">=</span> ed.id;<br></code></pre></td></tr></table></figure><h2 id="二-Join关联查询优化"><a href="#二-Join关联查询优化" class="headerlink" title="二   Join关联查询优化"></a>二   <strong>Join关联查询优化</strong></h2><h3 id="mysql的表关联常见有两种算法"><a href="#mysql的表关联常见有两种算法" class="headerlink" title="mysql的表关联常见有两种算法"></a>mysql的表关联常见有两种算法</h3><h4 id="1-嵌套循环连接（Nested-Loop-Join）-算法"><a href="#1-嵌套循环连接（Nested-Loop-Join）-算法" class="headerlink" title="1.嵌套循环连接（Nested-Loop Join） 算法"></a>1.嵌套循环连接（Nested-Loop Join） 算法</h4><ul><li><p>一次一行循环地从第一张表（称为<strong>驱动表</strong>）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（<strong>被驱动</strong>表）里取出满足条件的行，然后取出两张表的结果合集。</p></li><li><p>大致流程是：</p><ol><li><p>第一步：从表 t2 中读取一行数据，根据关联字段 到表 t1 中查找</p></li><li><p>第二步：取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端； </p></li><li><p>第三部：重复第二步</p></li></ol><blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">select</span><span class="hljs-operator">*</span><span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> t2 <span class="hljs-keyword">on</span> t1.a<span class="hljs-operator">=</span> t2.a;<br></code></pre></td></tr></table></figure><p>假设t2有100条数据，t1有10000条。整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(<strong>扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据（扫描索引很快，可以忽略），也就是总共 t1 表也扫描了100</strong> 行**)。因此整个过程扫描了 **200 行。</p></blockquote></li><li><p>优化器一般会优先选择小表做驱动表。<strong>所以使用 inner join 时，排在前面的表并不一定就是驱动表。</strong></p></li></ul><h4 id="2-基于块的嵌套循环连接（Block-Nested-Loop-Join）-算法"><a href="#2-基于块的嵌套循环连接（Block-Nested-Loop-Join）-算法" class="headerlink" title="2.基于块的嵌套循环连接（Block Nested-Loop Join） 算法"></a>2.基于块的嵌套循环连接（Block Nested-Loop Join） 算法</h4><ul><li><p>把<strong>驱动表</strong>的数据读入到 join_buffer 中，然后扫描<strong>被驱动表</strong>，把<strong>被驱动表</strong>每一行取出来跟 join_buffer 中的数据做对比。 </p></li><li><p>大致流程是：</p><ol><li><p>第一步：把t2中的所有数据放在join_buffer中</p></li><li><p>第二步：依次取出t1中的每一行，跟join_buffer中的数据做对比</p></li><li><p>第三部：返回满足条件的数据</p></li></ol><blockquote><p>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) &#x3D; <strong>10100</strong>。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000&#x3D; <strong>100 万次</strong>。</p></blockquote></li></ul><h3 id="对于关联sql的优化"><a href="#对于关联sql的优化" class="headerlink" title="对于关联sql的优化"></a>对于关联sql的优化</h3><ul><li><p>关联字段加索引，让mysql做join操作时，尽量选择嵌套循环算法。</p><blockquote><p>从上面的例子可以对比看出，嵌套循环算法因为有索引，每次进行查找时，只需根据索引，查找一条匹配的数据，即扫描一次。但基于块的嵌套循环连接却因为没有索引，每次都需要进行一次全表扫描。</p></blockquote></li><li><p>小表驱动大表。写多表连接sql时如果<strong>明确知道</strong>哪张表是小表可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间。</p><blockquote><p>straight_join同inner join类似，但是可以指定左边的表来驱动右边的表。但是使用它一定要慎重，因为大部分情况优化器是比人聪明的，人为指定的顺序不一定比搜索引擎靠谱。</p></blockquote></li></ul><h2 id="三-in和exsits优化"><a href="#三-in和exsits优化" class="headerlink" title="三  in和exsits优化"></a>三  <strong>in和exsits优化</strong></h2><blockquote><p> 原则：<strong>小表驱动大表</strong>，即小的数据集驱动大的数据集 </p></blockquote><ul><li><p>当B表的数据集 &lt; A表的数据集时，in优于exists</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B) <br>#等价于：  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B)&#123; <br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.id <span class="hljs-operator">=</span> B.id<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当B表的数据集 &gt; B表的数据集时，exists优于in</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> b.id <span class="hljs-operator">=</span> A.id) <br>#等价于：  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> A)&#123;<br>     <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换,官方说法是实际执行时会忽略SELECT清单,因此没有区别</p></blockquote></li></ul><h2 id="四-count-查询优化"><a href="#四-count-查询优化" class="headerlink" title="四  count(*)查询优化"></a>四  <strong>count(*)查询优化</strong></h2><h3 id="查询mysql自己维护的总行数"><a href="#查询mysql自己维护的总行数" class="headerlink" title="查询mysql自己维护的总行数"></a>查询mysql自己维护的总行数</h3><ul><li>对于<strong>myisam存储引擎</strong>的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被 mysql存储在磁盘上查询不需要计算 。</li><li>对于<strong>innodb存储引擎</strong>的表mysql不会存储表的总记录行数，查询count需要实时计算</li></ul><h3 id="show-table-status"><a href="#show-table-status" class="headerlink" title="show table status"></a><strong>show table status</strong></h3><ul><li><p>如果只需要知道表总行数的估计值可以用如下sql查询，性能很高 .</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxdq94vfa1j31rk088q4o.jpg"></p></li></ul><h3 id="count-优化方式"><a href="#count-优化方式" class="headerlink" title="count(*)优化方式"></a>count(*)优化方式</h3><ul><li><p><strong>将总数维护到Redis里</strong> </p><p>插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准（如mysql执行成功了，redis没有更新成功），很难保证表操作和redis操作的事务一致性 ，可能得考虑分布式事务，适用于准确度要求不高的场景。</p></li><li><p><strong>增加计数表</strong></p><p>插入或删除表数据行的时候同时维护计数表（如新建一个表，该表增加一个字段user_count，insert user 的同时更新该字段），让他们在同一个事务里操作，让mysql的事务来保证一致性。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见sql优化</title>
    <link href="/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96/"/>
    <url>/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="常见sql优化"><a href="#常见sql优化" class="headerlink" title="常见sql优化"></a>常见sql优化</h2><ul><li><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p></li><li><p>尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select * 语句</p></li><li><p>尽量不使用不等于（！&#x3D;或者&lt;&gt;），这些无法使用索引，会导致全表扫描 </p></li><li><p>尽量不使用 is null,is not null ，这些无法使用索引，会导致全表扫描 </p></li><li><p>like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</p></li><li><p>少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。</p></li><li><p>尽量将大范围拆分成多个小范围。单次数据量查询过大可能导致优化器最终选择不走索引</p></li><li><p>范围和范围右边的字段不会走索引，只有范围和范围之前的等值字段会走索引</p></li><li><p>不在索引列上做任何操作。（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描。</p></li></ul><p>准备工作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `employees` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">24</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  `position` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;职位&#x27;</span>,<br>  `hire_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;入职时 间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `idx_name_age_position` (`name`,`age`,`position`) <span class="hljs-keyword">USING</span> BTREE) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;员工记录表&#x27;</span>;<br>  <br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(name,age,position,hire_time) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;LiLei&#x27;</span>,<span class="hljs-number">22</span>,<span class="hljs-string">&#x27;mana ger&#x27;</span>,NOW());<br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(name,age,position,hire_time) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;HanMeimei&#x27;</span>, <span class="hljs-number">23</span>,<span class="hljs-string">&#x27;dev&#x27;</span>,NOW());<br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(name,age,position,hire_time) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;Lucy&#x27;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;dev&#x27;</span>,NOW());<br></code></pre></td></tr></table></figure><p>Eg1: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;LiLei&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx4g3b8iklj31m606ejsx.jpg"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">left</span>(name,<span class="hljs-number">3</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;LiLei&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx4g3oc8zsj31ek06cgmu.jpg"></p><p>Eg2:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> <span class="hljs-type">date</span>(hire_time) <span class="hljs-operator">=</span><span class="hljs-string">&#x27;2018-09-30&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> hire_time <span class="hljs-operator">&gt;=</span><span class="hljs-string">&#x27;2018-09-30 00:00:00&#x27;</span> <span class="hljs-keyword">and</span> hire_time <span class="hljs-operator">&lt;=</span><span class="hljs-string">&#x27;2018-09-30 23:59:59&#x27;</span>;<br></code></pre></td></tr></table></figure><p>给hire_time增加一个普通索引，上面的sql由于进行了date运算所以不会走索引，下面的会走。</p><h2 id="Using-filesort文件排序原理详解"><a href="#Using-filesort文件排序原理详解" class="headerlink" title="Using filesort文件排序原理详解"></a><strong>Using filesort文件排序原理详解</strong></h2><ul><li><p>MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。 </p></li><li><p>filesort文件排序方式</p><ul><li>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, packed_additional_fields &gt;</li><li>双路排序（又叫<strong>回表</strong>排序模式）：是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行</strong> <strong>数据的行 ID</strong>(主键)，然后在 sort buffer 中进行排序，排序完后需要再次通过主键回到原表查询需要的字段。用trace工具 可以看到sort_mode信息里显示&lt; sort_key, rowid &gt;</li></ul><blockquote><p> MySQL 通过比较系统变量 max_length_for_sort_data(<strong>默认1024字节</strong>) 的大小和需要查询的字段总大小来 判断使用哪种排序模式。</p><ul><li><p>如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 单路排序模式； </p></li><li><p>如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 双路排序模式。</p></li></ul></blockquote></li><li><p>单路排序 和 双路排序的选择</p><ul><li><p>如果 MySQL 排序内存配置的比较小并且没有条件继续增加了，可以适当max_length_for_sort_data 配 置小点，让优化器选择使用<strong>双路排序</strong>算法，可以在sort_buffer 中一次排序更多的行，只是需要再根据主键回到原表取数据。 </p></li><li><p>如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器 优先选择全字段排序(<strong>单路排序</strong>)，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查 询结果了。</p></li></ul></li></ul><blockquote><p>所以，MySQL通过 <strong>max_length_for_sort_data</strong> 这个参数来控制排序，在不同场景使用不同的排序模式， 从而提升排序效率。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Explain详解</title>
    <link href="/Explain%E8%AF%A6%E8%A7%A3/"/>
    <url>/Explain%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="explain使用介绍"><a href="#explain使用介绍" class="headerlink" title="explain使用介绍"></a>explain使用介绍</h1><ul><li><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈 </p></li><li><p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条SQL （如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）。</p></li><li><p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。表的意义相当广泛：可以是子查询、一个 union 结果等。</p></li></ul><p><strong>下面是使用explain的例子：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223313016.png" alt="image-20230228223313016"></p><h2 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a>explain中的列</h2><h3 id="id列"><a href="#id列" class="headerlink" title="id列"></a>id列</h3><ul><li><p>id列的编号就是select的序列号，有几个select就有几个id</p></li><li><p>id的顺序是按select 出现的顺序增长的</p></li><li><p>Id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor limit <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223320796.png" alt="image-20230228223320796"></p><h3 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h3><ul><li>simple: 简单查询。查询中不含子查询和联合查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223331408.png" alt="image-20230228223331408"></p><ul><li>primary : 复杂查询中最外层的select。</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor limit <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p>中的：<code>select *** from film </code> </p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223341496.png" alt="image-20230228223341496"></p><ul><li>subsquery: 复杂查询中的子查询（不在from子句中）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor limit <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p>中的：<code>select 1 from actor limit 1</code></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223405616.png"></p><ul><li>derived([dɪˈraɪv]) : 包含在from子句中的子查询。Mysql将把结果存放在一个临时表中，也称为派生表。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">set</span> session optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;derived_merge=off&#x27;</span>;<br>mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) der;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223416134.png"></p><ul><li>union ：在union后的select。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> id, name <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223426632.png" alt="image-20230228223426632"></p><blockquote><ul><li>union 用于把来自多个select  语句的结果组合到一个结果集合中。语法为：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-keyword">select</span>  <span class="hljs-keyword">column</span>,......<span class="hljs-keyword">from</span> table1<br><span class="hljs-keyword">union</span> [<span class="hljs-keyword">all</span>]<br> <span class="hljs-keyword">select</span>  <span class="hljs-keyword">column</span>,...... <span class="hljs-keyword">from</span> table2<br></code></pre></td></tr></table></figure></blockquote><h3 id="table列"><a href="#table列" class="headerlink" title="table列"></a>table列</h3><ul><li>这一列表示explain的这一行在执行哪个表</li><li>当form后有子查询时，table列为<code>&lt;derivedN&gt;</code>格式，表示当前查询依赖id &#x3D; N的查询，于是先执行id&#x3D; N的查询。</li></ul><h3 id="type-列"><a href="#type-列" class="headerlink" title="type 列"></a>type 列</h3><ul><li><p>这一列表示访问类型，即mysql决定如何查找表中的行。</p></li><li><p>性能排序从好到坏依次为：<code>system &gt;const&gt; eq_ref&gt; ref&gt; range &gt; index &gt; all</code>，一般来说，得保证查询至少到range级别，最好到ref。</p></li><li><p>具体的类型介绍。</p><blockquote><ul><li><p>NULL：mysql在窒息感阶段用不着访问表或者索引。例如索引列中取最小值，可以单独查找索引来完成，不需要执行时访问表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223438382.png" alt="image-20230228223438382"></p></li></ul></blockquote><blockquote><ul><li><p>const：直接按 primary key 或 unique key读取，将该列与常数比较，所以表最多有一个匹配行，读取1次，速度比较快</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id, name <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223446506.png" alt="image-20230228223446506"></p></li></ul></blockquote><blockquote><ul><li><p>eq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合 条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> film <span class="hljs-keyword">on</span> film_actor.film_id <span class="hljs-operator">=</span> film.id;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223459495.png" alt="image-20230228223459495"></p></li></ul></blockquote><blockquote><ul><li>ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者联合索引的部分前缀，索引要 和某个值相比较，可能会找到多个符合条件的行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;film1&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223509760.png" alt="image-20230228223509760"></p></blockquote><blockquote><ul><li>range：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;&#x3D; 等操作中。使用一个索引来检索给定范围的行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223520759.png" alt="image-20230228223520759"></p></blockquote><blockquote><ul><li>index：扫描全表索引，这通常比ALL快一些。即查询的字段都是索引列。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223531307.png" alt="image-20230228223531307"></p></blockquote><p>​</p><blockquote><ul><li>ALL：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223546942.png" alt="image-20230228223546942"></p></blockquote></li></ul><h3 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a><strong>possible_keys列</strong></h3><ul><li>这一列显示查询可能使用哪些索引来查找。 </li><li>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中 数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 </li><li>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</li></ul><h3 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h3><ul><li>这一列显示mysql实际采用哪个索引来优化对该表的访问。 </li><li>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索 引，在查询中使用 force index、ignore index。</li></ul><h3 id="key-len列"><a href="#key-len列" class="headerlink" title="key_len列"></a>key_len列</h3><ul><li>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </li><li>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成， 并且每个int是4字节。通过结果中的key_len&#x3D;4可推断出查询使用了第一个列：film_id列来执行索引查找。</li></ul><blockquote><p>key_len计算规则如下： </p><ul><li><p>字符串 </p><ul><li><p>char(n)：n字节长度</p></li><li><p>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n </p><p>+ 2</p></li></ul></li><li><p>数值类型</p><ul><li>tinyint：1字节 </li><li>smallint：2字节</li><li>int：4字节 </li><li>bigint：8字节</li></ul></li><li><p>时间类型</p><ul><li>date：3字节 </li><li>timestamp：4字节 </li><li>datetime：8字节</li></ul></li><li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p></li></ul></blockquote><h3 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a><strong>ref列</strong></h3><ul><li>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</li></ul><h3 id="rows列"><a href="#rows列" class="headerlink" title="rows列"></a><strong>rows列</strong></h3><ul><li>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</li></ul><h3 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a><strong>Extra列</strong></h3><p>这一列展示的是额外信息。常见的重要值如下： </p><ul><li><p>Using index：使用覆盖索引（覆盖索引指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。 ）</p></li><li><p>Using where：使用 where 语句来处理结果，查询的列未被索引覆盖</p></li><li><p>Using index condition：会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">where</span> film_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> name <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><ul><li>actor.name没有索引，此时创建了张临时表来distinct</li></ul></li><li><p>Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><ul><li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排 序name并检索行记录</li></ul></li><li><p>Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p> Extra 的介绍不是一定的，需要综合当时的场景考虑，不需要记住哪个场景使用的是哪个，只是需要当出现Using filesort, Using temporary：Using where：时，考虑需要优化。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Explain详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql索引介绍</title>
    <link href="/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="1-索引的本质"><a href="#1-索引的本质" class="headerlink" title="1. 索引的本质"></a>1. 索引的本质</h1><blockquote><p>索引是帮助Mysql高效获取数据的排好序的数据结构</p></blockquote><h1 id="2-索引的数据结构"><a href="#2-索引的数据结构" class="headerlink" title="2. 索引的数据结构"></a>2. 索引的数据结构</h1><h4 id="二叉树：单边增长的场景会导致全表扫描。"><a href="#二叉树：单边增长的场景会导致全表扫描。" class="headerlink" title="二叉树：单边增长的场景会导致全表扫描。"></a>二叉树：单边增长的场景会导致全表扫描。</h4><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230316043.png" alt="image-20230228230316043"></p><span id="more"></span><h4 id="红黑树：相对平衡，比二叉树性能好，大数据下，红黑树的高度过高，会造成磁盘IO频繁。"><a href="#红黑树：相对平衡，比二叉树性能好，大数据下，红黑树的高度过高，会造成磁盘IO频繁。" class="headerlink" title="红黑树：相对平衡，比二叉树性能好，大数据下，红黑树的高度过高，会造成磁盘IO频繁。"></a>红黑树：相对平衡，比二叉树性能好，大数据下，红黑树的高度过高，会造成磁盘IO频繁。</h4><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230321402.png" alt="image-20230228230321402"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>一次hash算法就可以定位到文件的位置，但存在缺点：</p><ul><li>不支持范围查找</li><li>不支持排序</li></ul><p>数据库如果比较大，只用到精确查找就可以用hash</p><h4 id="B-tree："><a href="#B-tree：" class="headerlink" title="B-tree："></a>B-tree：</h4><ol><li><strong>特点：</strong></li></ol><blockquote><ul><li>叶子结点具有相同的深度，叶子结点指针为空。</li><li>所有索引元素不重复</li><li>节点中的数据索引从左到右递增</li></ul></blockquote><ol start="2"><li>如果使用了innoDb存储引擎，结点的data元素就可能存储的是除了索引外的其他所有列，会占用比较大的存储空间，对于一个大结点而言，可以存放的结点数量就会比较小</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230329788.png" alt="image-20230228230329788"></p><h4 id="B-tree-B-tree变种"><a href="#B-tree-B-tree变种" class="headerlink" title="B+tree(B-tree变种)"></a>B+tree(B-tree变种)</h4><ol><li><p>特点：</p><blockquote><ul><li>非叶子结点不存储data ,只存储索引（冗余），可以存放更多的索引。</li><li>叶子结点包含所有的索引字段。</li><li>叶子结点用指针连接，提高区间访问的性能。</li></ul></blockquote><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230339454.png" alt="image-20230228230339454"></p></li></ol><p><strong>索引是怎么支持千万级表快速查找？</strong></p><p>mysql建议一个结点大小为16kb,这样一次iO速度比较快，一个大结点下的一个索引元素大约是14b，所以一个大结点里面约有1170个索引元素，对于一个高度为3的b+树，可以存储<code>16* 1170* 1170 </code>&#x3D; 2000万。</p><h1 id="4-存储引擎"><a href="#4-存储引擎" class="headerlink" title="4 存储引擎"></a>4 存储引擎</h1><p>存储引擎是对于表而言的，不同的表可以设置不同的存储引擎</p><h2 id="1-MyISAM索引实现-非聚集"><a href="#1-MyISAM索引实现-非聚集" class="headerlink" title="1 MyISAM索引实现(非聚集)"></a>1 MyISAM索引实现(非聚集)</h2><ul><li><p>MyISAM索引文件和数据文件是分离的</p></li><li><p>表结构文件是xxx.frm, 索引文件是xxx.MYI, 数据文件是xxx.MYD</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230349979.png" alt="image-20230228230349979"></p></li></ul><blockquote><p>执行流程：当有一条查询语句：where Col1 &#x3D; 49， 先判断有没有走索引，走索引的话，先根据49快速在MYI文件中定位到结点，获取该结点存储的索引所在行的磁盘文件指针0x90，再去MYD中定位数据。</p></blockquote><h2 id="2-InnoDb索引实现-聚集"><a href="#2-InnoDb索引实现-聚集" class="headerlink" title="2 InnoDb索引实现(聚集)"></a>2 InnoDb索引实现(聚集)</h2><ul><li><p>表数据文件本身就是按B+tree组织的一个索引文件</p></li><li><p>叶子结点包含了完整的数据记录，data里存储的是：索引所在行的其他所有数据</p></li><li><p>表结构文件是xxx.frm, 索引文件+ 数据文件 是xxx.ibd</p></li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230401564.png" alt="image-20230228230401564"></p><h1 id="5-常见面试题"><a href="#5-常见面试题" class="headerlink" title="5 常见面试题"></a>5 常见面试题</h1><h2 id="1-mysql-为什么使用B-树而不是B树"><a href="#1-mysql-为什么使用B-树而不是B树" class="headerlink" title="1. mysql 为什么使用B+树而不是B树"></a>1. mysql 为什么使用B+树而不是B树</h2><ol><li>更高的节点利用率</li></ol><p>B+树与B树的一个关键区别在于B+树的所有数据都存储在叶子节点，而非叶子节点只存储键值和指向子节点的指针。这样可以使非叶子节点包含更多的键值和指针，提高了节点的利用率，从而减少了树的高度。</p><ol start="2"><li>更高的查询效率</li></ol><p>由于B+树的叶子节点形成了一个链表，所有的实际数据都存储在叶子节点中，这使得范围查询和顺序遍历更加高效。可以很容易地通过顺序访问叶子节点来实现范围查询，而不需要回溯。</p><ol start="3"><li>更适合磁盘存储</li></ol><p>数据库系统通常需要处理大量的数据，这些数据大部分存储在磁盘上。B+树设计更加适合磁盘存储，因为它减少了树的高度，进而减少了磁盘I&#x2F;O操作的次数。每个节点可以存储更多的指针，从而降低了访问数据时需要读取的磁盘块数量。</p><ol start="4"><li>更稳定的查询性能</li></ol><p>在B+树中，所有实际数据都在叶子节点上，非叶子节点仅作为索引使用，这意味着所有的查找操作所需的路径长度相同。因此，B+树的查询性能更加稳定。</p><p><strong>具体比较：B树 vs B+树</strong></p><ul><li><p><strong>节点结构</strong>：</p><ul><li><strong>B树</strong>：每个节点既包含键值也包含数据。</li><li><strong>B+树</strong>：所有数据都存储在叶子节点，非叶子节点只包含键值和指针。</li></ul></li><li><p><strong>数据存储位置</strong>：</p><ul><li><strong>B树</strong>：数据存储在各个节点中。</li><li><strong>B+树</strong>：数据存储在叶子节点中，且叶子节点形成链表。</li></ul></li><li><p><strong>查询性能</strong>：</p><ul><li><strong>B树</strong>：查找过程中可能在不同深度找到数据。</li><li><strong>B+树</strong>：查找路径长度相同，查询性能更稳定。</li></ul></li><li><p><strong>范围查询</strong>：</p><ul><li><p><strong>B树</strong>：范围查询需要遍历多个节点，不如B+树高效。</p></li><li><p><strong>B+树</strong>：叶子节点形成链表，顺序遍历和范围查询非常高效。</p></li></ul></li></ul><h2 id="2-为什么InnoDb表要尽量设定一个主键"><a href="#2-为什么InnoDb表要尽量设定一个主键" class="headerlink" title="2 为什么InnoDb表要尽量设定一个主键"></a>2 为什么InnoDb表要尽量设定一个主键</h2><ul><li>innnoDb表数据文件本身就是按B+tree组织的一个索引文件</li><li>主键是数据库确保数据行在整张表唯一性的保障.</li><li>设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。 </li><li>如果没有主键，InnoDB会选择一个唯一键来作为聚簇索 引，如果没有唯一键，会生成一个隐式的主键。</li></ul><h2 id="3-主键使用整型的自增ID而不是UUID？"><a href="#3-主键使用整型的自增ID而不是UUID？" class="headerlink" title="3 主键使用整型的自增ID而不是UUID？"></a>3 主键使用整型的自增ID而不是UUID？</h2><ul><li>查找元素的时候会涉及到大量的数据比较，整型比字符串快</li><li>UUID占用的存储空间会大于整形</li><li>叶子结点是按顺序排列的，如果主键索 引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，在维护B+树的过程中，会造成非常多的数据插入，数据移动，然后导致产生很多的内 存碎片，进而造成插入性能的下降。</li></ul><h2 id="4-辅助索引（非主键索引）是什么"><a href="#4-辅助索引（非主键索引）是什么" class="headerlink" title="4 辅助索引（非主键索引）是什么"></a>4 辅助索引（非主键索引）是什么</h2><ul><li><p>叶子结点存储的是索引所在数据行的主键。</p></li><li><p>辅助索引访问数据总是需要二次查找，先遍历非主键索引再遍历主键索引</p></li></ul><h2 id="5-为什么非主键索引结构叶子结点存储的是主键值"><a href="#5-为什么非主键索引结构叶子结点存储的是主键值" class="headerlink" title="5 为什么非主键索引结构叶子结点存储的是主键值?"></a>5 为什么非主键索引结构叶子结点存储的是主键值?</h2><ul><li>一致性，完整的数据只在主键索引上维护一份就可以，不用考虑分布式的问题。</li><li>节省存储空间.</li></ul><h2 id="6-联合索引是什么"><a href="#6-联合索引是什么" class="headerlink" title="6 联合索引是什么"></a>6 联合索引是什么</h2><ul><li>5个单值索引，对应5棵B+树，联合索引就只需要一棵树，所以日常推荐使用联合索引而不是单值索引。</li><li>索引排序的时候会按照字段顺序，逐个去排序</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228230412331.png" alt="image-20230228230412331"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的7种工作模式</title>
    <link href="/RabbitMQ%E7%9A%847%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/RabbitMQ%E7%9A%847%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ的7种工作模式"><a href="#RabbitMQ的7种工作模式" class="headerlink" title="RabbitMQ的7种工作模式"></a><strong>RabbitMQ的7种工作模式</strong></h1><h2 id="1-simple模式"><a href="#1-simple模式" class="headerlink" title="1. simple模式"></a>1. simple模式</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223058625.png" alt="image-20230228223058625"></p><ul><li><p>最简单的收发模式。生产者发送一个消息到一个指定的queue，中间不需要任何exchange规则。消费者端通过queue方式进行消费。</p></li><li><p>代码</p><ul><li><p>producer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>String message = <span class="hljs-string">&quot;hello world&quot;</span>;<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure></li><li><p>consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-work工作模式-资源的竞争"><a href="#2-work工作模式-资源的竞争" class="headerlink" title="2. work工作模式(资源的竞争)"></a>2. work工作模式(资源的竞争)</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223108418.png" alt="image-20230228223108418"></p><ul><li><p>一个生产者，多个消费者。</p></li><li><p>consumer1, consumer2 同时监听同一 个队列,消息被消费。服务器根据负载方案决定把消息发给一个指定的consumer处理。work主要有两种模式：</p><blockquote><ul><li><strong>轮询分发</strong>：一个消费者消费一条，<strong>按均分配</strong>，woek模式下默认是采用轮询分发方式。比较简单，比如生产费者发送了6条消息到队列中，如果有3个消费者同时监听着这一个队列，那么这3个消费者每人就会分得2条消息。</li><li>公平分发<strong>：根据消费者的消费能力进行公平分发，处理得快的分得多，处理的慢的分得少，</strong>能者多劳。</li></ul></blockquote></li><li><p>隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用。</p></li></ul><h2 id="3-publish-x2F-subscribe发布订阅-共享资源"><a href="#3-publish-x2F-subscribe发布订阅-共享资源" class="headerlink" title="3. publish&#x2F;subscribe发布订阅(共享资源)"></a>3. publish&#x2F;subscribe发布订阅(共享资源)</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223121109.png"></p><ul><li><p>type为**”fanout”** 的exchange</p></li><li><p>每个消费者监听自己的队列； 生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。</p></li><li><p>代码</p><ul><li><p>producer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure></li><li><p>consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>);<br>channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>channel.queueBind(<span class="hljs-string">&quot;queue1&quot;</span>, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-Routing路由模式"><a href="#4-Routing路由模式" class="headerlink" title="4. Routing路由模式"></a><strong>4. Routing路由模式</strong></h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223131996.png" alt="image-20230228223131996"></p><ul><li><p>type为”<strong>direct</strong>” 的exchange</p></li><li><p>根据routing_key 进行匹配，生产者，发送消息的时候会制定routing_key，交换机根据routing_key，去匹配绑定改routing_key的队列,只能匹配上路由key对应 的消息队列,对应的消费者才能消费消息</p></li><li><p>代码</p><ul><li><p>producer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(DIRECT_EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br>channel.basicPublish(DIRECT_EXCHANGE_NAME, ROUTING_KEY, <span class="hljs-keyword">null</span>,message.getBytes(StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure></li><li><p>consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(DIRECT_EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br>channel.queueDeclare(DIRECT_QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>channel.queueBind(DIRECT_QUEUE_NAME, DIRECT_EXCHANGE_NAME, ROUTING_KEY);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5-topic-主题模式-路由模式的一种"><a href="#5-topic-主题模式-路由模式的一种" class="headerlink" title="5.topic 主题模式(路由模式的一种)"></a><strong>5.topic 主题模式(路由模式的一种)</strong></h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223142678.png"></p><ul><li><p>type为”<strong>topic</strong>“ 的exchange</p></li><li><p>交换机根据key的规则模糊匹配到对应的队列，由队列的监听消费者接收消息消费。类似sql的模糊匹配</p></li><li><p>* 代表一个具体的单词。# 代表0个或多个单词</p></li><li><p>代码</p><ul><li><p>producer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(TOPIC_EXCHANGE, BuiltinExchangeType.TOPIC);<br>String message = <span class="hljs-string">&quot;hello world topic!&quot;</span>;<br>channel.basicPublish(TOPIC_EXCHANGE, <span class="hljs-string">&quot;hello.info&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure></li><li><p>consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTING_KEY = <span class="hljs-string">&quot;*.info&quot;</span>;<br>channel.exchangeDeclare(TOPIC_EXCHANGE, BuiltinExchangeType.TOPIC);<br>channel.queueDeclare(TOPIC_QUEUE_1, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>channel.queueBind(TOPIC_QUEUE_1, TOPIC_EXCHANGE, ROUTING_KEY);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="6-RPC模式-路由模式的一种"><a href="#6-RPC模式-路由模式的一种" class="headerlink" title="6. RPC模式(路由模式的一种)"></a>6. RPC模式(路由模式的一种)</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223151956.png" alt="image-20230228223151956"></p><p>实现不同服务间的远程调用。 springCloud feign</p><h2 id="7-Publisher-Confirms-发送者消息确认"><a href="#7-Publisher-Confirms-发送者消息确认" class="headerlink" title="7. Publisher Confirms 发送者消息确认"></a>7. Publisher Confirms <strong>发送者消息确认</strong></h2><ul><li><p>这个模块就是通过给发送者提供一些确认机制，来保证这个消息发送的过程是成功的</p></li><li><p>发送者确认模式默认是不开启的，所以如果需要开启发送者确认模式，需要手动在channel中进行声明</p><p> <code>channel.confirmSelect() </code></p></li><li><p>在官网的示例中，重点解释了三种策略</p><ul><li><p><strong>1. 发布单条消息</strong></p><p>channel.waitForConfirmsOrDie(5_000);这个方法就会在channel端等待RabbitMQ给出一个响应，用来表明这个消息已经正确发送到了RabbitMQ服务端。但是要注意，这个方法会同步阻塞channel，在等待确认期间，channel将不能再继续发送消息，也就是说会明显降低集群的发送速度即吞吐量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (thereAreMessagesToPublish()) &#123;<br>    <span class="hljs-keyword">byte</span>[] body = ...;<br>    BasicProperties properties = ...;<br>    channel.basicPublish(exchange, queue, properties, body);<br>    <span class="hljs-comment">// uses a 5 second timeout</span><br>    channel.waitForConfirmsOrDie(<span class="hljs-number">5_000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>2. 发送批量消息</strong></p><p>之前单条确认的机制会对系统的吞吐量造成很大的影响，所以稍微中和一点的方式就是发送一批消息后，再一起确认。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> batchSize = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">int</span> outstandingMessageCount = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (thereAreMessagesToPublish()) &#123;<br>    <span class="hljs-keyword">byte</span>[] body = ...;<br>    BasicProperties properties = ...;<br>    channel.basicPublish(exchange, queue, properties, body);<br>    outstandingMessageCount++;<br>    <span class="hljs-keyword">if</span> (outstandingMessageCount == batchSize) &#123;<br>        channel.waitForConfirmsOrDie(<span class="hljs-number">5_000</span>);<br>        outstandingMessageCount = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (outstandingMessageCount &gt; <span class="hljs-number">0</span>) &#123;<br>    channel.waitForConfirmsOrDie(<span class="hljs-number">5_000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>3. 异步确认消息</strong></p><p>Producer在channel中注册监听器来对消息进行确认。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.addConfirmListener(ConfirmCallback var1, ConfirmCallback var2); <br></code></pre></td></tr></table></figure><p>发送者在发送完消息后，就会执行第一个监听器callback1，然后等服务端发过来的反馈后，再执行第二个监听器callback2</p></li></ul></li></ul><h2 id="常用的四种交换器："><a href="#常用的四种交换器：" class="headerlink" title="常用的四种交换器："></a>常用的四种交换器：</h2><ul><li><p>fanout：如果交换器收到消息，将会广播到所有绑定的队列上 </p></li><li><p>direct：如果路由键完全匹配，消息就被投递到相应的队列 </p></li><li><p>topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符， * 代表一个具体的单词。# 代表0个或多个单词</p></li><li><p>header: 不处理路由键，根据发送的消息内容中的headers属性进行匹配</p></li></ul><h2 id="消息的分发策略"><a href="#消息的分发策略" class="headerlink" title="消息的分发策略"></a>消息的分发策略</h2><ul><li><p>消息的分发策略</p><p>  假设队列里有100条消息，有 A,B,C   3个队列</p><ul><li>发布订阅。三个队列都收到100条</li><li>轮训分发。3个队列都是至少33条，剩下一条随机，不论你数据库性能怎么样，大家接受的都是公平的</li><li>公平分发。根据服务器性能，去分发，哪个性能高，哪个处理的消息可能就多，能者多劳，会造成数据倾斜</li><li>重发。发送消息中出现了异常后，消息没有得到应答，就会重发，kafka不支持</li><li>消息拉取。就是RPC去拉取数据</li></ul><blockquote><p>Rabbitmq以上集中策略都支持，且是开源的</p><p>kafka速度最快</p></blockquote></li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul><li>中间件<ul><li>是一种应用于分布式系统的基础软件。</li><li>常见的中间件：mysql，rabbit MQ</li></ul></li><li>怎么选择中间件<ul><li>可以通信，跨平台。比方两个项目一个java，一个go之间要通信，就要遵循同一种协议</li><li>高可用<ul><li>是否拥有持久化。比方中间件挂了，重启后是否可以把消息重新存储起来的能力</li><li>支持集群。系统cpu不够用了，就得搭集群</li></ul></li><li>有分发能力，多个系统，往那个系统去发送消息</li></ul></li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul><li><p>网络协议三要素：</p><ul><li>语法：用户数据的结构与形式，如：http中规定了请求和响应报文的格式</li><li>语义：规定了何种信息需要对应发出何种响应，如：请求get要把参数放在url中，post把参数放在body中</li><li>时序：事件的执行顺序，如：先有请求后有响应</li></ul></li><li><p>为什么消息中间件不用http？</p><ul><li>http的请求和响应报文比较复杂，有cookie, 状态码，响应码这些，但消息中间件：只需要接受消息，存储消息，分发消息，不需要这么复杂</li><li>http大部分是短链接，不利于出现故障时消息持久化</li></ul></li><li><p>AMQP（advanced message. Queuing protocol） 高级消息队列协议</p><ul><li>采用Erlang，底层是C，速度很快</li><li>特性<ul><li>支持分布式事务</li><li>消息持久化</li><li>高性能高可靠的消息处理优势</li></ul></li></ul></li><li><p>kafka 协议</p><ul><li>基于TCP&#x2F;IP的二进制协议，消息内部由长度分割，由基本数据类型构成</li><li>特性<ul><li>结构简单</li><li>解析速度快</li><li>消息持久化</li><li>不支持事务</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秒杀模块学习</title>
    <link href="/%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="秒杀模块"><a href="#秒杀模块" class="headerlink" title="秒杀模块"></a>秒杀模块</h1><h2 id="1-秒杀接口优化"><a href="#1-秒杀接口优化" class="headerlink" title="1. 秒杀接口优化"></a>1. 秒杀接口优化</h2><ul><li>用户是否登陆</li><li>判断库存（备份在redis中一份）<ul><li>在初始化contoller接口的时候，就把商品id和对应的库存数存入到redis</li></ul></li><li>判断是否已经秒杀到了</li><li>减缓存， 下订单（订单和秒杀订单）<ul><li>队列里面存的消息message，有两个变量用户和商品id,</li><li>receiver监听该队列，减库存，减库存成功了，根据用户和商品id,下订单</li><li>contoller需要的就是给队列发消息，最终给前端返回一个状态值（排队中）</li></ul></li></ul><span id="more"></span><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn32zi2y7j30o40n0wfo.jpg" style="zoom: 67%;" /><ul><li>前端轮询：是否生成了订单<ul><li>查询该笔订单是否存在<ul><li>存在，生成订单</li><li>不存在，查看商品是否已经秒杀完了：<ul><li>没秒杀完，就是排队中</li><li>完了，就返回该商品已经卖完了，并且在缓存中记录下该商品已经售罄了。goods_over+goodsId, true</li></ul></li></ul></li></ul></li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3541p3cj30qk0hkq4d.jpg" style="zoom:50%;" /><h2 id="2-秒杀接口地址隐藏"><a href="#2-秒杀接口地址隐藏" class="headerlink" title="2. 秒杀接口地址隐藏:"></a>2. 秒杀接口地址隐藏:</h2><p>针对不同的用户，生成不同的秒杀地址，即秒杀地址上带一个参数，参数根据当前【用户id，商品id】随机生成，并保存在redis中，做秒杀的时候，先检查该参数是否匹配，只有匹配了才可以进行秒杀，不匹配是非法请求。</p><h2 id="3-验证码生成"><a href="#3-验证码生成" class="headerlink" title="3. 验证码生成"></a>3. 验证码生成</h2><p>点击秒杀之前，先让用户输入验证码。有2个目的：</p><ul><li>防止机器人</li><li>用户输入验证码结果时间不同，因此分散用户的请求。</li></ul><p>实现：</p><ul><li>生成秒杀验证码，放在redis中</li><li>在秒杀的时候，先验证验证码，验证成功，删除ke y</li></ul><h2 id="4-接口限流防刷"><a href="#4-接口限流防刷" class="headerlink" title="4. 接口限流防刷"></a>4. 接口限流防刷</h2><p>思路：</p><p>把每个用户访问接口的次数写入到缓存中，并设置失效时长s，因为可能每个方法设置的参数可能不同，所以可以通过注解+拦截器实现。</p><p>实现在 <strong>Controller</strong> 处理请求之前 先判断是否已经超过了设置的最大访问次数。</p><p>具体实现：</p><p>Step1: 在需要防刷的方法上加注解annotation，注解里设置两个参数时间seconds和最大访问次数maxCount</p><p>Step2: 添加拦截器(Interceptor)，在拦截器里先判断该方法上是否加了对应注解</p><p>Step3: 通过request中取得的method uri, 用户id 可以得到当前用户访问的该方法的次数</p><p>step4: 将该次数和注解里存的最大访问次数进行比较，看是否已经超过了限制的最大次数</p><p>Step5: redis中存放的key设置最大过期时间为注解的时间</p><p>Step5: 注册该拦截器</p><h2 id="5-分布式session"><a href="#5-分布式session" class="headerlink" title="5. 分布式session"></a>5. 分布式session</h2><p>用户登陆成功后，给用户生成一个session_id标识这个用户，写在客户端cookie中，客户端访问服务器的时候会带上cookie，服务端在处理的时候，会从cookie中解码出session_id，从而取到用户信息。</p><hr/><h2 id="为什么要使用分布式Session"><a href="#为什么要使用分布式Session" class="headerlink" title="为什么要使用分布式Session"></a>为什么要使用分布式Session</h2><p>Web应用在单机部署的情况下，Session是被单个应用服务器存储管理的，由于只有一个应用服务器，用户的所有请求都是通过它进行响应处理的，所以能够很容易实现会话跟踪和保持。随着业务量的增长，系统架构需要做出调整以适应发展的需要，可能会使用分布式架构或微服务架构，无论使用哪种架构方式，应用系统单机部署的模式已经不能满足需求，所以会将应用系统部署到多台应用服务器上，用户的请求也会通过负载均衡转发到某个具体应用服务器上执行，可能会出现在A1系统登录后创建并保存Session，再次发起请求，请求被转发到A2系统上显示未登录的情况，此时单机部署模式下的Session机制已不能满足要求。所以，在分布式架构或微服务架构下，必须保证一个应用服务器上保存Session后，其它应用服务器可以同步或共享这个Session。</p><h2 id="分布式session管理实现方案"><a href="#分布式session管理实现方案" class="headerlink" title="分布式session管理实现方案"></a>分布式session管理实现方案</h2><p>分布式Session有如下几种实现方式。</p><h2 id="1-Session复制"><a href="#1-Session复制" class="headerlink" title="1.Session复制"></a>1.Session复制</h2><p>在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。<br>优点：代码上不需要做支持和修改。<br>缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。<br>适用场景：只适用于Web服务器比较少且Session数据量少的情况。<br>可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。</p><h2 id="2-Session粘滞"><a href="#2-Session粘滞" class="headerlink" title="2.Session粘滞"></a>2.Session粘滞</h2><p>将用户的每次请求都通过某种方法强制分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。<br>优点：使用简单，没有额外开销。<br>缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。<br>适用场景：对稳定性要求不是很高的业务情景。</p><h2 id="3-Session集中管理"><a href="#3-Session集中管理" class="headerlink" title="3.Session集中管理"></a>3.Session集中管理</h2><p>在单独的服务器或服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。<br>优点：可靠性高，减少Web服务器的资源开销。<br>缺点：实现上有些复杂，配置较多。<br>适用场景：Web服务器较多、要求高可用性的情况。<br>可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法，博主也动手写了一个，github搜索joincat用户，然后自取。</p><h2 id="4-基于Cookie管理"><a href="#4-基于Cookie管理" class="headerlink" title="4.基于Cookie管理"></a>4.基于Cookie管理</h2><p>这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。<br>优点：不需要依赖额外外部存储，不需要额外配置。<br>缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。<br>适用场景：数据不重要、不敏感且数据量小的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这四种方式，相对来说，Session集s管理更加可靠，使用也是最多的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Spock框架编写测试代码</title>
    <link href="/%E4%BD%BF%E7%94%A8Spock%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/"/>
    <url>/%E4%BD%BF%E7%94%A8Spock%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Spock-介绍"><a href="#Spock-介绍" class="headerlink" title="Spock 介绍"></a>Spock 介绍</h2><blockquote><ul><li><p>Spock是一个为groovy和java语言应用程序来测试和规范的框架。</p></li><li><p>这个框架的突出点在于它美妙和高效表达规范的语言。</p></li><li><p>得益于JUnit runner，Spock能够在大多数IDE、编译工具、持续集成服务下工作。</p></li><li><p>Spock的灵感源于JUnit,jMock, RSpec, Groovy, Scala, Vulcans以及其他优秀的框架形态。</p></li></ul></blockquote><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>a simple assertion</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be a simple assertion&quot;</span>() &#123;<br>    <span class="hljs-symbol">expect:</span><br>    <span class="hljs-number">1</span> == <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><ul><li>given when then 使用</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should demo given-when-then&quot;</span>()&#123;<br>     <span class="hljs-symbol">given:</span><br>     <span class="hljs-keyword">def</span> user = <span class="hljs-keyword">new</span> Polygon(<span class="hljs-number">10</span>)<br><br>     <span class="hljs-symbol">when:</span><br>     <span class="hljs-keyword">int</span> age = user.numberOfSides<br><br>     <span class="hljs-symbol">then:</span><br>     age == <span class="hljs-number">10</span><br> &#125;<br></code></pre></td></tr></table></figure><ul><li>expecting exceptions</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should expect exceptions&quot;</span>()&#123;<br>     <span class="hljs-symbol">when:</span><br>     <span class="hljs-keyword">new</span> Polygon(<span class="hljs-number">0</span>)<br><br>     <span class="hljs-symbol">then:</span><br>     thrown(TooFewSidesException)<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>data pipes.     where设置所有期望值</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should expect an exception to be throw for a number of invalid inputs&quot;</span>()&#123;<br>       <span class="hljs-symbol">when:</span><br>       <span class="hljs-keyword">new</span> Polygon(sides)<br><br>       <span class="hljs-symbol">then:</span><br>       thrown(TooFewSidesException)<br><br>       <span class="hljs-comment">//The where block says &quot;run this test with each of the following values: a negative value, zero, one and two&quot;.</span><br>       <span class="hljs-comment">// where设置所有期望值</span><br>       <span class="hljs-symbol">where:</span><br>       sides &lt;&lt; [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be able to create polygon with valid inputs&quot;</span>()&#123;<br>      <span class="hljs-symbol">expect:</span><br>      <span class="hljs-keyword">new</span> Polygon(sides).numberOfSides == sides<br><br>      <span class="hljs-comment">//The where block says &quot;run this test with each of the following values: a negative value, zero, one and two&quot;.</span><br>      <span class="hljs-symbol">where:</span><br>      sides &lt;&lt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>data tables</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use data tables for calculating max&quot;</span>()&#123;<br>      <span class="hljs-comment">// 如果我们只有一条语句设置了测试和断言，我们可以直接使用`expect`标签</span><br>      <span class="hljs-symbol">expect:</span><br>      Math.max(a,b) == max<br><br>      <span class="hljs-symbol">where:</span><br>      a | b | max<br>      <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">2</span><br>      <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">4</span><br>      <span class="hljs-number">5</span> | <span class="hljs-number">9</span> | <span class="hljs-number">9</span><br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>mocks 模拟出类或API来声明预期的行为</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be able to mock a specific class&quot;</span>() &#123;<br>        <span class="hljs-symbol">given:</span><br>        Renderer renderer = Mock()<br><br>        <span class="hljs-comment">//@Subject只是为了标记我们正在测试的对象，对代码没有任何影响</span><br>        <span class="hljs-meta">@Subject</span><br>        <span class="hljs-keyword">def</span> ploygon = <span class="hljs-keyword">new</span> Polygon(<span class="hljs-number">4</span>, renderer)<br><br>        <span class="hljs-symbol">when:</span><br>        ploygon.draw()<br><br>        <span class="hljs-symbol">then:</span><br>        <span class="hljs-number">4</span> * renderer.drawLine()<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>stubs 在测试的代码里提供数据或者值</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be able to create a stubs&quot;</span>() &#123;<br>       <span class="hljs-symbol">given:</span><br>       Palette palette = Stub()<br>       palette.getPrimaryColor() &gt;&gt; Color.red<br><br>       <span class="hljs-keyword">def</span> renderer =  <span class="hljs-keyword">new</span> Renderer(palette)<br><br>       <span class="hljs-symbol">expect:</span><br>       renderer.getForeGroundColor() == Color.red<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>help methods</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use a helper methods&quot;</span>() &#123;<br>    <span class="hljs-symbol">given:</span><br>    Renderer renderer = Mock()<br>    <span class="hljs-keyword">def</span> shapeFactory = <span class="hljs-keyword">new</span> ShapeFactory(renderer)<br><br>    <span class="hljs-symbol">when:</span><br>    <span class="hljs-keyword">def</span> polygon = shapeFactory.createDefaultPolygon()<br><br>    <span class="hljs-symbol">then:</span><br>    checkDefaultShape(polygon, renderer)<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-keyword">void</span> checkDefaultShape(Polygon polygon, Renderer renderer) &#123;<br>    <span class="hljs-keyword">assert</span> polygon.numberOfSides == <span class="hljs-number">4</span><br>    <span class="hljs-keyword">assert</span> renderer == renderer<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>with 测试但个对象的多个属性</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use #with()&quot;</span>() &#123;<br>        <span class="hljs-symbol">given:</span><br>        Renderer renderer = Mock()<br>        <span class="hljs-keyword">def</span> shapeFactory = <span class="hljs-keyword">new</span> ShapeFactory(renderer)<br><br>        <span class="hljs-symbol">when:</span><br>        <span class="hljs-keyword">def</span> polygon = shapeFactory.createDefaultPolygon()<br><br>        <span class="hljs-symbol">then:</span><br>        with(polygon)&#123;<br>            numberOfSides == <span class="hljs-number">4</span><br>            renderer == render<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>verifyAll() 确保所有断言都在执行，而不管其中之一是否失败了。</p><p>当使用with时，第一行测试失败了，第二行测试就不会执行了，而verifyAll 会运行所有行测试</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use #verifyAll()&quot;</span>() &#123;<br>       <span class="hljs-symbol">given:</span><br>       Renderer renderer = Mock()<br>       <span class="hljs-keyword">def</span> shapeFactory = <span class="hljs-keyword">new</span> ShapeFactory(renderer)<br><br>       <span class="hljs-symbol">when:</span><br>       <span class="hljs-keyword">def</span> polygon = shapeFactory.createDefaultPolygon()<br><br>       <span class="hljs-symbol">then:</span><br>       verifyAll(polygon)&#123;<br>           numberOfSides == <span class="hljs-number">5</span><br>           renderer == <span class="hljs-literal">null</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p>setup-and-teardown</p><ul><li>setupSpec():  在规范的开始设置状态一次，这是为了在各个测试方法之间不应该改变的东西</li><li>setup(): 将在该类中的每个单独测试方法之前运行。这可用于在每次测试开始时设置干净状态。</li><li>cleanup(): 在每个测试方法结束时清理数据或状态</li><li>cleanupSpec() :  对于最终的分解代码，该方法将在运行所有测试的最后调用一次。</li></ul></li><li><p>and可以增加多个使代码根据可读性：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">given: <span class="hljs-string">&quot;test method&quot;</span><br><span class="hljs-regexp">//</span> code ....<br><br>and: <span class="hljs-string">&quot;test method with user1&quot;</span><br><span class="hljs-regexp">//</span> code ...<br><br>and: <span class="hljs-string">&quot;test method with user2&quot;</span><br><span class="hljs-regexp">//</span> code ...<br></code></pre></td></tr></table></figure></li></ul><p>​</p>]]></content>
    
    
    <categories>
      
      <category>测试框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kotlin基础</title>
    <link href="/kotlin%E5%AD%A6%E4%B9%A0/"/>
    <url>/kotlin%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Kotlin-是什么？"><a href="#1-Kotlin-是什么？" class="headerlink" title="1.Kotlin 是什么？"></a>1.Kotlin 是什么？</h2><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。</p><p>在Google I&#x2F;O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p><h2 id="2-为什么选择-Kotlin？"><a href="#2-为什么选择-Kotlin？" class="headerlink" title="2.为什么选择 Kotlin？"></a>2.为什么选择 Kotlin？</h2><ul><li>简洁: 大大减少样板代码的数量。</li><li>安全: 避免空指针异常等整个类的错误。</li><li>互操作性: 充分利用 JVM、Android 和浏览器的现有库。</li><li>工具友好: 可用任何 Java IDE 或者使用命令行构建。</li></ul><span id="more"></span><h2 id="3-我的第一个-Kotlin-程序"><a href="#3-我的第一个-Kotlin-程序" class="headerlink" title="3.我的第一个 Kotlin 程序"></a>3.我的第一个 Kotlin 程序</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hello word!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Kotlin 程序文件以 <strong>.kt</strong> 结尾，如：hello.kt 、app.kt。</p></blockquote><h2 id="4-基础语法"><a href="#4-基础语法" class="headerlink" title="4.基础语法"></a>4.基础语法</h2><ul><li>函数定义</li></ul><p>格式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> 方法名<span class="hljs-params">(参数A : 类型<span class="hljs-type">A</span>, 参数B : 类型<span class="hljs-type">B</span>)</span></span>: 返回值类型(可以为空) &#123;<br>   函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;   <span class="hljs-comment">// Int 参数，返回值 Int</span><br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> result = add(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br>    println(result)<br>&#125;<br><br><span class="hljs-comment">//fun add(x: Int, y: Int): Int &#123;</span><br><span class="hljs-comment">//  return x+ y</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = x+ y<br></code></pre></td></tr></table></figure><ul><li>可变长参数</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">vars</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> v:<span class="hljs-type">Int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(vt <span class="hljs-keyword">in</span> v)&#123;<br>        print(vt)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    vars(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出12345</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认参数和具名参数</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calThePerimeterOfCircle</span><span class="hljs-params">(pi: <span class="hljs-type">Float</span> = Pi, r: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>* pi * r<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;圆的周长为：<span class="hljs-subst">$&#123;calThePerimeterOfCircle(r = <span class="hljs-number">2.0</span>f)&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数表达式</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> i = &#123;x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x+ y&#125;<br>    println(i(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>))<br><br>    <span class="hljs-comment">// 输入类型是两个int ，返回值是int，输入参数为x,y 表达式为x+y</span><br>    <span class="hljs-keyword">var</span> j:(<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123;x,y -&gt; x+y&#125;<br>    println(i(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>条件控制 if</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">returnBigValue</span><span class="hljs-params">(a:<span class="hljs-type">Int</span>,b:<span class="hljs-type">Int</span>)</span></span>:<span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (a&gt;b) a <span class="hljs-keyword">else</span> b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a= <span class="hljs-number">3</span><br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">5</span><br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;a&#125;</span>和<span class="hljs-subst">$&#123;b&#125;</span>中较大的数是<span class="hljs-subst">$&#123;returnBigValue(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>When 表达式</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">gradeStudent</span><span class="hljs-params">(score:<span class="hljs-type">Int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">when</span>(score)&#123;<br>        <span class="hljs-number">10</span> -&gt; println(<span class="hljs-string">&quot;优秀！&quot;</span>)<br>        <span class="hljs-number">1</span> -&gt; println(<span class="hljs-string">&quot;差劲！&quot;</span>)<br>        <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;努力努力！&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(gradeStudent(<span class="hljs-number">9</span>))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>list</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> items = listOf&lt;String&gt;(<span class="hljs-string">&quot;语文&quot;</span>,<span class="hljs-string">&quot;数学&quot;</span>,<span class="hljs-string">&quot;英语&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> items)&#123;<br>        println(<span class="hljs-string">&quot;科目有：<span class="hljs-subst">$&#123;i&#125;</span>&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> ((i,index) <span class="hljs-keyword">in</span> items.withIndex())&#123;<br>        println(<span class="hljs-string">&quot;科目为：<span class="hljs-subst">$&#123;i&#125;</span>，序号为<span class="hljs-subst">$&#123;index&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>map</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> map = TreeMap&lt;String,String&gt;()<br>    map[<span class="hljs-string">&quot;好&quot;</span>] = <span class="hljs-string">&quot;good&quot;</span><br>    map[<span class="hljs-string">&quot;坏&quot;</span>] = <span class="hljs-string">&quot;bad&quot;</span><br>    println(map[<span class="hljs-string">&quot;好&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>字符串和数字的转换</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;string&quot;</span><br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span><br>    println(<span class="hljs-string">&quot;字符串转数字：<span class="hljs-subst">$&#123;a.toString()&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;数字转字符串：<span class="hljs-subst">$&#123;b.toInt()&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>控制台输入变量</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;请输入第一个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str1 = readLine()<br>    println(<span class="hljs-string">&quot;请输入第二个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str2 = readLine()<br><br>    <span class="hljs-keyword">var</span> num1 = str1!!.toInt()<br>    <span class="hljs-keyword">var</span> num2 = str2!!.toInt()<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;num1&#125;</span>+<span class="hljs-subst">$&#123;num2&#125;</span>=<span class="hljs-subst">$&#123;num1+num2&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>处理异常-&gt; try…catch()</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;请输入第一个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str1 = readLine()<br>    println(<span class="hljs-string">&quot;请输入第二个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str2 = readLine()<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">var</span> num1 = str1!!.toInt()<br>        <span class="hljs-keyword">var</span> num2 = str2!!.toInt()<br>        println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;num1&#125;</span>+<span class="hljs-subst">$&#123;num2&#125;</span>=<span class="hljs-subst">$&#123;num1+num2&#125;</span>&quot;</span>)<br>    &#125;<span class="hljs-keyword">catch</span> (e: Exception)&#123;<br>        println(<span class="hljs-string">&quot;输入的数据有误！&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>字符串模板</p><p>$ 表示一个变量名或者变量值</p><p>$varName 表示变量值</p><p>${varName.fun()} 表示变量的方法返回值:</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 模板中的简单名称：</span><br>    <span class="hljs-keyword">val</span> s1 = <span class="hljs-string">&quot;a is <span class="hljs-variable">$a</span>&quot;</span><br><br>    a = <span class="hljs-number">2</span><br><span class="hljs-comment">// 模板中的任意表达式：</span><br>    <span class="hljs-keyword">val</span> s2 = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;s1.replace(<span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;was&quot;</span>)&#125;</span>, but now is <span class="hljs-variable">$a</span>&quot;</span><br>    println(s2)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>空值处理</p><p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式。</p><ul><li><p>字段后加!!像Java一样抛出空异常</p></li><li><p>字段后加?可不做处理返回值为 null或配合?:做空判断处理</p></li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//类型后面加?表示可为空</span><br><span class="hljs-keyword">var</span> age: String? = <span class="hljs-string">&quot;23&quot;</span> <br><span class="hljs-comment">//抛出空指针异常</span><br><span class="hljs-keyword">val</span> ages = age!!.toInt()<br><span class="hljs-comment">//不做处理返回 null</span><br><span class="hljs-keyword">val</span> ages1 = age?.toInt()<br><span class="hljs-comment">//age为空返回-1</span><br><span class="hljs-keyword">val</span> ages2 = age?.toInt() ?: -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="5-类"><a href="#5-类" class="headerlink" title="5.类"></a>5.类</h2><h3 id="5-1-类的创建"><a href="#5-1-类的创建" class="headerlink" title="5.1 类的创建"></a>5.1 类的创建</h3><p>Kotlin 中没有 new 关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangular</span></span>&#123;<br>    <span class="hljs-keyword">var</span> width:<span class="hljs-built_in">Int</span> = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">var</span> height:<span class="hljs-built_in">Int</span> = <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> rectangular = Rectangular()<br>    println(rectangular.height)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-枚举类"><a href="#5-2-枚举类" class="headerlink" title="5.2 枚举类"></a>5.2 枚举类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span>&#123;<br>    RED,BLACK,BLUE,GREEN,WHITE<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Kotlin-继承"><a href="#6-Kotlin-继承" class="headerlink" title="6. Kotlin 继承"></a>6. Kotlin 继承</h3><p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span> // 从 <span class="hljs-symbol">Any</span> 隐式继承<br></code></pre></td></tr></table></figure><p>Any 默认提供了三个函数：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">equals</span><span class="hljs-params">()</span></span><br><br><span class="hljs-function"><span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br><br><span class="hljs-function"><span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>注意：Any 不是 java.lang.Object。</p><p>如果一个类要被继承，可以使用 open 关键字进行修饰。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">open <span class="hljs-keyword">class</span> <span class="hljs-symbol">Base</span>(<span class="hljs-symbol">p: <span class="hljs-symbol">Int</span></span>)           // 定义基类<br><br><span class="hljs-symbol">class</span> <span class="hljs-symbol">Derived</span>(<span class="hljs-symbol">p: <span class="hljs-symbol">Int</span></span>) : <span class="hljs-symbol">Base</span>(<span class="hljs-symbol">p</span>)<br></code></pre></td></tr></table></figure><h1 id="7-Kotlin-接口"><a href="#7-Kotlin-接口" class="headerlink" title="7.Kotlin 接口"></a>7.Kotlin 接口</h1><p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>    <span class="hljs-comment">// 未实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">//已实现</span><br>      <span class="hljs-comment">// 可选的方法体</span><br>      println(<span class="hljs-string">&quot;foo&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> : <span class="hljs-type">MyInterface1</span>,<span class="hljs-type">MyInterface2 &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar1</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 方法体</span><br>    &#125;<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot整合graphql</title>
    <link href="/springboot%E6%95%B4%E5%90%88graphql/"/>
    <url>/springboot%E6%95%B4%E5%90%88graphql/</url>
    
    <content type="html"><![CDATA[<p>GraphQL是比REST更高效、强大和灵活的<strong>新一代API标准</strong>。详细的可以看官网<a href="https://graphql.cn/">GraphQL</a>。</p><p>下面介绍一个Spring boot整合graphql简单的例子。</p><span id="more"></span><ul><li><p>项目准备：相关依赖的引入：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">&lt;dependencies&gt;</span><br><span class="hljs-meta">&lt;!--web</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-meta">&lt;!--lombok</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-meta">&lt;!--graphql</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;version&gt;11.0.0&lt;/version&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-meta">&lt;!--playground</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;playground-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;version&gt;11.0.0&lt;/version&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-attr">&lt;/dependencies&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><ul><li><p>定义schema，分别为：</p><p><code>query.graphqls</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">type Query&#123;<br>  billingAccount(id: ID): BillingAccount<br>&#125;<br></code></pre></td></tr></table></figure><p><code>billingAccount.graphqls</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">type BillingAccount &#123;<br>  id: ID!<br>  name: String!<br>  currency: Currency<br>&#125;<br></code></pre></td></tr></table></figure><p><code>currency.graphqls</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Currency</span></span>&#123;<br>    RMB,<br>    USD<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义基础要操作的模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@Value</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingAccount</span> </span>&#123;<br>    UUID id;<br>    String name;<br>    Currency currency;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Currency</span> </span>&#123;<br>    RMB, USD<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义resolver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingAccountResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GraphQLQueryResolver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BillingAccount <span class="hljs-title">billingAccount</span><span class="hljs-params">(UUID id)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;receive billingAccount id is: &quot;</span>+ id);<br>        <span class="hljs-keyword">return</span> BillingAccount.builder()<br>                .id(id)<br>                .currency(Currency.RMB)<br>                .name(<span class="hljs-string">&quot;张三&quot;</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>效果图</p></li></ul><p><img src="/images/resolver.png" alt="img"></p><h4 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h4><ul><li>定义schema</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Mutation</span>&#123;<br>    createBillingAccount(input: <span class="hljs-type">CreateBillingAccountInput</span>): <span class="hljs-type">BillingAccount</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义input</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span> CreateBillingAccountInput&#123;<br>    name: String<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义input 对应的model</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateBillingAccountInput</span> </span>&#123;<br>  String name;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义mutationResolver</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingAccountMutation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GraphQLMutationResolver</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> BillingAccount <span class="hljs-title">createBillingAccount</span><span class="hljs-params">(CreateBillingAccountInput input)</span></span>&#123;<br><br>    <span class="hljs-keyword">return</span> BillingAccount.builder()<br>      .id(UUID.randomUUID())<br>      .currency(Currency.RMB)<br>      .name(input.getName())<br>      .build();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图</p><p>!<img src="/images/mutation.png" alt="mutation"></p>]]></content>
    
    
    <categories>
      
      <category>Springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>响应式编程</title>
    <link href="/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>1.响应式编程是什么？</strong></p><ul><li><p>响应式编程（<strong>reactive programming</strong>）是一种基于数据流和变化传递的声明式的编程范式</p><p>本来数据是我们自行处理的，后来我们把要处理的数据抽象出来（变成了数据流），然后通过<strong>API</strong>去处理数据流中的数据（是声明式的,如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum2 = IntStream.of(nums).parallel().sum();<br></code></pre></td></tr></table></figure></li></ul><p>​      将数组中的数据变成数据流，通过显式声明调用**.sum()**来处理数据流中的数据，得到最终的结果。</p><ul><li><p>响应式编程是关于非阻塞应用程序的，这些应用程序是异步的、事件驱动的，并且需要少量的线程来垂直伸缩(即在 JVM 中)，而不是水平伸缩(即通过集群)。</p><blockquote><p>工作太多，做不完时，水平伸缩就相当于加人，垂直伸缩相当于加班。</p></blockquote></li></ul><h3 id="2-响应式流（Reactive-Streams）-是什么"><a href="#2-响应式流（Reactive-Streams）-是什么" class="headerlink" title="2.响应式流（Reactive Streams） 是什么?"></a>2.响应式流（Reactive Streams） 是什么?</h3><span id="more"></span><ul><li><p>响应式流是JDK9引入的，基于发布-订阅者模式的一套数据处理的机制。</p></li><li><p>响应式流从2013年开始，作为提供非阻塞背压的异步流处理标准的倡议。 它旨在解决处理元素流的问题——如何将元素流从发布者传递到订阅者，而不需要发布者阻塞，或订阅者有无限制的缓冲区或丢弃。</p></li></ul><blockquote><p>背压：说白了就是一种反馈，发布者和订阅者之间的一种互动</p></blockquote><blockquote><p>之前的老模式，订阅者很被动，发布者给订阅者多少他就消费多少，不能多也不能多少。</p><p>Reactive Streams就可以做到发布者和订阅者之间可以进行交流，订阅者可以告诉发布者我需要多少数据，订阅者处理完了，可以再向发布者要，没处理完就不要给我。</p><p>起到了一种调节流量的作用，不会导致发布者数据太多，订阅者处理不完浪费，或者直接把订阅者压垮的场景。</p></blockquote><h3 id="2-Spring-Webflux-是什么？"><a href="#2-Spring-Webflux-是什么？" class="headerlink" title="2. Spring Webflux 是什么？"></a>2. Spring Webflux 是什么？</h3><p>Spring WebFlux是<a href="https://rumenz.com/java-topic/spring-mvc-tutorial/index.html">Spring MVC</a>并行版本，并支持完全无阻塞的反应流的web框架。 它支持背压概念，可以处理大量的并发连接，并使用**<a href="https://netty.io/">Netty</a>**作为内置服务器来运行响应式应用程序。 </p><h3 id="3-Spring-Webflux-和Spring-mvc-的关系"><a href="#3-Spring-Webflux-和Spring-mvc-的关系" class="headerlink" title="3.Spring Webflux 和Spring mvc 的关系"></a>3.Spring Webflux 和Spring mvc 的关系</h3><img src="https://spring.io/images/diagram-reactive-1290533f3f01ec9c57baf2cc9ea9fa2f.svg" style="zoom: 25%;" /><p>Spring MVC</p><ul><li>构建于 Servlet API 之上</li><li>同步阻塞 I&#x2F;O 模型, 认为应用会阻塞当前线程，所以一个 Request 对应一个 Thread，需要有一个含有大量线程的线程池</li></ul><p>Spring WebFlux</p><ul><li>构建于 Reactive Streams Adapters 之上</li><li>异步非阻塞 I&#x2F;O 模型，认为应用不会阻塞当前线程，所以只是需要一个包含少数固定线程数的线程池 (event loop workers) 来处理请求</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性之Stream流</title>
    <link href="/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81/"/>
    <url>/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="Java8新特性之Stream流"><a href="#Java8新特性之Stream流" class="headerlink" title="Java8新特性之Stream流"></a>Java8新特性之Stream流</h3><h3 id="1-什么是Stream？"><a href="#1-什么是Stream？" class="headerlink" title="1.什么是Stream？"></a>1.什么是Stream？</h3><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。通过声明性方式，能够对集合中的每个元素进行一系列并行或串行的流水线操作。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] numbers = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">int</span> num2 = IntStream.of(numbers).sum();<br>        System.out.println(num2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-创建流的几种方式"><a href="#2-创建流的几种方式" class="headerlink" title="2.创建流的几种方式"></a>2.创建流的几种方式</h3><span id="more"></span><h4 id="2-1-使用集合"><a href="#2-1-使用集合" class="headerlink" title="2.1 使用集合"></a>2.1 使用集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList arrayList = <span class="hljs-keyword">new</span> ArrayList();<br>arrayList.stream();<br>arrayList.parallelStream();  <br></code></pre></td></tr></table></figure><h4 id="2-2-使用数组"><a href="#2-2-使用数组" class="headerlink" title="2.2 使用数组"></a>2.2 使用数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><h4 id="2-3-数字Stream"><a href="#2-3-数字Stream" class="headerlink" title="2.3 数字Stream"></a>2.3 数字Stream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>IntStream.rangeClosed(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h4 id="2-4-使用Stream-generate"><a href="#2-4-使用Stream-generate" class="headerlink" title="2.4 使用Stream.generate()"></a>2.4 使用Stream.generate()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.generate(()-&gt; <span class="hljs-string">&quot;stream&quot;</span>).limit(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h3><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p><blockquote><ul><li>延迟方法：返回值任然是Stream接口自身类型的方法，因此支持链式调用(除了终结方法外，其他都是方法均为延迟方法)</li><li>终结方法：返回值类型不再是Stream接口自身类型的方法。</li></ul></blockquote><h4 id="3-1-延迟方法"><a href="#3-1-延迟方法" class="headerlink" title="3.1 延迟方法"></a>3.1 延迟方法</h4><h5 id="1-filter"><a href="#1-filter" class="headerlink" title="1. filter"></a>1. filter</h5><p>可以通过<code>filter</code>方法将一个流转换成另一个子集流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>).filter(i -&gt; i&gt;<span class="hljs-number">2</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5 id="2-peek"><a href="#2-peek" class="headerlink" title="2.peek"></a>2.peek</h5><p>用于debug，foreach是最终操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).peek(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out::println).<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br></code></pre></td></tr></table></figure><h5 id="3-map"><a href="#3-map" class="headerlink" title="3.map"></a>3.map</h5><p>将流中的元素映射到另一个流中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).map(String::length).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5 id="4-limit"><a href="#4-limit" class="headerlink" title="4.limit"></a>4.limit</h5><p>对流进行截取，只取用前n个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5 id="5-skip"><a href="#5-skip" class="headerlink" title="5.skip"></a>5.skip</h5><p>跳过前几个</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).skip(<span class="hljs-number">2</span>).<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="3-2-终止方法"><a href="#3-2-终止方法" class="headerlink" title="3.2 终止方法"></a>3.2 终止方法</h4><h5 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1.forEach"></a>1.forEach</h5><p>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5 id="2-count"><a href="#2-count" class="headerlink" title="2.count"></a>2.count</h5><p>计算个数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).count<span class="hljs-literal">()</span>);<br></code></pre></td></tr></table></figure><h5 id="3-collect"><a href="#3-collect" class="headerlink" title="3.collect"></a>3.collect</h5><p>收集到list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).collect(Collectors.toList());<br>System.out.println(<span class="hljs-string">&quot;收集到list:&quot;</span>+list);<br></code></pre></td></tr></table></figure><h5 id="4-reduce"><a href="#4-reduce" class="headerlink" title="4.reduce"></a>4.reduce</h5><p>从Stream中生成一个值</p><ul><li>使用reduce拼接字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; newStr = Stream.of(str.split(<span class="hljs-string">&quot;&quot;</span>)).reduce((str1, str2) -&gt; str1 + <span class="hljs-string">&quot;-&quot;</span> + str2);<br>System.out.println(newStr.orElse(<span class="hljs-string">&quot;&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>使用reduce拼接字符串-+ 带有初始值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String newStr2 = Stream.of(str.split(<span class="hljs-string">&quot;&quot;</span>)).reduce(<span class="hljs-string">&quot;&quot;</span>, (str1, str2) -&gt; str1 + <span class="hljs-string">&quot;-&quot;</span> + str2);<br>System.out.println(newStr2);<br></code></pre></td></tr></table></figure><ul><li>使用reduce计算所有单词总长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Integer&gt; length = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).map(s -&gt; s.length()).reduce((len1, len2) -&gt; len1 + len2);<br>System.out.println(<span class="hljs-string">&quot;length:&quot;</span> + length.get());<br></code></pre></td></tr></table></figure><h5 id="5-max"><a href="#5-max" class="headerlink" title="5.max"></a>5.max</h5><p>求最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; maxValue = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).max((str1, str2) -&gt; str1.length() - str2.length());<br>System.out.println(<span class="hljs-string">&quot;maxValue:&quot;</span> + maxValue.get());<br></code></pre></td></tr></table></figure><h5 id="6-findFirst"><a href="#6-findFirst" class="headerlink" title="6.findFirst"></a>6.findFirst</h5><p>找第一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; firstValue = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).findFirst();<br>System.out.println(<span class="hljs-string">&quot;firstValue:&quot;</span> + firstValue.get());<br></code></pre></td></tr></table></figure><h3 id="4-惰性求值"><a href="#4-惰性求值" class="headerlink" title="4. 惰性求值"></a>4. 惰性求值</h3><p>惰性求值：终结没有调用的情况下，延迟方法不会执行。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">int</span> num2 = IntStream.of(numbers).map(StreamDemo1::doubleNum).sum();<br>        System.out.println(num2);<br>      <br>      <span class="hljs-comment">// 这里没有执行中间操作</span><br>        IntStream.of(numbers).map(StreamDemo1::doubleNum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doubleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了乘以2&quot;</span>);<br>        <span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">Task :StreamDemo1.main()</span><br>执行了乘以2<br>执行了乘以2<br>执行了乘以2<br>12<br></code></pre></td></tr></table></figure><p>中间操作就是：返回stream的操作，如：map</p><p>终止操作就是：sum()</p><p>从输出结果可以看出doubleNum执行了3次</p><h3 id="5-并行流"><a href="#5-并行流" class="headerlink" title="5.并行流"></a>5.并行流</h3><h4 id="5-1-创建一个并行流"><a href="#5-1-创建一个并行流" class="headerlink" title="5.1 创建一个并行流"></a>5.1 创建一个并行流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallelStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>).parallel().peek(ParallelStream::debugger).count();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;debugger&quot;</span>+i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">Task :ParallelStream.main()</span><br>debugger90<br>debugger81<br>debugger82<br>debugger83<br>debugger84<br>debugger85<br>debugger86<br>debugger65<br>debugger66<br>debugger67<br><span class="hljs-meta">...</span><br></code></pre></td></tr></table></figure><ul><li>多次调用parallel &#x2F; sequential，以最后一个为准，如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallelStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>                .parallel().peek(ParallelStream::debugger)<br>                .sequential().peek(ParallelStream::debugger2)<br>                .count();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.err.println(<span class="hljs-string">&quot;debugger2: &quot;</span> + i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;debugger1: &quot;</span> + i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-并行流使用自己定义的线程池"><a href="#5-2-并行流使用自己定义的线程池" class="headerlink" title="5.2 并行流使用自己定义的线程池"></a>5.2 并行流使用自己定义的线程池</h4><blockquote><p>原因：避免使用默认线程池，防止任务被阻塞</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;<br><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallelStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">20</span>);<br>        forkJoinPool.submit(() -&gt; IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>                .parallel().peek(ParallelStream::debugger)<br>                .count());<br>        forkJoinPool.shutdown();<br><br>        <span class="hljs-keyword">synchronized</span> (forkJoinPool) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                forkJoinPool.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;debugger1: &quot;</span> + i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Stream-流的运行机制"><a href="#6-Stream-流的运行机制" class="headerlink" title="6. Stream 流的运行机制"></a>6. Stream 流的运行机制</h3><p>所有的操作都是链式调用，每个操作只会对每个元素操作一次；（是通过维护一个链表实现的。）具体实现：</p><blockquote><ul><li>每个中间操作都会返回一个新的流，每个流里面都会有一个SourceStage属性，所有流的SourceStage属性都指向同一个地方head【就是原始流的头部】；</li><li>如果一个中间操作之后还有中间操作，那么这个中间操作对应的流中nextStage属性就会执行下一个中间操作对应的流，否则就是null</li></ul></blockquote><p>注：parallel &#x2F; sequential也是中间操作，但是他们呢不创建流，只是修改head 里的并行标志：parallel</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stream流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8的新特性之lambda表达式</title>
    <link href="/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-函数接口"><a href="#1-函数接口" class="headerlink" title="1.函数接口"></a>1.函数接口</h3><p>函数接口（<code>@FunctionalInterface</code>）需要满足两个条件：</p><ul><li>类型是接口</li><li>有且只有一个抽象方法</li></ul><p>例如：Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这也是要求我们接口的设计尽量小，符合单一责任制，一个接口只做一个事，这样使用lambda就会比较方便。</p><h3 id="2-lambda表达式是个啥？"><a href="#2-lambda表达式是个啥？" class="headerlink" title="2. lambda表达式是个啥？"></a>2. lambda表达式是个啥？</h3><p><strong>lambda表达式</strong>是<strong>Java8</strong>的新特性，它就是就是一个匿名函数，箭头左边是函数的参数，右边是函数的执行体。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>              System.out.println(<span class="hljs-string">&quot;正常创建一个线程&quot;</span>);<br>          &#125;<br>      &#125;).start();<br>      # 实际上是返回了一个实现了Runnable的实例，箭头左边是参数，右边是方法体<br>      <span class="hljs-keyword">new</span> Thread(()-&gt; System.out.println(<span class="hljs-string">&quot;Lambda创建一个线程&quot;</span>)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上面的代码为例，Runnable接口仅有一个run方法，并且该方法没有参数，所以编译器可以自动推断出箭头后的内容为run方法的方法体。</p><p>如果Runnable接口中含有多个方法，编译器将无法编译lambda表达式，可以看出，lambda表达式是根据编译器的隐式推断来简化代码的。所以，<strong>lambda表达式需要函数式接口的支持。</strong></p><p><strong>实例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MoneyFormat</span></span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">format</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MoneyDemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMoney</span><span class="hljs-params">(MoneyFormat moneyFormat)</span></span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;金额数为：&quot;</span> + moneyFormat.format(<span class="hljs-keyword">this</span>.money)));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MoneyDemo moneyDemo = <span class="hljs-keyword">new</span> MoneyDemo(<span class="hljs-number">999</span>);<br>        moneyDemo.printMoney(i -&gt; <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#,##&quot;</span>).format(i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上可见，我们不关心接口的名字是什么，只关心输入是int，输出 是string，因此上面代码可优化为：</p><p>删除interface MoneyFormat，使用jdk8带的函数接口Function&lt;Integer,String&gt;替代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MoneyDemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMoney</span><span class="hljs-params">(Function&lt;Integer,String&gt; moneyFormat)</span></span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;金额数为：&quot;</span> + moneyFormat.apply(<span class="hljs-keyword">this</span>.money)));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MoneyDemo moneyDemo = <span class="hljs-keyword">new</span> MoneyDemo(<span class="hljs-number">999</span>);<br>        moneyDemo.printMoney(i -&gt; <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#,##&quot;</span>).format(i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="3-lambda表达式常用的函数式接口"><a href="#3-lambda表达式常用的函数式接口" class="headerlink" title="3. lambda表达式常用的函数式接口"></a>3. lambda表达式常用的函数式接口</h2><p>主要是分布在java.util.function包中，下面只简单列举2种：</p><h4 id="2-1-Supplier接口"><a href="#2-1-Supplier接口" class="headerlink" title="2.1 Supplier接口"></a>2.1 Supplier接口</h4><ul><li><code>java.util.function.Supplier&lt;T&gt;</code> 接口仅含有一个无参方法,<code>T get()</code></li><li><code>Supplier&lt;T&gt;</code> 接口是生产型接口,接口泛型指定什么类型,就返回什么泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupplierDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">supplyName</span><span class="hljs-params">(Supplier&lt;String&gt; supplier)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> supplier.get();<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SupplierDemo supplierDemo = <span class="hljs-keyword">new</span> SupplierDemo();<br>        String name = supplierDemo.supplyName(() -&gt; <span class="hljs-string">&quot;张三&quot;</span>);<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-Consumer接口"><a href="#3-2-Consumer接口" class="headerlink" title="3.2 Consumer接口"></a>3.2 Consumer接口</h3><ul><li><code>java.util.function.Consumer接口&lt;T&gt;</code> 接口仅含有一个有参方法,<code>void accept(T t)</code></li><li><code>Consumer接口&lt;T&gt;</code> 接口是消费型接口,接口泛型制定什么类型,就接受什么泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printName</span><span class="hljs-params">(String name, Consumer&lt;String&gt; consumer)</span> </span>&#123;<br>        consumer.accept(name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ConsumerDemo consumerDemo = <span class="hljs-keyword">new</span> ConsumerDemo();<br>        consumerDemo.printName(<span class="hljs-string">&quot;张三&quot;</span>, (String name) -&gt; System.out.println(<span class="hljs-string">&quot;姓名为 : &quot;</span> + name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lambda表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8的新特性之方法引用</title>
    <link href="/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <url>/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-方法引用是什么？"><a href="#1-方法引用是什么？" class="headerlink" title="1.方法引用是什么？"></a>1.方法引用是什么？</h3><blockquote><p>Java8的新特性之二：方法引用。方法引用其实也离不开Lambda表达式。</p></blockquote><ul><li><p>方法引用通过方法的名字来指向一个方法。</p></li><li><p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p></li><li><p>方法引用使用一对冒号 <strong>::</strong> 。</p></li></ul><h2 id="2、方法引用的分类"><a href="#2、方法引用的分类" class="headerlink" title="2、方法引用的分类"></a>2、方法引用的分类</h2><p>下面，我们在 Car 类中定义了 4 个方法作为例子来区分 Java 中 4 种不同方法的引用。</p><span id="more"></span><table><thead><tr><th align="center">类型</th><th>语法</th><th>对应lambda表达式</th></tr></thead><tbody><tr><td align="center">静态方法引用</td><td>类名::staticMethod</td><td>(args) -&gt; 类名.staticMethod(args)</td></tr><tr><td align="center">实例方法引用</td><td>instance::instance_Method</td><td>(args) -&gt; instance.instance_Method(args)</td></tr><tr><td align="center">对象方法引用</td><td>类名::instance_Method</td><td>(inst,args) -&gt; 类名.instance_Method(args)</td></tr><tr><td align="center">构建方法引用</td><td>类名::new</td><td>(args) -&gt; new 类名(args)</td></tr></tbody></table><h3 id="3、方法引用举例"><a href="#3、方法引用举例" class="headerlink" title="3、方法引用举例"></a>3、方法引用举例</h3><h4 id="3-1-静态方法引用"><a href="#3-1-静态方法引用" class="headerlink" title="3.1 静态方法引用"></a>3.1 静态方法引用</h4><ul><li><p>实例1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s); 输出的参数和输入的参数一致，可以缩写</span><br>    Consumer&lt;String&gt; consumer = System.out::println;<br>    consumer.accept(<span class="hljs-string">&quot;接受的数据&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p> 实例中我们将 System.out::println 方法作为静态方法来引用。</p></li><li><p>实例2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;啸天犬&quot;</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bark</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>            System.out.println(dog + <span class="hljs-string">&quot;狗叫了&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>        &#125;<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">//静态方法</span><br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        Consumer&lt;Dog&gt; consumer2 = Dog::bark;<br>        consumer2.accept(dog);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-2-实例方法引用"><a href="#3-2-实例方法引用" class="headerlink" title="3.2 实例方法引用"></a>3.2 实例方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> food_weight = <span class="hljs-number">10</span>;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;小狗吃了&quot;</span> + weight + <span class="hljs-string">&quot;斤狗粮&quot;</span>);<br>            <span class="hljs-keyword">this</span>.food_weight -= weight;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.food_weight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">// Function&lt;Integer, Integer&gt; function = dog::eat;</span><br>        <span class="hljs-comment">// UnaryOperator&lt;Integer&gt; function = dog::eat;</span><br>        <span class="hljs-comment">// int weight = function.apply(3);</span><br>        IntUnaryOperator function = dog::eat;<br>        <span class="hljs-keyword">int</span> weight = function.applyAsInt(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;还剩余&quot;</span> + weight + <span class="hljs-string">&quot;斤狗粮&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的eat方法，页可改写为<code>public int eat(Dog this, int weight) </code>编译也不会报错。因此&#x3D;》</p><blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">JDk会默认把当前实例传入到非静态方法，参数名为<span class="hljs-keyword">this</span>，位置是第一个<br></code></pre></td></tr></table></figure></blockquote><h4 id="3-3-构建方法引用"><a href="#3-3-构建方法引用" class="headerlink" title="3.3 构建方法引用"></a>3.3 构建方法引用</h4><ul><li>无参数的构造方法引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;啸天犬&quot;</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Supplier&lt;Dog&gt; supplier = Dog::<span class="hljs-keyword">new</span>;<br>        System.out.println(supplier.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有参数的构造方法的引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;啸天犬&quot;</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Function&lt;String,Dog&gt; function2 =  Dog::<span class="hljs-keyword">new</span>;;<br>        System.out.println(function2.apply(<span class="hljs-string">&quot;小杂毛&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch简介</title>
    <link href="/ElasticSearch%E7%AE%80%E4%BB%8B/"/>
    <url>/ElasticSearch%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h1><h2 id="Es是什么？"><a href="#Es是什么？" class="headerlink" title="Es是什么？"></a>Es是什么？</h2><ul><li>Elasticsearch是用Java开发并且是当前最流行的开源的企业级搜索引擎。</li><li>能够达到实时搜索，稳定，可靠，快速，安装使用方便。</li><li>客户端支持Java、.NET（C#）、PHP、Python、Ruby等多种语言。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>关键词搜索。</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224603261.png" alt="image-20230228224603261"></p><blockquote><p>从上面的搜索结果，可以看出不是根据模糊匹配去进行搜索的</p></blockquote><h2 id="ElasticSearch与Lucene的关系"><a href="#ElasticSearch与Lucene的关系" class="headerlink" title="ElasticSearch与Lucene的关系"></a>ElasticSearch与Lucene的关系</h2><ul><li>Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库（框架）</li></ul><h3 id="Lucene缺点："><a href="#Lucene缺点：" class="headerlink" title="Lucene缺点："></a>Lucene缺点：</h3><ul><li>想要使用Lucene，必须使用Java来作为开发语言并将其直接集成到你的应用中。</li><li>Lucene的配置及使用非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</li><li>使用非常复杂-创建索引和搜索索引代码繁杂。</li><li>不支持集群环境-索引数据不同步（不支持大型项目）</li><li>索引数据如果太多就不行，索引库和应用所在同一个服务器,共同占用硬盘.共用空间少.</li></ul><p><strong>上述Lucene框架中的缺点,ES全部都能解决.</strong></p><h2 id="哪些公司在使用Elasticsearch"><a href="#哪些公司在使用Elasticsearch" class="headerlink" title="哪些公司在使用Elasticsearch"></a>哪些公司在使用Elasticsearch</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224612979.png" alt="image-20230228224612979"></p><h2 id="ES-vs-Solr比较"><a href="#ES-vs-Solr比较" class="headerlink" title="ES vs Solr比较"></a>ES vs Solr比较</h2><ul><li>当单纯的对已有数据进行搜索时，Solr更快。</li><li>当实时建立索引时,Solr会产生io阻塞，查询性能较差,Elasticsearch具有明显的优势。</li><li>Solr利用Zookeeper进行分布式管理，而Elasticsearch自身带有分布式协调管理功能。</li><li>Solr支持更多格式的数据，比如JSON、XML、CSV，而Elasticsearch仅支持json文件格式。</li><li>Solr在传统的搜索应用中表现好于Elasticsearch，但在处理实时搜索应用时效率明显低于Elasticsearch。</li><li>Solr是传统搜索应用的有力解决方案，但Elasticsearch更适用于新兴的实时搜索应用。</li></ul><h2 id="ESvs关系型数据库"><a href="#ESvs关系型数据库" class="headerlink" title="ESvs关系型数据库"></a>ESvs关系型数据库</h2><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224621969.png" alt="image-20230228224621969"></p><h2 id="Lucene全文检索框架"><a href="#Lucene全文检索框架" class="headerlink" title="Lucene全文检索框架"></a>Lucene全文检索框架</h2><h3 id="什么是全文检索"><a href="#什么是全文检索" class="headerlink" title="什么是全文检索"></a>什么是全文检索</h3><ul><li>全文检索是指：通过一个程序扫描文本中的每一个单词，针对单词建立索引，并保存该单词在文本中的位置、以及出现的次数。</li><li>用户查询时，通过之前建立好的索引来查询，将索引中单词对应的文本位置、出现的次数返回给用户，因为有了具体文本的位置，所以就可以将具体内容读取出来了</li></ul><h3 id="词原理之倒排索引"><a href="#词原理之倒排索引" class="headerlink" title="词原理之倒排索引"></a>词原理之倒排索引</h3><p>对于关系型数据库mysql来说，<strong>普通的索引结构就是“id-&gt;题目-&gt;内容”，</strong>在我们搜索的时候，如果我们知道id或者题目<strong>，那么检索效率是很高效的，因为“id”、“题目”是很方便创建索引的。</strong></p><p>那么<strong>倒排序索引</strong>的结构是怎样的呢？简单来讲<strong>就是“以内容的关键词”建立索引，</strong>映射关系为<strong>“内容的关键词-&gt;ID”。</strong>这样的话，我们只需要在“关键词”中进行检索</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228224640464.png" alt="image-20230228224640464"></p><blockquote><p>对于上面的场景，输入为hello，会根据hello定位到此时数据的id为1和2，进而查出对应的数据。</p></blockquote><h2 id="Elasticsearch中的核心概念"><a href="#Elasticsearch中的核心概念" class="headerlink" title="Elasticsearch中的核心概念"></a>Elasticsearch中的核心概念</h2><h3 id="索引index"><a href="#索引index" class="headerlink" title="索引index"></a>索引index</h3><ul><li>一个索引就是一个拥有几分相似特征的文档的集合。比如说，可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引</li><li>一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字</li></ul><h3 id="映射mapping"><a href="#映射mapping" class="headerlink" title="映射mapping"></a>映射mapping</h3><ul><li><p>ElasticSearch中的映射（Mapping）用来定义一个文档</p></li><li><p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分词器、是否被索引等等，这些都是映射里面可以设置的</p></li></ul><h3 id="字段Field"><a href="#字段Field" class="headerlink" title="字段Field"></a>字段Field</h3><ul><li>相当于是数据表的字段|列</li></ul><h3 id="字段类型Type"><a href="#字段类型Type" class="headerlink" title="字段类型Type"></a>字段类型Type</h3><p>每一个字段都应该有一个对应的类型，例如：Text、Keyword、Byte等</p><h3 id="文档document"><a href="#文档document" class="headerlink" title="文档document"></a>文档document</h3><p>一个文档是一个可被索引的基础信息单元，类似一条记录。文档以JSON（JavascriptObjectNotation）格式来表示；</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oauth2</title>
    <link href="/oauth2/"/>
    <url>/oauth2/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="oauth2-0"><a href="#oauth2-0" class="headerlink" title="oauth2.0"></a>oauth2.0</h1><h2 id="一-oauth2-0-产生"><a href="#一-oauth2-0-产生" class="headerlink" title="一. oauth2.0 产生"></a>一. oauth2.0 产生</h2><ol><li>传统方式：用户和第三方共享密码<ul><li>不安全。未来可能会持久访问资源，第三方存储用户密码不安全，因为他可以访问用户的所有资源</li><li>改密码的话，第三方会失效</li></ul></li></ol><h2 id="二-oauth2-0是什么？"><a href="#二-oauth2-0是什么？" class="headerlink" title="二. oauth2.0是什么？"></a>二. oauth2.0是什么？</h2><blockquote><ul><li><p>oauth2.0 是一种授权方式，使第三方可以获得对用户资源的访问</p></li><li><p>他的核心就是：向第三方应用颁发令牌</p></li><li><p>不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）</p></li></ul></blockquote><h2 id="三-OAuth-2-0-规定了四种获得令牌的流程"><a href="#三-OAuth-2-0-规定了四种获得令牌的流程" class="headerlink" title="三.OAuth 2.0 规定了四种获得令牌的流程"></a>三.OAuth 2.0 规定了四种获得令牌的流程</h2><span id="more"></span><h3 id="3-1-授权码模式"><a href="#3-1-授权码模式" class="headerlink" title="3.1 授权码模式"></a>3.1 授权码模式</h3><p><strong>第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p><ol><li><p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">https:<span class="hljs-comment">//b.com/oauth/authorize?</span><br>  response_type=code&amp;                        <br>  client_id=CLIENT_ID&amp;<br>  redirect_uri=CALLBACK_URL&amp;<br>  scope=read<br></code></pre></td></tr></table></figure><ul><li>response_type表示要求返回授权码</li><li>client_id让B网站知道是谁在请求</li><li>redirect_uri 是B网站接受或处理后跳转的URL</li><li>scope 表示授权的范围，这里是只读</li></ul></li><li><p>第二步，此时B网站会询问用户是否给予A网站授权，用户表示同意，这时B网站就会跳转到上一步<code>redirect_uri</code> 中的地址（也就是我们常说的callback地址），同时返回一个授权码，如下面的地址，其中，<code>code</code>参数就是授权码</p></li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//a.com/callback?code=AUTHORIZATION_CODE</span><br></code></pre></td></tr></table></figure><ol start="3"><li>第三步，A网站拿到授权码后，就可以根据该授权码，在后端向B网站请求<strong>令牌</strong></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//b.com/oauth/token?</span><br> <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br> <span class="hljs-attr">client_secret</span>=<span class="hljs-string">CLIENT_SECRET&amp;</span><br> <span class="hljs-attr">grant_type</span>=<span class="hljs-string">authorization_code&amp;</span><br> <span class="hljs-attr">code</span>=<span class="hljs-string">AUTHORIZATION_CODE&amp;</span><br> <span class="hljs-attr">redirect_uri</span>=<span class="hljs-string">CALLBACK_URL</span><br></code></pre></td></tr></table></figure><ul><li><p><code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求）</p></li><li><p><code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码</p></li><li><p><code>code</code>参数是上一步拿到的授权码</p></li><li><p><code>redirect_uri</code>参数是令牌颁发后的回调网址。</p></li></ul><ol start="4"><li><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nim">&#123;    <br>  <span class="hljs-string">&quot;access_token&quot;</span>:<span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span>,<br>  <span class="hljs-string">&quot;token_type&quot;</span>:<span class="hljs-string">&quot;bearer&quot;</span>,<br>  <span class="hljs-string">&quot;expires_in&quot;</span>:<span class="hljs-number">2592000</span>,<br>  <span class="hljs-string">&quot;refresh_token&quot;</span>:<span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span>,<br>  <span class="hljs-string">&quot;scope&quot;</span>:<span class="hljs-string">&quot;read&quot;</span>,<br>  <span class="hljs-string">&quot;uid&quot;</span>:<span class="hljs-number">100101</span>,<br>  <span class="hljs-string">&quot;info&quot;</span>:<span class="hljs-meta">&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p></li></ol><h4 id="3-2-隐藏式模式（适合没有后台的第三方）"><a href="#3-2-隐藏式模式（适合没有后台的第三方）" class="headerlink" title="3.2 隐藏式模式（适合没有后台的第三方）"></a>3.2 隐藏式模式（适合没有后台的第三方）</h4><p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//b.com/oauth/authorize?</span><br>  <span class="hljs-attr">response_type</span>=<span class="hljs-string">token&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br>  <span class="hljs-attr">redirect_uri</span>=<span class="hljs-string">CALLBACK_URL&amp;</span><br>  <span class="hljs-attr">scope</span>=<span class="hljs-string">read</span><br></code></pre></td></tr></table></figure><p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>a.com/callback<span class="hljs-comment">#token=ACCESS_TOKEN</span><br></code></pre></td></tr></table></figure><p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p><ol><li>点击链接，跳转至第三方</li><li>第三方直接把令牌给客户端</li></ol><p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p><h4 id="3-3-密码模式（风险极大，适合于用户极其信任第三方）"><a href="#3-3-密码模式（风险极大，适合于用户极其信任第三方）" class="headerlink" title="3.3 密码模式（风险极大，适合于用户极其信任第三方）"></a>3.3 密码模式（风险极大，适合于用户极其信任第三方）</h4><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌</strong></p><ol><li>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。、</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//oauth.b.com/token?</span><br>  <span class="hljs-attr">grant_type</span>=<span class="hljs-string">password&amp;</span><br>  <span class="hljs-attr">username</span>=<span class="hljs-string">USERNAME&amp;</span><br>  <span class="hljs-attr">password</span>=<span class="hljs-string">PASSWORD&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID</span><br></code></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p><ol start="2"><li>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</li></ol><h4 id="3-4-凭证式模式（适合没有前端的第三方）"><a href="#3-4-凭证式模式（适合没有前端的第三方）" class="headerlink" title="3.4 凭证式模式（适合没有前端的第三方）"></a>3.4 凭证式模式（适合没有前端的第三方）</h4><p><strong>命令行下请求令牌。</strong>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><ol><li>第一步，A 应用在命令行向 B 发出请求。</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//oauth.b.com/token?</span><br>  <span class="hljs-attr">grant_type</span>=<span class="hljs-string">client_credentials&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br>  <span class="hljs-attr">client_secret</span>=<span class="hljs-string">CLIENT_SECRET</span><br></code></pre></td></tr></table></figure><ul><li><p><code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式</p></li><li><p><code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p></li></ul><ol start="2"><li>第二步，B 网站验证通过以后，直接返回令牌。</li></ol><p>适合场景：向该平台所有用户发送消息提醒</p><h2 id="四、令牌的使用"><a href="#四、令牌的使用" class="headerlink" title="四、令牌的使用"></a>四、令牌的使用</h2><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p><p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">curl -H <span class="hljs-string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> <span class="hljs-string">\</span><br><span class="hljs-string">&quot;https://api.b.com&quot;</span><br></code></pre></td></tr></table></figure><p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p><h2 id="五、更新令牌"><a href="#五、更新令牌" class="headerlink" title="五、更新令牌"></a>五、更新令牌</h2><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//b.com/oauth/token?</span><br>  <span class="hljs-attr">grant_type</span>=<span class="hljs-string">refresh_token&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br>  <span class="hljs-attr">client_secret</span>=<span class="hljs-string">CLIENT_SECRET&amp;</span><br>  <span class="hljs-attr">refresh_token</span>=<span class="hljs-string">REFRESH_TOKEN</span><br></code></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌。</p>]]></content>
    
    
    <categories>
      
      <category>Oauth2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper集群特性</title>
    <link href="/zookeeper%E9%9B%86%E7%BE%A4%E7%89%B9%E6%80%A7/"/>
    <url>/zookeeper%E9%9B%86%E7%BE%A4%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="1-集群的目的"><a href="#1-集群的目的" class="headerlink" title="1 集群的目的"></a>1 集群的目的</h2><p>zookeeper集群是为了保证系统的性能，能够承载更多的客户端连接。通过集群(主从模式可以实现以下功能：</p><ul><li>读写分离：提高承载，为更多的客户端提供连接，并保障性能。</li><li>主从自动切换：提高服务容错性，部分节点故障不会影响整个服务集群。</li></ul><h2 id="2-半数以上运行机制说明"><a href="#2-半数以上运行机制说明" class="headerlink" title="2 半数以上运行机制说明"></a>2 半数以上运行机制说明</h2><p>集群至少需要三台服务器，并且强烈建议使用奇数个服务器。</p><p>因为zookeeper 通过判断大多数节点的存活来判断整个服务是否可用。比如3个节点，挂掉了2个表示整个集群挂掉，而用偶数4个，挂掉了2个也表示其并不是大部分存活，因此也会挂掉。</p><h2 id="3-集群部署"><a href="#3-集群部署" class="headerlink" title="3 集群部署"></a>3 集群部署</h2><h3 id="配置语法："><a href="#配置语法：" class="headerlink" title="配置语法："></a>配置语法：</h3><p><code>server.&lt;节点ID&gt;=&lt;ip&gt;:&lt;数据同步端口&gt;:&lt;选举端口&gt;</code></p><ul><li>节点ID：服务id手动指定1至125之间的数字，并写到对应服务节点的 {dataDir}&#x2F;myid 文件中。</li><li>IP地址：节点的远程IP地址，可以相同。但生产环境就不能这么做了，因为在同一台机器就无法达到容错的目的。所以这种称作为伪集群。</li><li>数据同步端口：主从同时数据复制端口，（做伪集群时端口号不能重复）。</li><li>远举端口：主从节点选举端口，（做伪集群时端口号不能重复）。</li></ul><p><strong>配置文件示例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attribute">dataDir</span>=/var/lib/zookeeper/<br><span class="hljs-attribute">clientPort</span>=<span class="hljs-number">2181</span><br><span class="hljs-attribute">initLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attribute">syncLimit</span>=<span class="hljs-number">2</span><br><span class="hljs-comment">#以下为集群配置，必须配置在所有节点的zoo.cfg文件中</span><br><span class="hljs-attribute">server</span>.<span class="hljs-number">1</span>=zoo<span class="hljs-number">1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attribute">server</span>.<span class="hljs-number">2</span>=zoo<span class="hljs-number">2</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attribute">server</span>.<span class="hljs-number">3</span>=zoo<span class="hljs-number">3</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br></code></pre></td></tr></table></figure><h3 id="集群配置流程："><a href="#集群配置流程：" class="headerlink" title="集群配置流程："></a>集群配置流程：</h3><ol><li>分别创建3个data目录用于存储各节点数据</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span></span><br><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/1</span><br><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/3</span><br><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/3</span><br></code></pre></td></tr></table></figure><ol start="2"><li>编写myid文件</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> <span class="hljs-number">1</span> &gt; data/<span class="hljs-number">1</span>/myid<br><span class="hljs-attribute">echo</span> <span class="hljs-number">3</span> &gt; data/<span class="hljs-number">3</span>/myid<br><span class="hljs-attribute">echo</span> <span class="hljs-number">2</span> &gt; data/<span class="hljs-number">2</span>/myid<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ls -R data<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><br>data/<span class="hljs-number">1</span>:<br>myid<br><br>data/<span class="hljs-number">2</span>:<br>myid<br><br>data/<span class="hljs-number">3</span>:<br>myid<br></code></pre></td></tr></table></figure><p>3、编写配置文件</p><ul><li><code>vim conf/zoo1.cfg</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=data/<span class="hljs-number">1</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2181</span><br><span class="hljs-comment">#集群配置</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure><ul><li><code>vim conf/zoo2.cfg</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=data/<span class="hljs-number">2</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2182</span><br><span class="hljs-comment">#集群配置</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure><ul><li><code>vim conf/zoo3.cfg</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=data/<span class="hljs-number">3</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2183</span><br><span class="hljs-comment">#集群配置</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure><p>4.分别启动</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>zkServer.sh start conf/zoo1.cfg<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh start conf/zoo2.cfg<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh start conf/zoo3.cfg<br></code></pre></td></tr></table></figure><p>5.分别查看状态</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo1.cfg<br>Mode: follower<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo2.cfg<br>Mode: follower<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo3.cfg<br>Mode: leader<br></code></pre></td></tr></table></figure><ol start="6"><li>进入客户端，在server1中创建节点，server 3查看节点是否同步</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">.<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>zkCli.sh <span class="hljs-operator">-</span>server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span><br><br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span>(CONNECTED) <span class="hljs-number">0</span>] ls <span class="hljs-operator">/</span><br>[zookeeper]<br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span>(CONNECTED) <span class="hljs-number">1</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>tt<br>Created <span class="hljs-operator">/</span>tt0000000001<br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span>(CONNECTED) <span class="hljs-number">2</span>] ls <span class="hljs-operator">/</span><br>[tt0000000001, zookeeper]<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">.<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>zkCli.sh <span class="hljs-operator">-</span>server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2183</span><br><br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2183</span>(CONNECTED) <span class="hljs-number">1</span>] ls <span class="hljs-operator">/</span><br>[tt0000000001, zookeeper]<br></code></pre></td></tr></table></figure><h2 id="4-集群角色说明"><a href="#4-集群角色说明" class="headerlink" title="4 集群角色说明"></a>4 集群角色说明</h2><p>zookeeper 集群中总共有三种角色，分别是leader（主节点）follower(子节点) observer（次级子节点）</p><table><thead><tr><th align="left">角色</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>leader</strong></td><td align="left">主节点，又名领导者。用于写入数据，通过选举产生，如果宕机将会选举新的主节点。</td></tr><tr><td align="left"><strong>follower</strong></td><td align="left">子节点，又名追随者。用于实现数据的读取。同时他也是主节点的备选节点，并用拥有投票权。</td></tr><tr><td align="left"><strong>observer</strong></td><td align="left">次级子节点，又名观察者。用于读取数据，与fllower区别在于没有投票权，不能选为主节点。并且在计算集群可用状态时不会将observer计算入内。</td></tr></tbody></table><p><strong>observer配置：</strong><br>只要在集群配置中加上observer后缀即可，示例如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">server</span>.<span class="hljs-number">3</span>=<span class="hljs-number">127.0.0.1:2889</span>:<span class="hljs-number">3889</span>:observer<br></code></pre></td></tr></table></figure><h2 id="5-集群选举机制"><a href="#5-集群选举机制" class="headerlink" title="5 集群选举机制"></a>5 集群选举机制</h2><p>通过 .&#x2F;bin&#x2F;zkServer.sh status &lt;zoo配置文件&gt; 命令可以查看到节点状态，可以发现中间的2182 是leader状态</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo1.cfg<br>Mode: follower<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo2.cfg<br>Mode: leader<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo3.cfg<br>Mode: follower<br></code></pre></td></tr></table></figure><h2 id="5-1-投票机制说明"><a href="#5-1-投票机制说明" class="headerlink" title="5.1 投票机制说明"></a>5.1 投票机制说明</h2><ol><li><p>第一轮投票全部投给自己</p></li><li><p>第二轮投票给myid比自己大的相邻节点，</p></li><li><p>如果得票超过半数，选举结束。</p></li></ol><p>其选举机制如下图：</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223714485.png" alt="image-20230228223714485"></p><h2 id="5-2-选举触发："><a href="#5-2-选举触发：" class="headerlink" title="5.2 选举触发："></a>5.2 <strong>选举触发：</strong></h2><p>当集群中的服务器出现已下两种情况时会进行Leader的选举</p><ol><li>服务节点初始化启动。当节点初始起动时会在集群中寻找Leader节点，如果找到则与Leader建立连接，其自身状态变化<strong>follower</strong>或<strong>observer。</strong>如果没有找到Leader，当前节点状态将变化LOOKING，进入选举流程。</li><li>半数以上的节点无法和Leader建立连接。在集群运行其间如果有follower或observer节点宕机只要不超过半数并不会影响整个集群服务的正常运行。但如果leader宕机，将暂停对外服务，所有follower将进入LOOKING 状态，进入选举流程。</li></ol><h2 id="5-3-数据同步机制"><a href="#5-3-数据同步机制" class="headerlink" title="5.3 数据同步机制"></a>5.3 数据同步机制</h2><p>zookeeper 的数据同步是为了保证各节点中数据的一至性，同步时涉及两个流程，一个是正常的客户端数据提交，另一个是集群某个节点宕机在恢复后的数据同步。</p><h2 id="5-3-1-客户端写入请求"><a href="#5-3-1-客户端写入请求" class="headerlink" title="5.3.1 客户端写入请求"></a>5.3.1 客户端写入请求</h2><p>当我们使用zookeeper客户端向Zookeeper 集群的某一个 Server 发送事务请求时，也就是对 Znode 节点的增删改操作时。</p><ol><li>如果该server不是leader，则会将该写请求转发给leader server，leader将请求事务以proposal（建议）形式分发给follower；</li><li>当follower收到收到leader的proposal时，根据接收的先后顺序处理proposal；</li><li>当Leader收到follower针对某个proposal过半的ack后，（即follower过半都已经同步完成）则发起事务提交，重新发起一个commit的proposal</li><li>Follower收到commit的proposal后，记录事务提交，并把数据更新到内存数据库；</li><li>当写成功后，反馈给client。</li></ol><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223852985.png" alt="image-20230228223852985"></p><h2 id="5-3-2-服务节点初始化同步"><a href="#5-3-2-服务节点初始化同步" class="headerlink" title="5.3.2 服务节点初始化同步"></a>5.3.2 服务节点初始化同步</h2><ul><li><p>在集群运行过程当中如果有一个follower节点宕机，由于宕机节点没过半，集群仍然能正常服务。</p></li><li><p>当leader 收到新的客户端请求，此时无法同步给宕机的节点。造成数据不一致。为了解决这个问题，当节点启动时，第一件事情就是找当前的Leader，比对数据是否一致。不一致则开始同步,同步完成之后在进行对外提供服务。故在节点同步数据期间，该节点不会对外提供服务。</p></li><li><p>Leader挂了后，选举leader的过程中，集群不可以对外提供服务。</p></li></ul><h1 id="6-四字运维命令"><a href="#6-四字运维命令" class="headerlink" title="6 四字运维命令"></a>6 四字运维命令</h1><p>ZooKeeper响应少量命令。每个命令由四个字母组成。可通过telnet或nc向ZooKeeper发出命令。<br>这些命令默认是关闭的，需要配置4lw.commands.whitelist来打开，可打开部分或全部示例如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#打开指定命令</span><br>4lw.commands.<span class="hljs-attribute">whitelist</span>=stat, ruok, conf, isro<br><span class="hljs-comment">#打开全部</span><br>4lw.commands.<span class="hljs-attribute">whitelist</span>=*<br><span class="hljs-comment">#查看服务器及客户端连接状态</span><br>echo stat | nc localhost 2181<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo stat | nc localhost <span class="hljs-number">2181</span><br>stat is not executed because it is not in the whitelist.<br><br>## 打开全部nc命令<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot;</span> &gt;&gt; conf/zoo1.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot;</span> &gt;&gt; conf/zoo2.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot;</span> &gt;&gt; conf/zoo3.cfg<br><br>## 重启服务<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin ./bin/zkServer.sh restart conf/zoo1.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin ./bin/zkServer.sh restart conf/zoo2.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin ./bin/zkServer.sh restart conf/zoo3.cfg<br></code></pre></td></tr></table></figure><h3 id="ZXID说明"><a href="#ZXID说明" class="headerlink" title="ZXID说明"></a>ZXID说明</h3><blockquote><p>如何比对Leader的数据版本呢，这里通过ZXID事物ID来确认。比Leader小就需要同步。</p></blockquote><ul><li><p>ZXID是一个长度64位的数字，其中低32位是按照数字递增，任何数据的变更都会导致低32位的数字加1。</p></li><li><p>高32位是leader周期编号，每当选举出一个新的leader时，新的leader就从本地事物日志中取出ZXID,然后解析出高32位的周期编号，进行加1，再将低32位的全部设置为0。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是保证递增的。</p></li></ul><p> </p><p>eg1: 节点数据的变更</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223906822.png" alt="image-20230228223906822"></p><p>Eg2: 某个节点挂掉重新选举</p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223916530.png" alt="image-20230228223916530"></p><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/image-20230228223927521.png" alt="image-20230228223927521"></p><p><strong>思考题：</strong><br>如果leader 节点宕机，在恢复后它还能被选为leader吗？</p><p>不会，因为它的数据不是最新的。</p>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper客户端使用</title>
    <link href="/zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/"/>
    <url>/zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="客户端API常规应用"><a href="#客户端API常规应用" class="headerlink" title="客户端API常规应用"></a>客户端API常规应用</h2><hr><p>zookeeper 提供了java与C两种语言的客户端。我们要学习的就是java客户端。引入最新的maven依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;<br>  &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">3.6</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="初始连接"><a href="#初始连接" class="headerlink" title="初始连接"></a>初始连接</h2><p>常规的客户端类是 org.apache.zookeeper.ZooKeeper，实例化该类之后将会自动与集群建立连接。</p><ul><li>connectString    连接串，包括ip+端口 ,集群模式下用逗号隔开</li><li>sessionTimeout  会话超时时间，该值不能超过服务端所设置的 minSessionTimeout 和maxSessionTimeout</li><li>watcher 会话监听器，服务端事件将会触该监听</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">zooKeeper = <span class="hljs-keyword">new</span> ZooKeeper(<span class="hljs-string">&quot;192.168.2.103:2181&quot;</span>, <span class="hljs-number">4000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;init:&quot;</span>+watchedEvent.getPath());<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="创建、查看节点"><a href="#创建、查看节点" class="headerlink" title="创建、查看节点"></a>创建、查看节点</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>通过org.apache.zookeeper.ZooKeeper#create()即可创建节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  List&lt;ACL&gt; aclList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">int</span> perm = ZooDefs.Perms.ADMIN | ZooDefs.Perms.READ;<br>  <br>  <span class="hljs-comment">// perms 对应权限位permission</span><br>  <span class="hljs-comment">// id 对应权限模式scheme + id</span><br>  ACL acl1 = <span class="hljs-keyword">new</span> ACL(perm, <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;anyone&quot;</span>));<br>  ACL acl2 = <span class="hljs-keyword">new</span> ACL(perm, <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;ip&quot;</span>,<span class="hljs-string">&quot;192.168.2.103&quot;</span>));<br>  ACL acl3 = <span class="hljs-keyword">new</span> ACL(perm, <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;ip&quot;</span>,<span class="hljs-string">&quot;127.0.0.1&quot;</span>));<br><br>  aclList.add(acl1);<br>  aclList.add(acl2);<br>  aclList.add(acl3);<br>  zooKeeper.create(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-string">&quot;hello word!&quot;</span>.getBytes(), aclList, CreateMode.PERSISTENT);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行完成后，在zookeeper进行查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">64</span>] getAcl /hello<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: ra<br><span class="hljs-string">&#x27;ip,&#x27;</span><span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.103</span><br>: ra<br><span class="hljs-string">&#x27;ip,&#x27;</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>: ra<br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">65</span>] get /hello<br>hello word<br></code></pre></td></tr></table></figure><h3 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h3><h4 id="查看当前节点"><a href="#查看当前节点" class="headerlink" title="查看当前节点"></a>查看当前节点</h4><p>通过org.apache.zookeeper.ZooKeeper#getData()即可查看节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] keeperData = zooKeeper.getData(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>  System.out.println(<span class="hljs-string">&quot;testData:&quot;</span> + <span class="hljs-keyword">new</span> String(keeperData));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查看子节点"><a href="#查看子节点" class="headerlink" title="查看子节点"></a>查看子节点</h4><p>通过org.apache.zookeeper.ZooKeeper#getChildren()即可获取子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetChildrenWithoutWatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> List&lt;String&gt; children = zooKeeper.getChildren(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">false</span>);<br>  children.stream().forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="监听节点"><a href="#监听节点" class="headerlink" title="监听节点"></a>监听节点</h2><ul><li><p>在getData() 与getChildren()两个方法中可分别设置监听数据变化和子节点变化。</p></li><li><p>通过设置watch为true，当前事件触发时会调用zookeeper()构建函数中Watcher.process()方法。也可以添加watcher参数来实现自定义监听。一般采用后者。</p></li><li><p>所有的监听都是一次性的，如果要持续监听需要触发后在添加一次监听。</p></li></ul><p><strong>使用默认监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDataWithWatcher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] keeperData = zooKeeper.getData(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>);<br>  System.out.println(<span class="hljs-string">&quot;testGetDataWithWatcher:&quot;</span> + <span class="hljs-keyword">new</span> String(keeperData));<br>  Thread.sleep(Long.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDataWithCustomWatcher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] keeperData = zooKeeper.getData(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        zooKeeper.getData(<span class="hljs-string">&quot;/temp&quot;</span>, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (KeeperException | InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;testGetDataWithCustomWatcher:&quot;</span> + watchedEvent.getPath());<br><br>    &#125;<br>  &#125;, <span class="hljs-keyword">null</span>);<br>  Thread.sleep(Long.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三方客户端ZkClient"><a href="#第三方客户端ZkClient" class="headerlink" title="第三方客户端ZkClient"></a>第三方客户端ZkClient</h2><p>zkClient 是在zookeeper客户端基础之上封装的，使用上更加友好。主要变化如下：</p><ul><li>可以设置持久监听，或删除某个监听</li><li>可以插入JAVA对象，自动进行序列化和反序列化</li><li>简化了基本的增删改查操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
